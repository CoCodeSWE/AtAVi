<!doctype html>
<html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Mochawesome Report</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{
  &quot;stats&quot;: {
    &quot;suites&quot;: 136,
    &quot;tests&quot;: 185,
    &quot;passes&quot;: 180,
    &quot;pending&quot;: 0,
    &quot;failures&quot;: 5,
    &quot;start&quot;: &quot;2017-05-10T16:30:32.283Z&quot;,
    &quot;end&quot;: &quot;2017-05-10T16:30:37.359Z&quot;,
    &quot;duration&quot;: 5076,
    &quot;testsRegistered&quot;: 185,
    &quot;passPercent&quot;: 97.3,
    &quot;pendingPercent&quot;: 0,
    &quot;other&quot;: 0,
    &quot;hasOther&quot;: false,
    &quot;skipped&quot;: 0,
    &quot;hasSkipped&quot;: false,
    &quot;passPercentClass&quot;: &quot;success&quot;,
    &quot;pendingPercentClass&quot;: &quot;danger&quot;
  },
  &quot;suites&quot;: {
    &quot;title&quot;: &quot;&quot;,
    &quot;suites&quot;: [
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;AdministrationWebhookService&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;webhook&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
                    &quot;fullTitle&quot;: &quot;AdministrationWebhookService webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;201c125c-f6b5-4b67-b6b8-e0ab539e4842&quot;,
                    &quot;parentUUID&quot;: &quot;6484bb47-e148-4798-a478-e126cd9f5af4&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
                    &quot;fullTitle&quot;: &quot;AdministrationWebhookService webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;5775b128-2941-4e79-b0f9-2f15bae2e18c&quot;,
                    &quot;parentUUID&quot;: &quot;6484bb47-e148-4798-a478-e126cd9f5af4&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_AdministrationWebhookService.js&quot;,
                &quot;uuid&quot;: &quot;6484bb47-e148-4798-a478-e126cd9f5af4&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AdministrationWebhookService.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
                    &quot;fullTitle&quot;: &quot;AdministrationWebhookService webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;201c125c-f6b5-4b67-b6b8-e0ab539e4842&quot;,
                    &quot;parentUUID&quot;: &quot;6484bb47-e148-4798-a478-e126cd9f5af4&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
                    &quot;fullTitle&quot;: &quot;AdministrationWebhookService webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;5775b128-2941-4e79-b0f9-2f15bae2e18c&quot;,
                    &quot;parentUUID&quot;: &quot;6484bb47-e148-4798-a478-e126cd9f5af4&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 2,
                &quot;totalPasses&quot;: 2,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 3,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_AdministrationWebhookService.js&quot;,
            &quot;uuid&quot;: &quot;84f26181-e6e2-4c3c-aff1-bbb805e449c2&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AdministrationWebhookService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_AdministrationWebhookService.js&quot;,
        &quot;uuid&quot;: &quot;aeb849e4-db6c-4a14-a7db-27b32f050600&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AdministrationWebhookService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Agents&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;AgentsDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addAgent&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4da8d2f8-44be-4fc5-bd31-9399d1ae3461&quot;,
                        &quot;parentUUID&quot;: &quot;1a1cd1c9-e32c-4605-ab3c-44f3e6c80553&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;600ac6f5-2684-4558-8ea7-87de516f8c5c&quot;,
                        &quot;parentUUID&quot;: &quot;1a1cd1c9-e32c-4605-ab3c-44f3e6c80553&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;1a1cd1c9-e32c-4605-ab3c-44f3e6c80553&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4da8d2f8-44be-4fc5-bd31-9399d1ae3461&quot;,
                        &quot;parentUUID&quot;: &quot;1a1cd1c9-e32c-4605-ab3c-44f3e6c80553&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;600ac6f5-2684-4558-8ea7-87de516f8c5c&quot;,
                        &quot;parentUUID&quot;: &quot;1a1cd1c9-e32c-4605-ab3c-44f3e6c80553&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getAgent&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgent Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;681c5cee-913f-4bf7-9b44-aeabca68166e&quot;,
                        &quot;parentUUID&quot;: &quot;c934c740-0a08-4849-81ea-8a20b57e4b4b&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgent Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = agents.getAgent(&#x27;mock_name&#x27;);\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;038a2e14-ab14-4ebe-bac6-e00d98b72213&quot;,
                        &quot;parentUUID&quot;: &quot;c934c740-0a08-4849-81ea-8a20b57e4b4b&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;c934c740-0a08-4849-81ea-8a20b57e4b4b&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgent Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;681c5cee-913f-4bf7-9b44-aeabca68166e&quot;,
                        &quot;parentUUID&quot;: &quot;c934c740-0a08-4849-81ea-8a20b57e4b4b&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgent Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = agents.getAgent(&#x27;mock_name&#x27;);\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;038a2e14-ab14-4ebe-bac6-e00d98b72213&quot;,
                        &quot;parentUUID&quot;: &quot;c934c740-0a08-4849-81ea-8a20b57e4b4b&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getAgentList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;2&#x27;});\ndynamo_client.scan.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e5cd0e7f-01ac-4fb0-b4eb-bb04696c2ba5&quot;,
                        &quot;parentUUID&quot;: &quot;049f22aa-b4ad-48ee-8742-1bf878841a37&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgentList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b179bf2e-796b-4e79-805d-cffd322e0b26&quot;,
                        &quot;parentUUID&quot;: &quot;049f22aa-b4ad-48ee-8742-1bf878841a37&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;049f22aa-b4ad-48ee-8742-1bf878841a37&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;2&#x27;});\ndynamo_client.scan.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e5cd0e7f-01ac-4fb0-b4eb-bb04696c2ba5&quot;,
                        &quot;parentUUID&quot;: &quot;049f22aa-b4ad-48ee-8742-1bf878841a37&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgentList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b179bf2e-796b-4e79-805d-cffd322e0b26&quot;,
                        &quot;parentUUID&quot;: &quot;049f22aa-b4ad-48ee-8742-1bf878841a37&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 4,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeAgent&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB removeAgent Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\&quot;error removing rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;79b91142-dd47-48bd-9fa1-2957bc46d414&quot;,
                        &quot;parentUUID&quot;: &quot;91d34988-c360-4ba4-a4bb-a4b9cbb75abc&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB removeAgent Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\&quot;success\&quot;});\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e4ec6986-86a1-44ae-89f2-6b43c0c935aa&quot;,
                        &quot;parentUUID&quot;: &quot;91d34988-c360-4ba4-a4bb-a4b9cbb75abc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;91d34988-c360-4ba4-a4bb-a4b9cbb75abc&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB removeAgent Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\&quot;error removing rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;79b91142-dd47-48bd-9fa1-2957bc46d414&quot;,
                        &quot;parentUUID&quot;: &quot;91d34988-c360-4ba4-a4bb-a4b9cbb75abc&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB removeAgent Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\&quot;success\&quot;});\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e4ec6986-86a1-44ae-89f2-6b43c0c935aa&quot;,
                        &quot;parentUUID&quot;: &quot;91d34988-c360-4ba4-a4bb-a4b9cbb75abc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateAgent&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB updateAgent Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c9e304b9-0940-40ee-a2b0-412e32492ff1&quot;,
                        &quot;parentUUID&quot;: &quot;8b278e1f-34f1-4b84-bf8e-95c49ae8e66f&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB updateAgent Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9d9e1bc4-9000-4388-9d12-9f089ae581e5&quot;,
                        &quot;parentUUID&quot;: &quot;8b278e1f-34f1-4b84-bf8e-95c49ae8e66f&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;8b278e1f-34f1-4b84-bf8e-95c49ae8e66f&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB updateAgent Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c9e304b9-0940-40ee-a2b0-412e32492ff1&quot;,
                        &quot;parentUUID&quot;: &quot;8b278e1f-34f1-4b84-bf8e-95c49ae8e66f&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB updateAgent Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9d9e1bc4-9000-4388-9d12-9f089ae581e5&quot;,
                        &quot;parentUUID&quot;: &quot;8b278e1f-34f1-4b84-bf8e-95c49ae8e66f&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 5,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;4c469143-a81a-41b0-b327-69d39e6998f4&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;df740f6c-e6c8-4dbe-b6f8-168b2cd55ff9&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;eaf145fe-fc2b-43ee-bfb4-73822950cce9&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;VirtualAssistant&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;ApiAiVAAdapter&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;query&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
                        &quot;fullTitle&quot;: &quot;ApiAiVAAdapter query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;892857aa-c38d-463b-83a9-acd3fc8f120a&quot;,
                        &quot;parentUUID&quot;: &quot;03ac273a-cbcb-4429-bb54-d233bbdf76da&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
                        &quot;fullTitle&quot;: &quot;ApiAiVAAdapter query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cedd67b2-da02-4f20-b5e8-58eeace39d3c&quot;,
                        &quot;parentUUID&quot;: &quot;03ac273a-cbcb-4429-bb54-d233bbdf76da&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ApiAiVAAdapter.js&quot;,
                    &quot;uuid&quot;: &quot;03ac273a-cbcb-4429-bb54-d233bbdf76da&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
                        &quot;fullTitle&quot;: &quot;ApiAiVAAdapter query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;892857aa-c38d-463b-83a9-acd3fc8f120a&quot;,
                        &quot;parentUUID&quot;: &quot;03ac273a-cbcb-4429-bb54-d233bbdf76da&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
                        &quot;fullTitle&quot;: &quot;ApiAiVAAdapter query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cedd67b2-da02-4f20-b5e8-58eeace39d3c&quot;,
                        &quot;parentUUID&quot;: &quot;03ac273a-cbcb-4429-bb54-d233bbdf76da&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 4,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ApiAiVAAdapter.js&quot;,
                &quot;uuid&quot;: &quot;c7fcadee-5924-46eb-8c00-c7018e67c0ab&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ApiAiVAAdapter.js&quot;,
            &quot;uuid&quot;: &quot;ab0807e4-0856-4420-a407-612dffea94d4&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ApiAiVAAdapter.js&quot;,
        &quot;uuid&quot;: &quot;504e3c28-8a91-4988-9799-9f430f72e560&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Conversations&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;ConversationsDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addConversation&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \&quot;Requested resource not found\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;56edd907-668d-4063-bb19-8217cca5a6f0&quot;,
                        &quot;parentUUID&quot;: &quot;dd30394a-09cb-4e9e-a8f9-5927dd88e4f4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5d18a45e-92d8-4cd2-8938-97f8fe337bd7&quot;,
                        &quot;parentUUID&quot;: &quot;dd30394a-09cb-4e9e-a8f9-5927dd88e4f4&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;dd30394a-09cb-4e9e-a8f9-5927dd88e4f4&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \&quot;Requested resource not found\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;56edd907-668d-4063-bb19-8217cca5a6f0&quot;,
                        &quot;parentUUID&quot;: &quot;dd30394a-09cb-4e9e-a8f9-5927dd88e4f4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5d18a45e-92d8-4cd2-8938-97f8fe337bd7&quot;,
                        &quot;parentUUID&quot;: &quot;dd30394a-09cb-4e9e-a8f9-5927dd88e4f4&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;addMessage&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \&quot;error adding message\&quot; });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d194eb24-0c42-462f-b421-22aa7e3d460b&quot;,
                        &quot;parentUUID&quot;: &quot;8d4834da-337d-4b24-806d-a3a5ec17993a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;615d8d34-d57d-4855-a3c8-7143abe05c42&quot;,
                        &quot;parentUUID&quot;: &quot;8d4834da-337d-4b24-806d-a3a5ec17993a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;8d4834da-337d-4b24-806d-a3a5ec17993a&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \&quot;error adding message\&quot; });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d194eb24-0c42-462f-b421-22aa7e3d460b&quot;,
                        &quot;parentUUID&quot;: &quot;8d4834da-337d-4b24-806d-a3a5ec17993a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;615d8d34-d57d-4855-a3c8-7143abe05c42&quot;,
                        &quot;parentUUID&quot;: &quot;8d4834da-337d-4b24-806d-a3a5ec17993a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getConversation&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \&quot;error downloading conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ab391d2a-b749-46e6-9140-ed7e02c93382&quot;,
                        &quot;parentUUID&quot;: &quot;b5e2d499-efac-4754-ae6c-c6f2760e032b&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversation Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;449f94e7-2a51-41c5-8b40-96420ade2565&quot;,
                        &quot;parentUUID&quot;: &quot;b5e2d499-efac-4754-ae6c-c6f2760e032b&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;b5e2d499-efac-4754-ae6c-c6f2760e032b&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \&quot;error downloading conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ab391d2a-b749-46e6-9140-ed7e02c93382&quot;,
                        &quot;parentUUID&quot;: &quot;b5e2d499-efac-4754-ae6c-c6f2760e032b&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversation Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;449f94e7-2a51-41c5-8b40-96420ade2565&quot;,
                        &quot;parentUUID&quot;: &quot;b5e2d499-efac-4754-ae6c-c6f2760e032b&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getConversationList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;86d12a60-ec59-4149-b2cd-6110b5e6f02e&quot;,
                        &quot;parentUUID&quot;: &quot;9331cd11-da9d-4bb6-a549-ce15952ba0c2&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversationList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ce356d05-8bc9-4525-9d1e-d36749e2eb16&quot;,
                        &quot;parentUUID&quot;: &quot;9331cd11-da9d-4bb6-a549-ce15952ba0c2&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;9331cd11-da9d-4bb6-a549-ce15952ba0c2&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;86d12a60-ec59-4149-b2cd-6110b5e6f02e&quot;,
                        &quot;parentUUID&quot;: &quot;9331cd11-da9d-4bb6-a549-ce15952ba0c2&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversationList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ce356d05-8bc9-4525-9d1e-d36749e2eb16&quot;,
                        &quot;parentUUID&quot;: &quot;9331cd11-da9d-4bb6-a549-ce15952ba0c2&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeConversation&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0ce15b90-37b9-4438-a8cf-06ff889498ad&quot;,
                        &quot;parentUUID&quot;: &quot;f940f770-7e3e-4d84-a478-7ad367391deb&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;53a18a88-6848-4b64-9cc2-8ee2675fd2b3&quot;,
                        &quot;parentUUID&quot;: &quot;f940f770-7e3e-4d84-a478-7ad367391deb&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;f940f770-7e3e-4d84-a478-7ad367391deb&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0ce15b90-37b9-4438-a8cf-06ff889498ad&quot;,
                        &quot;parentUUID&quot;: &quot;f940f770-7e3e-4d84-a478-7ad367391deb&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;53a18a88-6848-4b64-9cc2-8ee2675fd2b3&quot;,
                        &quot;parentUUID&quot;: &quot;f940f770-7e3e-4d84-a478-7ad367391deb&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;93111115-fb4b-45d0-829a-11bcf44e66ac&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;4f88429f-a96d-4f9c-81c5-890ba6c6c77a&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;99b89665-a681-41ed-b72c-641c1807286b&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;ConversationWebhookService&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;webhook&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
                    &quot;fullTitle&quot;: &quot;ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 8,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;body.result.action = &#x27;user.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;admin&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;e6e13f06-dc13-484f-945e-5dd2217d7484&quot;,
                    &quot;parentUUID&quot;: &quot;4fc2923c-f1f2-4f37-8fae-3076405c0b5b&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
                    &quot;fullTitle&quot;: &quot;ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;body.result.action = &#x27;guest.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;, company : \&quot;Google\&quot;}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;welcome&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;b4e6c206-b90d-484b-99fc-9b01000d66bd&quot;,
                    &quot;parentUUID&quot;: &quot;4fc2923c-f1f2-4f37-8fae-3076405c0b5b&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ConversationWebhookService.js&quot;,
                &quot;uuid&quot;: &quot;4fc2923c-f1f2-4f37-8fae-3076405c0b5b&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationWebhookService.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
                    &quot;fullTitle&quot;: &quot;ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 8,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;body.result.action = &#x27;user.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;admin&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;e6e13f06-dc13-484f-945e-5dd2217d7484&quot;,
                    &quot;parentUUID&quot;: &quot;4fc2923c-f1f2-4f37-8fae-3076405c0b5b&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
                    &quot;fullTitle&quot;: &quot;ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;body.result.action = &#x27;guest.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;, company : \&quot;Google\&quot;}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;welcome&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;b4e6c206-b90d-484b-99fc-9b01000d66bd&quot;,
                    &quot;parentUUID&quot;: &quot;4fc2923c-f1f2-4f37-8fae-3076405c0b5b&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 2,
                &quot;totalPasses&quot;: 2,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 10,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ConversationWebhookService.js&quot;,
            &quot;uuid&quot;: &quot;bb739d7f-19d0-479c-bf29-85084e83755c&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationWebhookService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ConversationWebhookService.js&quot;,
        &quot;uuid&quot;: &quot;cf1371bd-7e56-4c52-8ec8-72f523d83133&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationWebhookService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Libs&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;ErrorObserver&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;next&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ErrorObserver next Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;expect(obs.next.bind(obs)).to.throw();&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;7c5a8cf7-c3a7-4ee6-8d73-f33bbe2cf0ed&quot;,
                    &quot;parentUUID&quot;: &quot;cdc0f1c0-5b38-4d08-9a7f-39d0beaefa22&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ErrorObserver.js&quot;,
                &quot;uuid&quot;: &quot;cdc0f1c0-5b38-4d08-9a7f-39d0beaefa22&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ErrorObserver.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ErrorObserver next Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;expect(obs.next.bind(obs)).to.throw();&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;7c5a8cf7-c3a7-4ee6-8d73-f33bbe2cf0ed&quot;,
                    &quot;parentUUID&quot;: &quot;cdc0f1c0-5b38-4d08-9a7f-39d0beaefa22&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 1,
                &quot;totalPasses&quot;: 1,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 1,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ErrorObserver.js&quot;,
            &quot;uuid&quot;: &quot;52566cfa-727b-45da-bed1-b0bf2b238d3d&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ErrorObserver.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ErrorObserver.js&quot;,
        &quot;uuid&quot;: &quot;ef7702e3-ab3e-49d9-b3ab-86a568f0372d&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ErrorObserver.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Guests&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;GuestsDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addGuest&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fd3fabb5-6ce2-4017-a233-ed53abda4369&quot;,
                        &quot;parentUUID&quot;: &quot;e15832d4-001c-471f-8eb3-9d46f147d3e0&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addGuest Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addGuest(&#x27;mauro&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c33f5247-5d82-4766-9891-8bae8aed8e0f&quot;,
                        &quot;parentUUID&quot;: &quot;e15832d4-001c-471f-8eb3-9d46f147d3e0&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;e15832d4-001c-471f-8eb3-9d46f147d3e0&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fd3fabb5-6ce2-4017-a233-ed53abda4369&quot;,
                        &quot;parentUUID&quot;: &quot;e15832d4-001c-471f-8eb3-9d46f147d3e0&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addGuest Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addGuest(&#x27;mauro&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c33f5247-5d82-4766-9891-8bae8aed8e0f&quot;,
                        &quot;parentUUID&quot;: &quot;e15832d4-001c-471f-8eb3-9d46f147d3e0&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getGuest&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \&quot;error getting data\&quot; });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e400a3d1-0f97-444b-8d42-6a98bbac998a&quot;,
                        &quot;parentUUID&quot;: &quot;4d7bde28-3b1b-49b0-a43f-dac96e770980&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuest Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \&quot;Mauro\&quot;);\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\&quot;Zero12\&quot;);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a9510da0-ceb7-45a9-b28e-8898b3774e93&quot;,
                        &quot;parentUUID&quot;: &quot;4d7bde28-3b1b-49b0-a43f-dac96e770980&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;4d7bde28-3b1b-49b0-a43f-dac96e770980&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \&quot;error getting data\&quot; });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e400a3d1-0f97-444b-8d42-6a98bbac998a&quot;,
                        &quot;parentUUID&quot;: &quot;4d7bde28-3b1b-49b0-a43f-dac96e770980&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuest Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \&quot;Mauro\&quot;);\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\&quot;Zero12\&quot;);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a9510da0-ceb7-45a9-b28e-8898b3774e93&quot;,
                        &quot;parentUUID&quot;: &quot;4d7bde28-3b1b-49b0-a43f-dac96e770980&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getGuestList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }], LastEvaluatedKey: &#x27;Luca&#x27;});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;adad55a9-79e2-43b1-b571-fd5d8bc93f74&quot;,
                        &quot;parentUUID&quot;: &quot;fb50a842-aba7-401b-8d88-ba5b8cabc0e6&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuestList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 8,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;52254194-5b02-457d-9b96-3962b59aabeb&quot;,
                        &quot;parentUUID&quot;: &quot;fb50a842-aba7-401b-8d88-ba5b8cabc0e6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;fb50a842-aba7-401b-8d88-ba5b8cabc0e6&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }], LastEvaluatedKey: &#x27;Luca&#x27;});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;adad55a9-79e2-43b1-b571-fd5d8bc93f74&quot;,
                        &quot;parentUUID&quot;: &quot;fb50a842-aba7-401b-8d88-ba5b8cabc0e6&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuestList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 8,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;52254194-5b02-457d-9b96-3962b59aabeb&quot;,
                        &quot;parentUUID&quot;: &quot;fb50a842-aba7-401b-8d88-ba5b8cabc0e6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 9,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeGuest&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing guest\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;645b7505-cd3a-4d03-b7de-71d5165bffa6&quot;,
                        &quot;parentUUID&quot;: &quot;559c0e51-e662-41e8-b03d-25aa60b9ccf3&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB removeGuest Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7ff14c2c-ad04-49e7-8090-808d7a93addb&quot;,
                        &quot;parentUUID&quot;: &quot;559c0e51-e662-41e8-b03d-25aa60b9ccf3&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;559c0e51-e662-41e8-b03d-25aa60b9ccf3&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing guest\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;645b7505-cd3a-4d03-b7de-71d5165bffa6&quot;,
                        &quot;parentUUID&quot;: &quot;559c0e51-e662-41e8-b03d-25aa60b9ccf3&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB removeGuest Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7ff14c2c-ad04-49e7-8090-808d7a93addb&quot;,
                        &quot;parentUUID&quot;: &quot;559c0e51-e662-41e8-b03d-25aa60b9ccf3&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateGuest&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating guest\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;da58b96b-8c62-4f1b-85eb-39740939df91&quot;,
                        &quot;parentUUID&quot;: &quot;499995c5-faa2-43ef-8b2c-ba41633e99af&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;754b4d11-15fd-40ce-96a0-3479e15d1f46&quot;,
                        &quot;parentUUID&quot;: &quot;499995c5-faa2-43ef-8b2c-ba41633e99af&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;499995c5-faa2-43ef-8b2c-ba41633e99af&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating guest\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;da58b96b-8c62-4f1b-85eb-39740939df91&quot;,
                        &quot;parentUUID&quot;: &quot;499995c5-faa2-43ef-8b2c-ba41633e99af&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;754b4d11-15fd-40ce-96a0-3479e15d1f46&quot;,
                        &quot;parentUUID&quot;: &quot;499995c5-faa2-43ef-8b2c-ba41633e99af&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;addConversation&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addConversation Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c8166c54-da6a-4e3e-ae1d-597680253c34&quot;,
                        &quot;parentUUID&quot;: &quot;3ae86c4f-6fed-4e0d-bd85-49d57775793c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addConversation Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1cdf300d-39d1-4e18-a54d-247cdcc39d02&quot;,
                        &quot;parentUUID&quot;: &quot;3ae86c4f-6fed-4e0d-bd85-49d57775793c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;3ae86c4f-6fed-4e0d-bd85-49d57775793c&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addConversation Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c8166c54-da6a-4e3e-ae1d-597680253c34&quot;,
                        &quot;parentUUID&quot;: &quot;3ae86c4f-6fed-4e0d-bd85-49d57775793c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addConversation Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1cdf300d-39d1-4e18-a54d-247cdcc39d02&quot;,
                        &quot;parentUUID&quot;: &quot;3ae86c4f-6fed-4e0d-bd85-49d57775793c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;d87070bc-880f-49ba-a5bb-cbf22a348ed0&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;241b2dee-c3a5-464e-be61-d48dd5b3c179&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;23af84e8-8e4c-4c58-a0a1-690a70b39b63&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Members&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;MembersDAOSlack&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addMember&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack addMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.addMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7e20bd8e-cb26-4cac-9af6-b7ee0608b286&quot;,
                        &quot;parentUUID&quot;: &quot;3fe428d4-204c-47cf-8f62-93e47a030d01&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;3fe428d4-204c-47cf-8f62-93e47a030d01&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack addMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.addMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7e20bd8e-cb26-4cac-9af6-b7ee0608b286&quot;,
                        &quot;parentUUID&quot;: &quot;3fe428d4-204c-47cf-8f62-93e47a030d01&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getMember&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMember Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t&#x27;ok&#x27;: true,\n\t&#x27;user&#x27;:\n\t{\n\t\t&#x27;id&#x27;: &#x27;U023BECGF&#x27;,\n\t\t&#x27;name&#x27;: &#x27;bobby&#x27;,\n\t\t&#x27;deleted&#x27;: false,\n\t\t&#x27;color&#x27;: &#x27;9f69e7&#x27;,\n\t\t&#x27;profile&#x27;:\n\t\t{\n\t\t\t&#x27;avatar_hash&#x27;: &#x27;ge3b51ca72de&#x27;,\n\t\t\t&#x27;current_status&#x27;: &#x27;:mountain_railway: riding a train&#x27;,\n\t\t\t&#x27;first_name&#x27;: &#x27;Bobby&#x27;,\n\t\t\t&#x27;last_name&#x27;: &#x27;Tables&#x27;,\n\t\t\t&#x27;real_name&#x27;: &#x27;Bobby Tables&#x27;,\n\t\t\t&#x27;email&#x27;: &#x27;bobby@slack.com&#x27;,\n\t\t\t&#x27;skype&#x27;: &#x27;my-skype-name&#x27;,\n\t\t\t&#x27;phone&#x27;: &#x27;+1 (123) 456 7890&#x27;\n\t\t},\n\t\t&#x27;is_admin&#x27;: true,\n\t\t&#x27;is_owner&#x27;: true,\n\t\t&#x27;updated&#x27;: 1490054400,\n\t\t&#x27;has_2fa&#x27;: true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f5aff198-7e6c-496c-a9eb-6ecf1d6de1fe&quot;,
                        &quot;parentUUID&quot;: &quot;3381f674-c74c-4cc9-94d6-cccf8c3aea50&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMember Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;21969e3b-5d80-4e79-966d-388b8c02b590&quot;,
                        &quot;parentUUID&quot;: &quot;3381f674-c74c-4cc9-94d6-cccf8c3aea50&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;3381f674-c74c-4cc9-94d6-cccf8c3aea50&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMember Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t&#x27;ok&#x27;: true,\n\t&#x27;user&#x27;:\n\t{\n\t\t&#x27;id&#x27;: &#x27;U023BECGF&#x27;,\n\t\t&#x27;name&#x27;: &#x27;bobby&#x27;,\n\t\t&#x27;deleted&#x27;: false,\n\t\t&#x27;color&#x27;: &#x27;9f69e7&#x27;,\n\t\t&#x27;profile&#x27;:\n\t\t{\n\t\t\t&#x27;avatar_hash&#x27;: &#x27;ge3b51ca72de&#x27;,\n\t\t\t&#x27;current_status&#x27;: &#x27;:mountain_railway: riding a train&#x27;,\n\t\t\t&#x27;first_name&#x27;: &#x27;Bobby&#x27;,\n\t\t\t&#x27;last_name&#x27;: &#x27;Tables&#x27;,\n\t\t\t&#x27;real_name&#x27;: &#x27;Bobby Tables&#x27;,\n\t\t\t&#x27;email&#x27;: &#x27;bobby@slack.com&#x27;,\n\t\t\t&#x27;skype&#x27;: &#x27;my-skype-name&#x27;,\n\t\t\t&#x27;phone&#x27;: &#x27;+1 (123) 456 7890&#x27;\n\t\t},\n\t\t&#x27;is_admin&#x27;: true,\n\t\t&#x27;is_owner&#x27;: true,\n\t\t&#x27;updated&#x27;: 1490054400,\n\t\t&#x27;has_2fa&#x27;: true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f5aff198-7e6c-496c-a9eb-6ecf1d6de1fe&quot;,
                        &quot;parentUUID&quot;: &quot;3381f674-c74c-4cc9-94d6-cccf8c3aea50&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMember Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;21969e3b-5d80-4e79-966d-388b8c02b590&quot;,
                        &quot;parentUUID&quot;: &quot;3381f674-c74c-4cc9-94d6-cccf8c3aea50&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getMemberList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMemberList L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\&quot;ok\&quot;: true,\n\t\&quot;members\&quot;:\n\t[\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECGF\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;mauro\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Mauro Bocciofilo\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t},\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECLL\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;bobby\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;,\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;313b15cc-32f0-4515-ac05-7269b708287b&quot;,
                        &quot;parentUUID&quot;: &quot;ff91f221-b873-4648-a873-3ded9e313b2e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMemberList Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;928f9f7d-fa05-4392-a4cc-7ddbcfb758bd&quot;,
                        &quot;parentUUID&quot;: &quot;ff91f221-b873-4648-a873-3ded9e313b2e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;ff91f221-b873-4648-a873-3ded9e313b2e&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMemberList L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\&quot;ok\&quot;: true,\n\t\&quot;members\&quot;:\n\t[\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECGF\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;mauro\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Mauro Bocciofilo\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t},\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECLL\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;bobby\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;,\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;313b15cc-32f0-4515-ac05-7269b708287b&quot;,
                        &quot;parentUUID&quot;: &quot;ff91f221-b873-4648-a873-3ded9e313b2e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMemberList Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;928f9f7d-fa05-4392-a4cc-7ddbcfb758bd&quot;,
                        &quot;parentUUID&quot;: &quot;ff91f221-b873-4648-a873-3ded9e313b2e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeMember&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack removeMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.removeMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;22183424-d062-4633-a0f9-33115a71c3ff&quot;,
                        &quot;parentUUID&quot;: &quot;9541b917-ea95-44ae-b0ae-7ff27606a3fc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;9541b917-ea95-44ae-b0ae-7ff27606a3fc&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack removeMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.removeMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;22183424-d062-4633-a0f9-33115a71c3ff&quot;,
                        &quot;parentUUID&quot;: &quot;9541b917-ea95-44ae-b0ae-7ff27606a3fc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateMember&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack updateMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.updateMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a59f1c23-335f-4238-a817-b005191ad772&quot;,
                        &quot;parentUUID&quot;: &quot;df457aae-a51f-4a21-83b7-1ec667a3b385&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;df457aae-a51f-4a21-83b7-1ec667a3b385&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack updateMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.updateMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a59f1c23-335f-4238-a817-b005191ad772&quot;,
                        &quot;parentUUID&quot;: &quot;df457aae-a51f-4a21-83b7-1ec667a3b385&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                &quot;uuid&quot;: &quot;2abd0b08-f4dc-43af-a914-2e4650761095&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
            &quot;uuid&quot;: &quot;dd7fe82b-9f9d-4110-8b47-b12ac8662961&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
        &quot;uuid&quot;: &quot;87b08580-13ca-44d5-9fc9-92ca5b3c9a6b&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Notifications&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;NotificationService&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;getChannelList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(&#x27;errore&#x27;);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n  done();\n}&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9c311b52-f5c8-4852-9a29-2deac3d26db6&quot;,
                        &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields(&#x27;errore&#x27;);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;318761ec-5f8a-4dec-9ecc-3ba81bc9bade&quot;,
                        &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(&#x27;errore&#x27;);\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;70e4010d-0d73-461d-af4e-72674e144954&quot;,
                        &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 200);\n  done();\n}&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;eeb7b1ea-d646-41b4-94fc-4ea1a6aa2ca4&quot;,
                        &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
                    &quot;uuid&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(&#x27;errore&#x27;);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n  done();\n}&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9c311b52-f5c8-4852-9a29-2deac3d26db6&quot;,
                        &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields(&#x27;errore&#x27;);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;318761ec-5f8a-4dec-9ecc-3ba81bc9bade&quot;,
                        &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(&#x27;errore&#x27;);\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;70e4010d-0d73-461d-af4e-72674e144954&quot;,
                        &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 200);\n  done();\n}&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;eeb7b1ea-d646-41b4-94fc-4ea1a6aa2ca4&quot;,
                        &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 4,
                    &quot;totalPasses&quot;: 4,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 7,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;sendMsg&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {request_event};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(&#x27;errore&#x27;);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: stub cannot yield since it was not yet invoked.\n  at Function.&lt;anonymous&gt; (node_modules\\sinon\\lib\\sinon\\spy.js:414:11)\n  at Function.spyApi.(anonymous function) (node_modules\\sinon\\lib\\sinon\\spy.js:361:34)\n  at Context.&lt;anonymous&gt; (src\\test\\test_NotificationService.js:89:35)\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2f29a161-60fb-4b3e-ad34-247098a6a5ae&quot;,
                        &quot;parentUUID&quot;: &quot;2c206f5e-4ebe-485e-9347-381c69ff29d5&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {request_event};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: stub cannot yield since it was not yet invoked.\n  at Function.&lt;anonymous&gt; (node_modules\\sinon\\lib\\sinon\\spy.js:414:11)\n  at Function.spyApi.(anonymous function) (node_modules\\sinon\\lib\\sinon\\spy.js:361:34)\n  at Context.&lt;anonymous&gt; (src\\test\\test_NotificationService.js:101:35)\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2844f821-55eb-4d34-b908-b6d5917f4c9c&quot;,
                        &quot;parentUUID&quot;: &quot;2c206f5e-4ebe-485e-9347-381c69ff29d5&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;TypeError: Cannot read property &#x27;channel&#x27; of undefined\n  at NotificationService.sendMsg (src\\Back-end\\Notifications\\NotificationService.js:175:39)\n  at Context.&lt;anonymous&gt; (src\\test\\test_NotificationService.js:112:14)\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3595d29e-ca2e-4a2c-a311-c3709da6be72&quot;,
                        &quot;parentUUID&quot;: &quot;2c206f5e-4ebe-485e-9347-381c69ff29d5&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
                    &quot;uuid&quot;: &quot;2c206f5e-4ebe-485e-9347-381c69ff29d5&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
                    &quot;passes&quot;: [],
                    &quot;failures&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {request_event};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(&#x27;errore&#x27;);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: stub cannot yield since it was not yet invoked.\n  at Function.&lt;anonymous&gt; (node_modules\\sinon\\lib\\sinon\\spy.js:414:11)\n  at Function.spyApi.(anonymous function) (node_modules\\sinon\\lib\\sinon\\spy.js:361:34)\n  at Context.&lt;anonymous&gt; (src\\test\\test_NotificationService.js:89:35)\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2f29a161-60fb-4b3e-ad34-247098a6a5ae&quot;,
                        &quot;parentUUID&quot;: &quot;2c206f5e-4ebe-485e-9347-381c69ff29d5&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {request_event};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: stub cannot yield since it was not yet invoked.\n  at Function.&lt;anonymous&gt; (node_modules\\sinon\\lib\\sinon\\spy.js:414:11)\n  at Function.spyApi.(anonymous function) (node_modules\\sinon\\lib\\sinon\\spy.js:361:34)\n  at Context.&lt;anonymous&gt; (src\\test\\test_NotificationService.js:101:35)\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2844f821-55eb-4d34-b908-b6d5917f4c9c&quot;,
                        &quot;parentUUID&quot;: &quot;2c206f5e-4ebe-485e-9347-381c69ff29d5&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;TypeError: Cannot read property &#x27;channel&#x27; of undefined\n  at NotificationService.sendMsg (src\\Back-end\\Notifications\\NotificationService.js:175:39)\n  at Context.&lt;anonymous&gt; (src\\test\\test_NotificationService.js:112:14)\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3595d29e-ca2e-4a2c-a311-c3709da6be72&quot;,
                        &quot;parentUUID&quot;: &quot;2c206f5e-4ebe-485e-9347-381c69ff29d5&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 0,
                    &quot;totalFailures&quot;: 3,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: false,
                    &quot;hasFailures&quot;: true,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
                &quot;uuid&quot;: &quot;af3e616c-7999-4561-a359-28a11008c680&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
            &quot;uuid&quot;: &quot;4ebcc833-4c3e-4b0f-8227-5a43fc6f91f3&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
        &quot;uuid&quot;: &quot;b8550b75-0ba9-40fa-8d41-4d8a9508f77b&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Libs&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;ObserverAdapter&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;complete&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare complete_cb&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Deve chiamare complete_cb&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \&quot;il callback di complete non è stato chiamato esattamente una volta.\&quot;).to.equal(1);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;f05c49c7-ff67-4d26-a4aa-f394d94f4612&quot;,
                    &quot;parentUUID&quot;: &quot;9a7462f3-8afc-407d-addb-97283a8885e1&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;73738efc-3aa6-490e-b2c4-3835df6ef3ba&quot;,
                    &quot;parentUUID&quot;: &quot;9a7462f3-8afc-407d-addb-97283a8885e1&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;fc9943c7-4942-48d6-9c3d-4bf5a1b0c35e&quot;,
                    &quot;parentUUID&quot;: &quot;9a7462f3-8afc-407d-addb-97283a8885e1&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;uuid&quot;: &quot;9a7462f3-8afc-407d-addb-97283a8885e1&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare complete_cb&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Deve chiamare complete_cb&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \&quot;il callback di complete non è stato chiamato esattamente una volta.\&quot;).to.equal(1);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;f05c49c7-ff67-4d26-a4aa-f394d94f4612&quot;,
                    &quot;parentUUID&quot;: &quot;9a7462f3-8afc-407d-addb-97283a8885e1&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;73738efc-3aa6-490e-b2c4-3835df6ef3ba&quot;,
                    &quot;parentUUID&quot;: &quot;9a7462f3-8afc-407d-addb-97283a8885e1&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;fc9943c7-4942-48d6-9c3d-4bf5a1b0c35e&quot;,
                    &quot;parentUUID&quot;: &quot;9a7462f3-8afc-407d-addb-97283a8885e1&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 3,
                &quot;totalPasses&quot;: 3,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 1,
                &quot;rootEmpty&quot;: false
              },
              {
                &quot;title&quot;: &quot;error&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare error_cb&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Deve chiamare error_cb&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;f16d7a0f-0b7c-4381-99cd-41e1b009a3cb&quot;,
                    &quot;parentUUID&quot;: &quot;49c37700-2b2b-44aa-b5cd-cc1086e1e5f8&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onError(success);\nobs.pause();\nobs.error(&#x27;errore&#x27;);\n        expect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;57b06065-1d80-4e60-b718-da166632e1e6&quot;,
                    &quot;parentUUID&quot;: &quot;49c37700-2b2b-44aa-b5cd-cc1086e1e5f8&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;5c0f7bd7-4cd8-4feb-b788-0c19aae6b1fa&quot;,
                    &quot;parentUUID&quot;: &quot;49c37700-2b2b-44aa-b5cd-cc1086e1e5f8&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;uuid&quot;: &quot;49c37700-2b2b-44aa-b5cd-cc1086e1e5f8&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare error_cb&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Deve chiamare error_cb&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;f16d7a0f-0b7c-4381-99cd-41e1b009a3cb&quot;,
                    &quot;parentUUID&quot;: &quot;49c37700-2b2b-44aa-b5cd-cc1086e1e5f8&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onError(success);\nobs.pause();\nobs.error(&#x27;errore&#x27;);\n        expect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;57b06065-1d80-4e60-b718-da166632e1e6&quot;,
                    &quot;parentUUID&quot;: &quot;49c37700-2b2b-44aa-b5cd-cc1086e1e5f8&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;5c0f7bd7-4cd8-4feb-b788-0c19aae6b1fa&quot;,
                    &quot;parentUUID&quot;: &quot;49c37700-2b2b-44aa-b5cd-cc1086e1e5f8&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 3,
                &quot;totalPasses&quot;: 3,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 1,
                &quot;rootEmpty&quot;: false
              },
              {
                &quot;title&quot;: &quot;next&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal(&#x27;data&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;a91fe3d4-967b-4883-837e-6ec145eeab0f&quot;,
                    &quot;parentUUID&quot;: &quot;9e368828-444c-43b3-80d5-5e289809a136&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.pause();\nobs.next(&#x27;Function called&#x27;);\nexpect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;5a4940c3-0031-49b9-9392-544955ffba7c&quot;,
                    &quot;parentUUID&quot;: &quot;9e368828-444c-43b3-80d5-5e289809a136&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next(&#x27;other data&#x27;);\nexpect(success.callCount).to.equal(2);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;9d9f1afe-a149-4fde-bc35-3b7ce9404fbd&quot;,
                    &quot;parentUUID&quot;: &quot;9e368828-444c-43b3-80d5-5e289809a136&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;uuid&quot;: &quot;9e368828-444c-43b3-80d5-5e289809a136&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal(&#x27;data&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;a91fe3d4-967b-4883-837e-6ec145eeab0f&quot;,
                    &quot;parentUUID&quot;: &quot;9e368828-444c-43b3-80d5-5e289809a136&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.pause();\nobs.next(&#x27;Function called&#x27;);\nexpect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;5a4940c3-0031-49b9-9392-544955ffba7c&quot;,
                    &quot;parentUUID&quot;: &quot;9e368828-444c-43b3-80d5-5e289809a136&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next(&#x27;other data&#x27;);\nexpect(success.callCount).to.equal(2);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;9d9f1afe-a149-4fde-bc35-3b7ce9404fbd&quot;,
                    &quot;parentUUID&quot;: &quot;9e368828-444c-43b3-80d5-5e289809a136&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 3,
                &quot;totalPasses&quot;: 3,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 1,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
            &quot;uuid&quot;: &quot;d53fbc3a-9c43-49fb-80ea-9a4d0e809b0f&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
        &quot;uuid&quot;: &quot;da3a7a2b-6bf7-4c08-9038-5e99b4411361&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Rules&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;RulesDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB addRule Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;15eaeb8f-5e68-4844-bee6-3b70dc2cec6c&quot;,
                        &quot;parentUUID&quot;: &quot;61f257c4-c5ed-49e0-8733-3565b5574880&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB addRule Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3e346b4c-b95d-4b48-a70a-3cc33ff44e9f&quot;,
                        &quot;parentUUID&quot;: &quot;61f257c4-c5ed-49e0-8733-3565b5574880&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;61f257c4-c5ed-49e0-8733-3565b5574880&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB addRule Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;15eaeb8f-5e68-4844-bee6-3b70dc2cec6c&quot;,
                        &quot;parentUUID&quot;: &quot;61f257c4-c5ed-49e0-8733-3565b5574880&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB addRule Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3e346b4c-b95d-4b48-a70a-3cc33ff44e9f&quot;,
                        &quot;parentUUID&quot;: &quot;61f257c4-c5ed-49e0-8733-3565b5574880&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRule Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;94729610-4e1b-4e1f-9e11-10af6ab45580&quot;,
                        &quot;parentUUID&quot;: &quot;edf155e6-cd9b-4e3b-b368-142d412a9ccc&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRule Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1246fbbc-7dc6-423c-b9d6-a2405b080479&quot;,
                        &quot;parentUUID&quot;: &quot;edf155e6-cd9b-4e3b-b368-142d412a9ccc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;edf155e6-cd9b-4e3b-b368-142d412a9ccc&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRule Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;94729610-4e1b-4e1f-9e11-10af6ab45580&quot;,
                        &quot;parentUUID&quot;: &quot;edf155e6-cd9b-4e3b-b368-142d412a9ccc&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRule Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1246fbbc-7dc6-423c-b9d6-a2405b080479&quot;,
                        &quot;parentUUID&quot;: &quot;edf155e6-cd9b-4e3b-b368-142d412a9ccc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getRuleList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3e59c6cf-8b9d-430c-a165-6c8c6169cb4d&quot;,
                        &quot;parentUUID&quot;: &quot;deb25722-4df7-4922-9822-9af2ef3b4113&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;22a7480d-91eb-44ff-b256-3d8890c00465&quot;,
                        &quot;parentUUID&quot;: &quot;deb25722-4df7-4922-9822-9af2ef3b4113&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;//da definire&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0ebfabdd-cafb-4249-90b1-2b16eb281a51&quot;,
                        &quot;parentUUID&quot;: &quot;deb25722-4df7-4922-9822-9af2ef3b4113&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;deb25722-4df7-4922-9822-9af2ef3b4113&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3e59c6cf-8b9d-430c-a165-6c8c6169cb4d&quot;,
                        &quot;parentUUID&quot;: &quot;deb25722-4df7-4922-9822-9af2ef3b4113&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;22a7480d-91eb-44ff-b256-3d8890c00465&quot;,
                        &quot;parentUUID&quot;: &quot;deb25722-4df7-4922-9822-9af2ef3b4113&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;//da definire&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0ebfabdd-cafb-4249-90b1-2b16eb281a51&quot;,
                        &quot;parentUUID&quot;: &quot;deb25722-4df7-4922-9822-9af2ef3b4113&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB removeRule Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f1059ebf-1910-4f56-bf60-8b03b9805a30&quot;,
                        &quot;parentUUID&quot;: &quot;b6aaee9e-fe16-4aac-aa77-6ef83cc0d682&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB removeRule Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b8420c32-526c-4419-9a8c-5f10064c8d72&quot;,
                        &quot;parentUUID&quot;: &quot;b6aaee9e-fe16-4aac-aa77-6ef83cc0d682&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;b6aaee9e-fe16-4aac-aa77-6ef83cc0d682&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB removeRule Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f1059ebf-1910-4f56-bf60-8b03b9805a30&quot;,
                        &quot;parentUUID&quot;: &quot;b6aaee9e-fe16-4aac-aa77-6ef83cc0d682&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB removeRule Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b8420c32-526c-4419-9a8c-5f10064c8d72&quot;,
                        &quot;parentUUID&quot;: &quot;b6aaee9e-fe16-4aac-aa77-6ef83cc0d682&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c15370c4-0d06-42e5-8381-d2bc56c6c6a7&quot;,
                        &quot;parentUUID&quot;: &quot;fa881d42-af8e-4f5b-aa13-e813a8623c0f&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9d296d35-abb4-4a98-8cc2-1e4d078f5ead&quot;,
                        &quot;parentUUID&quot;: &quot;fa881d42-af8e-4f5b-aa13-e813a8623c0f&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;fa881d42-af8e-4f5b-aa13-e813a8623c0f&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c15370c4-0d06-42e5-8381-d2bc56c6c6a7&quot;,
                        &quot;parentUUID&quot;: &quot;fa881d42-af8e-4f5b-aa13-e813a8623c0f&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9d296d35-abb4-4a98-8cc2-1e4d078f5ead&quot;,
                        &quot;parentUUID&quot;: &quot;fa881d42-af8e-4f5b-aa13-e813a8623c0f&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;80920372-74e5-48f2-a4e1-e8cabbe2a7e4&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;dc3dac61-e35b-4e00-98b5-1b4b8cf592c2&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;13ccd384-8e10-4d38-810f-318e432a9b3a&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Rules&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;RulesService&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \&quot;\&quot;};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;98e3dd70-89ce-459f-acdc-641b7bb9c10d&quot;,
                        &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3b3e0afa-b7be-46c6-aeeb-9a34d637a900&quot;,
                        &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b57b4b04-5426-4250-95b2-f5f4b1da7e66&quot;,
                        &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d0fe8168-7054-4d00-9a15-28d037ad92a6&quot;,
                        &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \&quot;\&quot;};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;98e3dd70-89ce-459f-acdc-641b7bb9c10d&quot;,
                        &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3b3e0afa-b7be-46c6-aeeb-9a34d637a900&quot;,
                        &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b57b4b04-5426-4250-95b2-f5f4b1da7e66&quot;,
                        &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d0fe8168-7054-4d00-9a15-28d037ad92a6&quot;,
                        &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 4,
                    &quot;totalPasses&quot;: 4,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 4,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;deleteRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e762cf65-5242-4a88-820d-867e9f70a941&quot;,
                        &quot;parentUUID&quot;: &quot;b2aa7e66-cdda-4625-87f8-ec110f9bf81c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;adfbf517-ef9e-4d3c-b3e3-a6a9cddd6154&quot;,
                        &quot;parentUUID&quot;: &quot;b2aa7e66-cdda-4625-87f8-ec110f9bf81c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);\n};&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b6e6f97e-13c5-4fdc-90ab-cbf66d5dccfc&quot;,
                        &quot;parentUUID&quot;: &quot;b2aa7e66-cdda-4625-87f8-ec110f9bf81c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;b2aa7e66-cdda-4625-87f8-ec110f9bf81c&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e762cf65-5242-4a88-820d-867e9f70a941&quot;,
                        &quot;parentUUID&quot;: &quot;b2aa7e66-cdda-4625-87f8-ec110f9bf81c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;adfbf517-ef9e-4d3c-b3e3-a6a9cddd6154&quot;,
                        &quot;parentUUID&quot;: &quot;b2aa7e66-cdda-4625-87f8-ec110f9bf81c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);\n};&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b6e6f97e-13c5-4fdc-90ab-cbf66d5dccfc&quot;,
                        &quot;parentUUID&quot;: &quot;b2aa7e66-cdda-4625-87f8-ec110f9bf81c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c3e9053a-1c10-40b5-98bc-ffb89faf4b71&quot;,
                        &quot;parentUUID&quot;: &quot;94738676-1a13-4e38-94c0-8e7d8b0c2463&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2438f097-3c80-4749-a83f-d3d0bb355fba&quot;,
                        &quot;parentUUID&quot;: &quot;94738676-1a13-4e38-94c0-8e7d8b0c2463&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;653a4eca-a6b4-4eb7-aef5-508669e6d640&quot;,
                        &quot;parentUUID&quot;: &quot;94738676-1a13-4e38-94c0-8e7d8b0c2463&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;94738676-1a13-4e38-94c0-8e7d8b0c2463&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c3e9053a-1c10-40b5-98bc-ffb89faf4b71&quot;,
                        &quot;parentUUID&quot;: &quot;94738676-1a13-4e38-94c0-8e7d8b0c2463&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2438f097-3c80-4749-a83f-d3d0bb355fba&quot;,
                        &quot;parentUUID&quot;: &quot;94738676-1a13-4e38-94c0-8e7d8b0c2463&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;653a4eca-a6b4-4eb7-aef5-508669e6d640&quot;,
                        &quot;parentUUID&quot;: &quot;94738676-1a13-4e38-94c0-8e7d8b0c2463&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getRuleList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7219ab31-1903-4947-9eed-09f807fb27d3&quot;,
                        &quot;parentUUID&quot;: &quot;8287b028-21b5-431e-b67a-4041c9c3e44d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a3b4feac-3e21-4c67-866a-65c6ea5bff97&quot;,
                        &quot;parentUUID&quot;: &quot;8287b028-21b5-431e-b67a-4041c9c3e44d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;8287b028-21b5-431e-b67a-4041c9c3e44d&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7219ab31-1903-4947-9eed-09f807fb27d3&quot;,
                        &quot;parentUUID&quot;: &quot;8287b028-21b5-431e-b67a-4041c9c3e44d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a3b4feac-3e21-4c67-866a-65c6ea5bff97&quot;,
                        &quot;parentUUID&quot;: &quot;8287b028-21b5-431e-b67a-4041c9c3e44d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getTaskList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c75cb0db-d9af-4c4b-998f-ac49afa95e4b&quot;,
                        &quot;parentUUID&quot;: &quot;3c3c777c-2740-489e-84fd-284013434230&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a12a0138-eeeb-43e5-ab8c-189af276fd4e&quot;,
                        &quot;parentUUID&quot;: &quot;3c3c777c-2740-489e-84fd-284013434230&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;3c3c777c-2740-489e-84fd-284013434230&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c75cb0db-d9af-4c4b-998f-ac49afa95e4b&quot;,
                        &quot;parentUUID&quot;: &quot;3c3c777c-2740-489e-84fd-284013434230&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a12a0138-eeeb-43e5-ab8c-189af276fd4e&quot;,
                        &quot;parentUUID&quot;: &quot;3c3c777c-2740-489e-84fd-284013434230&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5e977a2c-c68a-4b31-be7d-bb983a9fc576&quot;,
                        &quot;parentUUID&quot;: &quot;d4e83ef5-ca80-44bd-b820-4d08c7ba9249&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \&quot;\&quot; , body: \&quot;\&quot;};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fff7249c-ceab-498b-9e7e-a25a820882ef&quot;,
                        &quot;parentUUID&quot;: &quot;d4e83ef5-ca80-44bd-b820-4d08c7ba9249&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fd82199a-105f-4c06-b1fc-b0f19ac4b324&quot;,
                        &quot;parentUUID&quot;: &quot;d4e83ef5-ca80-44bd-b820-4d08c7ba9249&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;d4e83ef5-ca80-44bd-b820-4d08c7ba9249&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5e977a2c-c68a-4b31-be7d-bb983a9fc576&quot;,
                        &quot;parentUUID&quot;: &quot;d4e83ef5-ca80-44bd-b820-4d08c7ba9249&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \&quot;\&quot; , body: \&quot;\&quot;};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fff7249c-ceab-498b-9e7e-a25a820882ef&quot;,
                        &quot;parentUUID&quot;: &quot;d4e83ef5-ca80-44bd-b820-4d08c7ba9249&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fd82199a-105f-4c06-b1fc-b0f19ac4b324&quot;,
                        &quot;parentUUID&quot;: &quot;d4e83ef5-ca80-44bd-b820-4d08c7ba9249&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                &quot;uuid&quot;: &quot;859646b0-c832-49a9-a6f2-e168949c624e&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
            &quot;uuid&quot;: &quot;5fe61cd3-3f4d-46c1-afbb-b2e49bf4bd93&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
        &quot;uuid&quot;: &quot;cf47b9d0-1bfb-4131-b158-45b0c967a976&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;STT&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;STTWatsonAdapter&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;speechToText&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
                        &quot;fullTitle&quot;: &quot;STTWatsonAdapter speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;faf56f43-f076-4f33-aac3-2c3dbe23dfe7&quot;,
                        &quot;parentUUID&quot;: &quot;13cd6e76-77c3-4acc-b934-55d12551993d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_STTWatsonAdapter.js&quot;,
                    &quot;uuid&quot;: &quot;13cd6e76-77c3-4acc-b934-55d12551993d&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
                        &quot;fullTitle&quot;: &quot;STTWatsonAdapter speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;faf56f43-f076-4f33-aac3-2c3dbe23dfe7&quot;,
                        &quot;parentUUID&quot;: &quot;13cd6e76-77c3-4acc-b934-55d12551993d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_STTWatsonAdapter.js&quot;,
                &quot;uuid&quot;: &quot;8d7fc422-5875-432a-84b0-21cc8a98765f&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_STTWatsonAdapter.js&quot;,
            &quot;uuid&quot;: &quot;3c0812cf-9943-466d-a587-f191161ede1c&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_STTWatsonAdapter.js&quot;,
        &quot;uuid&quot;: &quot;9f7b50dc-afd5-4ce0-9d63-838dbaf2c5d8&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Tasks&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;TasksDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addTask&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d6ba4de7-aca1-462a-bb7d-69ab63b9e260&quot;,
                        &quot;parentUUID&quot;: &quot;5a594656-005d-44b1-928c-20b5b6343a63&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;08defae6-44e1-4b1c-afe8-1dff06b429d3&quot;,
                        &quot;parentUUID&quot;: &quot;5a594656-005d-44b1-928c-20b5b6343a63&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;5a594656-005d-44b1-928c-20b5b6343a63&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d6ba4de7-aca1-462a-bb7d-69ab63b9e260&quot;,
                        &quot;parentUUID&quot;: &quot;5a594656-005d-44b1-928c-20b5b6343a63&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;08defae6-44e1-4b1c-afe8-1dff06b429d3&quot;,
                        &quot;parentUUID&quot;: &quot;5a594656-005d-44b1-928c-20b5b6343a63&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getTask&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTask Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTask(&#x27;mock_type&#x27;).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a428e036-b2d4-49bf-ad4e-e2f7f9728912&quot;,
                        &quot;parentUUID&quot;: &quot;f25873d1-00b0-4a8f-b334-ded563900812&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTask Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = tasks.getTask(&#x27;mock_type&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3e7609b0-f517-4d26-87cb-ffbc7180ed15&quot;,
                        &quot;parentUUID&quot;: &quot;f25873d1-00b0-4a8f-b334-ded563900812&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;f25873d1-00b0-4a8f-b334-ded563900812&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTask Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTask(&#x27;mock_type&#x27;).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a428e036-b2d4-49bf-ad4e-e2f7f9728912&quot;,
                        &quot;parentUUID&quot;: &quot;f25873d1-00b0-4a8f-b334-ded563900812&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTask Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = tasks.getTask(&#x27;mock_type&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3e7609b0-f517-4d26-87cb-ffbc7180ed15&quot;,
                        &quot;parentUUID&quot;: &quot;f25873d1-00b0-4a8f-b334-ded563900812&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getTaskList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \&quot;mock_type3\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;02d9accf-3ca9-41b3-857d-4cd3eee98884&quot;,
                        &quot;parentUUID&quot;: &quot;101cfe00-c24e-4229-922d-fbd255aa004e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTaskList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;73ed2dc2-d926-40af-a3e3-842b60aa7fc7&quot;,
                        &quot;parentUUID&quot;: &quot;101cfe00-c24e-4229-922d-fbd255aa004e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;101cfe00-c24e-4229-922d-fbd255aa004e&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \&quot;mock_type3\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;02d9accf-3ca9-41b3-857d-4cd3eee98884&quot;,
                        &quot;parentUUID&quot;: &quot;101cfe00-c24e-4229-922d-fbd255aa004e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTaskList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;73ed2dc2-d926-40af-a3e3-842b60aa7fc7&quot;,
                        &quot;parentUUID&quot;: &quot;101cfe00-c24e-4229-922d-fbd255aa004e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeTask&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1848671c-66e6-44a0-acf2-d290cb6382f0&quot;,
                        &quot;parentUUID&quot;: &quot;2ecf9916-8690-4db7-a3f9-11182b852491&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e4f51a84-7020-4a9e-a016-3272c933f00f&quot;,
                        &quot;parentUUID&quot;: &quot;2ecf9916-8690-4db7-a3f9-11182b852491&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;2ecf9916-8690-4db7-a3f9-11182b852491&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1848671c-66e6-44a0-acf2-d290cb6382f0&quot;,
                        &quot;parentUUID&quot;: &quot;2ecf9916-8690-4db7-a3f9-11182b852491&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e4f51a84-7020-4a9e-a016-3272c933f00f&quot;,
                        &quot;parentUUID&quot;: &quot;2ecf9916-8690-4db7-a3f9-11182b852491&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateTask&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;454c1179-853e-45e7-bd25-9b034723f652&quot;,
                        &quot;parentUUID&quot;: &quot;7a96f36c-94e0-491b-a0ff-ad0ce195e8b5&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e235b321-4e3e-4769-aef8-1ca967a429a8&quot;,
                        &quot;parentUUID&quot;: &quot;7a96f36c-94e0-491b-a0ff-ad0ce195e8b5&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;7a96f36c-94e0-491b-a0ff-ad0ce195e8b5&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;454c1179-853e-45e7-bd25-9b034723f652&quot;,
                        &quot;parentUUID&quot;: &quot;7a96f36c-94e0-491b-a0ff-ad0ce195e8b5&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e235b321-4e3e-4769-aef8-1ca967a429a8&quot;,
                        &quot;parentUUID&quot;: &quot;7a96f36c-94e0-491b-a0ff-ad0ce195e8b5&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;6c30c20a-a47c-4981-ab36-2e1be29bbf8e&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;246b1140-4a21-4363-93ff-a8d51fa41cc1&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;c9db4b0d-2644-49b7-885b-72f2bc368f60&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Users&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;UsersDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB addUser Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\&quot;Requested resource not found\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;af67856f-3de2-4c43-9202-6b33d74c330c&quot;,
                        &quot;parentUUID&quot;: &quot;aeae1446-b11b-4b06-aea9-6ae51733d593&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB addUser Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fb039aa0-b2ea-42f5-9910-52b63ea77179&quot;,
                        &quot;parentUUID&quot;: &quot;aeae1446-b11b-4b06-aea9-6ae51733d593&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;aeae1446-b11b-4b06-aea9-6ae51733d593&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB addUser Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\&quot;Requested resource not found\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;af67856f-3de2-4c43-9202-6b33d74c330c&quot;,
                        &quot;parentUUID&quot;: &quot;aeae1446-b11b-4b06-aea9-6ae51733d593&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB addUser Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fb039aa0-b2ea-42f5-9910-52b63ea77179&quot;,
                        &quot;parentUUID&quot;: &quot;aeae1446-b11b-4b06-aea9-6ae51733d593&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUser Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ac50f261-0403-4af0-93ee-5426e49438cb&quot;,
                        &quot;parentUUID&quot;: &quot;ff4ad3b8-0674-4085-8d0d-4132f11d6d31&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUser Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = users.getUser(&#x27;mou&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\n\t\t\t\t\texpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0a34898d-bac4-4add-badc-46683e904ce8&quot;,
                        &quot;parentUUID&quot;: &quot;ff4ad3b8-0674-4085-8d0d-4132f11d6d31&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;ff4ad3b8-0674-4085-8d0d-4132f11d6d31&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUser Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ac50f261-0403-4af0-93ee-5426e49438cb&quot;,
                        &quot;parentUUID&quot;: &quot;ff4ad3b8-0674-4085-8d0d-4132f11d6d31&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUser Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = users.getUser(&#x27;mou&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\n\t\t\t\t\texpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0a34898d-bac4-4add-badc-46683e904ce8&quot;,
                        &quot;parentUUID&quot;: &quot;ff4ad3b8-0674-4085-8d0d-4132f11d6d31&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUserList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}], LastEvaluatedKey: &#x27;marco&#x27;});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;71bec860-59c0-468d-8f31-0096103a781f&quot;,
                        &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;63228552-797c-4e0b-b0b4-db7be8027e24&quot;,
                        &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;aa5fc92f-6517-4d10-a8db-bae03580113a&quot;,
                        &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;,\n\tslack_channel: &#x27;channel&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name and slack_channel = :slack_channel&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:slack_channel&#x27;, &#x27;channel&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9d3b5690-b034-4b69-a0c3-e3f428632869&quot;,
                        &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}], LastEvaluatedKey: &#x27;marco&#x27;});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;71bec860-59c0-468d-8f31-0096103a781f&quot;,
                        &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;63228552-797c-4e0b-b0b4-db7be8027e24&quot;,
                        &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;aa5fc92f-6517-4d10-a8db-bae03580113a&quot;,
                        &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;,\n\tslack_channel: &#x27;channel&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name and slack_channel = :slack_channel&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:slack_channel&#x27;, &#x27;channel&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9d3b5690-b034-4b69-a0c3-e3f428632869&quot;,
                        &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 4,
                    &quot;totalPasses&quot;: 4,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 5,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB removeUser Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \&quot;error removing user\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;58f8769f-fbbb-414b-a799-c445e069e88e&quot;,
                        &quot;parentUUID&quot;: &quot;5ac8bd5a-9a5a-400d-bf11-fec8a903e77b&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB removeUser Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e9622257-893d-4ddd-b674-b5963c613b76&quot;,
                        &quot;parentUUID&quot;: &quot;5ac8bd5a-9a5a-400d-bf11-fec8a903e77b&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;5ac8bd5a-9a5a-400d-bf11-fec8a903e77b&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB removeUser Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \&quot;error removing user\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;58f8769f-fbbb-414b-a799-c445e069e88e&quot;,
                        &quot;parentUUID&quot;: &quot;5ac8bd5a-9a5a-400d-bf11-fec8a903e77b&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB removeUser Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e9622257-893d-4ddd-b674-b5963c613b76&quot;,
                        &quot;parentUUID&quot;: &quot;5ac8bd5a-9a5a-400d-bf11-fec8a903e77b&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB updateUser Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \&quot;error updating user\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;91850804-7575-40b0-b670-2d4c4896d8b3&quot;,
                        &quot;parentUUID&quot;: &quot;fdf1a4b7-c403-4d66-ae64-820fa14f3606&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB updateUser Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1d0cc82f-3cc7-4b5b-a7fa-505821648875&quot;,
                        &quot;parentUUID&quot;: &quot;fdf1a4b7-c403-4d66-ae64-820fa14f3606&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;fdf1a4b7-c403-4d66-ae64-820fa14f3606&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB updateUser Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \&quot;error updating user\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;91850804-7575-40b0-b670-2d4c4896d8b3&quot;,
                        &quot;parentUUID&quot;: &quot;fdf1a4b7-c403-4d66-ae64-820fa14f3606&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB updateUser Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1d0cc82f-3cc7-4b5b-a7fa-505821648875&quot;,
                        &quot;parentUUID&quot;: &quot;fdf1a4b7-c403-4d66-ae64-820fa14f3606&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;f8bb0703-27ef-4a93-9760-985cc7ab02dd&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;e25c1d37-daf7-4e03-a8d5-42ab748fc2ba&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;9e25e8b3-c06c-4558-8b55-ffa1f36f6047&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Users&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;UsersService&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;089a912a-aecf-4485-9906-76f472715847&quot;,
                        &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;63775100-ff4b-4ce0-8fd5-fc200ba95b0f&quot;,
                        &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \&quot;\&quot; };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5771b81a-00a2-485e-abca-327039381dd4&quot;,
                        &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;df221a75-311d-4738-801a-c49843bcf83e&quot;,
                        &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;089a912a-aecf-4485-9906-76f472715847&quot;,
                        &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;63775100-ff4b-4ce0-8fd5-fc200ba95b0f&quot;,
                        &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \&quot;\&quot; };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5771b81a-00a2-485e-abca-327039381dd4&quot;,
                        &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;df221a75-311d-4738-801a-c49843bcf83e&quot;,
                        &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 4,
                    &quot;totalPasses&quot;: 4,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;deleteUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d014fde5-db8e-4e5c-9fa7-f282afc46836&quot;,
                        &quot;parentUUID&quot;: &quot;ed489e91-85fb-46c7-8342-e57c0743d069&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f498d75d-7b20-4cc4-884e-3d101a2099f1&quot;,
                        &quot;parentUUID&quot;: &quot;ed489e91-85fb-46c7-8342-e57c0743d069&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { pathParameters: { username: &#x27;pippo&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;82a61ea1-4888-4efb-a864-2dedf3e33752&quot;,
                        &quot;parentUUID&quot;: &quot;ed489e91-85fb-46c7-8342-e57c0743d069&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;ed489e91-85fb-46c7-8342-e57c0743d069&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d014fde5-db8e-4e5c-9fa7-f282afc46836&quot;,
                        &quot;parentUUID&quot;: &quot;ed489e91-85fb-46c7-8342-e57c0743d069&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f498d75d-7b20-4cc4-884e-3d101a2099f1&quot;,
                        &quot;parentUUID&quot;: &quot;ed489e91-85fb-46c7-8342-e57c0743d069&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { pathParameters: { username: &#x27;pippo&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;82a61ea1-4888-4efb-a864-2dedf3e33752&quot;,
                        &quot;parentUUID&quot;: &quot;ed489e91-85fb-46c7-8342-e57c0743d069&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9f4940a2-7dd2-477a-9321-d608ac3e0bfa&quot;,
                        &quot;parentUUID&quot;: &quot;e2986c45-3325-4cdf-9fb4-37e4a993cd46&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;84767ef0-2309-419a-88b5-7b10056164d8&quot;,
                        &quot;parentUUID&quot;: &quot;e2986c45-3325-4cdf-9fb4-37e4a993cd46&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\n          let ev = { pathParameters: { username: &#x27;pippo&#x27;} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ac78051f-0dd2-4da0-ab3e-54e85ca14edc&quot;,
                        &quot;parentUUID&quot;: &quot;e2986c45-3325-4cdf-9fb4-37e4a993cd46&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;e2986c45-3325-4cdf-9fb4-37e4a993cd46&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9f4940a2-7dd2-477a-9321-d608ac3e0bfa&quot;,
                        &quot;parentUUID&quot;: &quot;e2986c45-3325-4cdf-9fb4-37e4a993cd46&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;84767ef0-2309-419a-88b5-7b10056164d8&quot;,
                        &quot;parentUUID&quot;: &quot;e2986c45-3325-4cdf-9fb4-37e4a993cd46&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\n          let ev = { pathParameters: { username: &#x27;pippo&#x27;} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ac78051f-0dd2-4da0-ab3e-54e85ca14edc&quot;,
                        &quot;parentUUID&quot;: &quot;e2986c45-3325-4cdf-9fb4-37e4a993cd46&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUserList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;67fe971b-f87b-4cc9-a541-9999e0423b86&quot;,
                        &quot;parentUUID&quot;: &quot;26ec5209-e4c6-4ce1-82e8-d03d68d9c6d6&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ users: [{ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cea9fc7d-40bb-434b-94bd-29c6cf0354c9&quot;,
                        &quot;parentUUID&quot;: &quot;26ec5209-e4c6-4ce1-82e8-d03d68d9c6d6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;26ec5209-e4c6-4ce1-82e8-d03d68d9c6d6&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;67fe971b-f87b-4cc9-a541-9999e0423b86&quot;,
                        &quot;parentUUID&quot;: &quot;26ec5209-e4c6-4ce1-82e8-d03d68d9c6d6&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ users: [{ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cea9fc7d-40bb-434b-94bd-29c6cf0354c9&quot;,
                        &quot;parentUUID&quot;: &quot;26ec5209-e4c6-4ce1-82e8-d03d68d9c6d6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9086399a-bda1-40ba-b05f-945023a0a52b&quot;,
                        &quot;parentUUID&quot;: &quot;17d3f16f-1440-4e51-927c-e04805295041&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;080c9b1e-b60c-452d-93f7-b8f8564a5e2e&quot;,
                        &quot;parentUUID&quot;: &quot;17d3f16f-1440-4e51-927c-e04805295041&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = { pathParameters: \&quot;\&quot;, body: \&quot;\&quot; };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8bfda398-f498-42da-a60f-62633084a0f5&quot;,
                        &quot;parentUUID&quot;: &quot;17d3f16f-1440-4e51-927c-e04805295041&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;17d3f16f-1440-4e51-927c-e04805295041&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9086399a-bda1-40ba-b05f-945023a0a52b&quot;,
                        &quot;parentUUID&quot;: &quot;17d3f16f-1440-4e51-927c-e04805295041&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;080c9b1e-b60c-452d-93f7-b8f8564a5e2e&quot;,
                        &quot;parentUUID&quot;: &quot;17d3f16f-1440-4e51-927c-e04805295041&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = { pathParameters: \&quot;\&quot;, body: \&quot;\&quot; };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8bfda398-f498-42da-a60f-62633084a0f5&quot;,
                        &quot;parentUUID&quot;: &quot;17d3f16f-1440-4e51-927c-e04805295041&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                &quot;uuid&quot;: &quot;d28090ed-55ee-44d2-b400-1551c91cbae2&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
            &quot;uuid&quot;: &quot;f03bc7d6-725e-4e5f-9bc2-2f36586f5b93&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
        &quot;uuid&quot;: &quot;f1d235a3-f786-48a6-a8a7-5272323a3dd7&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Events&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;VAMessageListener&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;onMessage&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {
                          &quot;name&quot;: &quot;AssertionError&quot;,
                          &quot;message&quot;: &quot;expected 1 to be above 1&quot;,
                          &quot;showDiff&quot;: false,
                          &quot;actual&quot;: 1,
                          &quot;estack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:54:36)\n&quot;,
                          &quot;stack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:54:36)\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4a8e2960-e8a9-4180-a9f9-7ff28e5272c8&quot;,
                        &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {
                          &quot;name&quot;: &quot;AssertionError&quot;,
                          &quot;message&quot;: &quot;expected 1 to be above 1&quot;,
                          &quot;showDiff&quot;: false,
                          &quot;actual&quot;: 1,
                          &quot;estack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:67:36)\n&quot;,
                          &quot;stack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:67:36)\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fab7dbb3-a4d2-4ad6-9782-d344f42e70cb&quot;,
                        &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;msg&#x27;: &#x27;error getting guest&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3c003d51-33fd-4b06-976f-072340d2b2e6&quot;,
                        &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ &#x27;msg&#x27;: &#x27;error adding conversation&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;987b6a01-c708-4bcc-be5f-c895046d9c7b&quot;,
                        &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;type&#x27;: &#x27;example&#x27; });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c69a5fbf-7258-4d9b-839b-f789885cb000&quot;,
                        &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VAMessageListener.js&quot;,
                    &quot;uuid&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;msg&#x27;: &#x27;error getting guest&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3c003d51-33fd-4b06-976f-072340d2b2e6&quot;,
                        &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ &#x27;msg&#x27;: &#x27;error adding conversation&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;987b6a01-c708-4bcc-be5f-c895046d9c7b&quot;,
                        &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;type&#x27;: &#x27;example&#x27; });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c69a5fbf-7258-4d9b-839b-f789885cb000&quot;,
                        &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {
                          &quot;name&quot;: &quot;AssertionError&quot;,
                          &quot;message&quot;: &quot;expected 1 to be above 1&quot;,
                          &quot;showDiff&quot;: false,
                          &quot;actual&quot;: 1,
                          &quot;estack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:54:36)\n&quot;,
                          &quot;stack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:54:36)\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4a8e2960-e8a9-4180-a9f9-7ff28e5272c8&quot;,
                        &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {
                          &quot;name&quot;: &quot;AssertionError&quot;,
                          &quot;message&quot;: &quot;expected 1 to be above 1&quot;,
                          &quot;showDiff&quot;: false,
                          &quot;actual&quot;: 1,
                          &quot;estack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:67:36)\n&quot;,
                          &quot;stack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:67:36)\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fab7dbb3-a4d2-4ad6-9782-d344f42e70cb&quot;,
                        &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 5,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 2,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: true,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 4,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_VAMessageListener.js&quot;,
                &quot;uuid&quot;: &quot;8bd586ec-3487-4616-85a9-b623c73540c1&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_VAMessageListener.js&quot;,
            &quot;uuid&quot;: &quot;5dee60db-a08d-4361-8da8-6946bc19dab3&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_VAMessageListener.js&quot;,
        &quot;uuid&quot;: &quot;9852fdf0-9a07-4c9e-9368-c58da7166239&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;VirtualAssistant&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;VAService&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;query&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;VAService query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith(&#x27;test&#x27;));\n\tlet result = context.succeed.getCall(0).args[0];\n            expect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n            done();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2051a21b-4c35-4779-84e7-f13aa3ae1c2a&quot;,
                        &quot;parentUUID&quot;: &quot;9ec9fb3d-1b49-4f6b-be7c-241a74a68141&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
                        &quot;fullTitle&quot;: &quot;VAService query Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.reject(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n            done();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1ea70980-80a4-4686-a80f-3ca41b31ca01&quot;,
                        &quot;parentUUID&quot;: &quot;9ec9fb3d-1b49-4f6b-be7c-241a74a68141&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VAService.js&quot;,
                    &quot;uuid&quot;: &quot;9ec9fb3d-1b49-4f6b-be7c-241a74a68141&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;VAService query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith(&#x27;test&#x27;));\n\tlet result = context.succeed.getCall(0).args[0];\n            expect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n            done();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2051a21b-4c35-4779-84e7-f13aa3ae1c2a&quot;,
                        &quot;parentUUID&quot;: &quot;9ec9fb3d-1b49-4f6b-be7c-241a74a68141&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
                        &quot;fullTitle&quot;: &quot;VAService query Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.reject(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n            done();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1ea70980-80a4-4686-a80f-3ca41b31ca01&quot;,
                        &quot;parentUUID&quot;: &quot;9ec9fb3d-1b49-4f6b-be7c-241a74a68141&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 4,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_VAService.js&quot;,
                &quot;uuid&quot;: &quot;d5a36386-ab5b-4959-8c17-581fae5f1660&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_VAService.js&quot;,
            &quot;uuid&quot;: &quot;50316b7f-716d-4560-a048-b0d7fe30aefc&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_VAService.js&quot;,
        &quot;uuid&quot;: &quot;99532628-a648-416f-ab47-6816929b3313&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;APIGateway&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;VocalAPI&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;_addRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b60e4a82-00f8-46d8-abf4-6c086aa3b62b&quot;,
                        &quot;parentUUID&quot;: &quot;8e09aa21-be16-4203-a2f9-698a7f9bda2f&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;8e09aa21-be16-4203-a2f9-698a7f9bda2f&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b60e4a82-00f8-46d8-abf4-6c086aa3b62b&quot;,
                        &quot;parentUUID&quot;: &quot;8e09aa21-be16-4203-a2f9-698a7f9bda2f&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_addUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cb35b38c-4874-4ddb-864c-1c606affc554&quot;,
                        &quot;parentUUID&quot;: &quot;fb6484a0-e7ab-490f-967f-37d7bf3bb4be&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;fb6484a0-e7ab-490f-967f-37d7bf3bb4be&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cb35b38c-4874-4ddb-864c-1c606affc554&quot;,
                        &quot;parentUUID&quot;: &quot;fb6484a0-e7ab-490f-967f-37d7bf3bb4be&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_addUserEnrollment&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.addEnrollment.returns(Rx.Observable.throw(errore));\napi._addUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8d10e8fe-7ae8-4553-b722-1e948809daa8&quot;,
                        &quot;parentUUID&quot;: &quot;8ac3a77d-a36f-486e-b032-d1f969a3dd78&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;8ac3a77d-a36f-486e-b032-d1f969a3dd78&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.addEnrollment.returns(Rx.Observable.throw(errore));\napi._addUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8d10e8fe-7ae8-4553-b722-1e948809daa8&quot;,
                        &quot;parentUUID&quot;: &quot;8ac3a77d-a36f-486e-b032-d1f969a3dd78&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_getRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;de6241a9-9d63-4709-b6b2-1f0d8f49153b&quot;,
                        &quot;parentUUID&quot;: &quot;66c308d0-9cc6-43ec-8a14-c5948f490a34&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;66c308d0-9cc6-43ec-8a14-c5948f490a34&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;de6241a9-9d63-4709-b6b2-1f0d8f49153b&quot;,
                        &quot;parentUUID&quot;: &quot;66c308d0-9cc6-43ec-8a14-c5948f490a34&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 4,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_getRuleList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cc94634f-a9f7-47b7-9598-bd85767c1241&quot;,
                        &quot;parentUUID&quot;: &quot;d25fee7e-54b0-4cd6-8f50-39479e231437&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;d25fee7e-54b0-4cd6-8f50-39479e231437&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cc94634f-a9f7-47b7-9598-bd85767c1241&quot;,
                        &quot;parentUUID&quot;: &quot;d25fee7e-54b0-4cd6-8f50-39479e231437&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_getUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b2b7a2c8-d9a2-44e2-b12f-9f16e0a6af31&quot;,
                        &quot;parentUUID&quot;: &quot;90cf3ec7-7575-40c6-8ac9-d78f19b49aeb&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;90cf3ec7-7575-40c6-8ac9-d78f19b49aeb&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b2b7a2c8-d9a2-44e2-b12f-9f16e0a6af31&quot;,
                        &quot;parentUUID&quot;: &quot;90cf3ec7-7575-40c6-8ac9-d78f19b49aeb&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_getUserList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3364ab4a-aaf5-4631-910a-b040fb42a8af&quot;,
                        &quot;parentUUID&quot;: &quot;c3b82a4c-84d7-43e3-a5e5-c06fe5a799ed&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;c3b82a4c-84d7-43e3-a5e5-c06fe5a799ed&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3364ab4a-aaf5-4631-910a-b040fb42a8af&quot;,
                        &quot;parentUUID&quot;: &quot;c3b82a4c-84d7-43e3-a5e5-c06fe5a799ed&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_loginUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.doLogin.returns(Rx.Observable.throw(errore));\napi._loginUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0e93df58-d56c-409f-803a-35ad1dfc3bad&quot;,
                        &quot;parentUUID&quot;: &quot;f98c281f-cbdd-4e0d-9547-931289b28203&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;f98c281f-cbdd-4e0d-9547-931289b28203&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.doLogin.returns(Rx.Observable.throw(errore));\napi._loginUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0e93df58-d56c-409f-803a-35ad1dfc3bad&quot;,
                        &quot;parentUUID&quot;: &quot;f98c281f-cbdd-4e0d-9547-931289b28203&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;queryLambda&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;// Manca il catch\nstt.speechToText.returns(Promise.reject(&#x27;Speech to Text Error&#x27;));\ncontext.succeed = function(response)\n{\n\texpect(response).have.property(&#x27;statusCode&#x27;, 500);\n\tdone();\n};\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0ead4d51-e553-4028-9634-ba401218908d&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se lo status della risposta ricevuta dall&#x27;assistente virtuale è diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio &#x27;Errore nel contattare l&#x27;assistente virtuale&#x27;.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se lo status della risposta ricevuta dall&#x27;assistente virtuale è diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio &#x27;Errore nel contattare l&#x27;assistente virtuale&#x27;.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;// Manca il catch\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.reject(errore_VA));\ncontext.succeed = function(response)\n{\n\texpect(response).to.have.deep.property(&#x27;statusCode&#x27;, errore_VA.statusCode);\n\tdone();\n};\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;72719ad5-527a-4333-b8ab-cb83dacfbd08&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 5,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ca4a9b0d-24bc-4e9d-866a-f9a0fd24267d&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e35861dc-5dea-4a5c-9ca4-6be524e51ca2&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b8c336c8-2872-4ecf-aa99-c30c8d16e10c&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2e8f7e23-eacb-441a-9810-a1cef03226fb&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8db79abb-48f9-44d1-bbde-80caed51b679&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;537037f6-244c-484c-8780-32e6c31df918&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUserList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUserList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUserList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUserList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9361af75-3f01-48dc-90d3-7b1395e2f748&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fc8e5f44-dec8-4a92-92e4-82797dbb5cb6&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;aacc9fda-ab84-49e5-8a2a-18a17c21778b&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d8288d8c-8249-4ab1-b318-ca1a24ccab55&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3bba97c1-b319-464f-827c-6580ce0d52e0&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0848e405-6181-4673-9580-19fcbe86f160&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;920da242-edd9-4775-8503-5b1705e4a85b&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          };\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;621f6014-47d4-46ac-b602-7022869028f6&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;dc26f1cd-0b40-4eb9-b96e-2130b6654260&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;49259128-fd49-4f28-8be2-029cdd2a9d7c&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b7e74616-c559-4f09-80bd-2d47b78b9139&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d7e135ae-4bda-4761-997c-33f35525fce3&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;05baabe1-047c-4dab-94a4-69c63d7ad32f&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4bd2ade0-14a4-4948-98c1-049b4b136f61&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;47095238-ed93-401e-afc1-f1b0efc07e79&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f012c1bc-f24f-454a-ad2a-1071b4350b67&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8a8671d5-6a40-4ed9-bc61-441b9458e77d&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;010f819c-071b-4f42-87a5-62c2eace4d6c&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a3060f88-b54d-4d40-bad9-7eb5b7f5077e&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7608b3f8-a644-47b2-b6eb-47aaf6a0f7c9&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;sns.publish.yields(&#x27;Errore&#x27;);\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n\t\t\t\t\tpromise.returns(Promise.resolve(empty_action_response));\ncontext.succeed = function(args)\n{\n  expect(args).to.have.deep.property(&#x27;statusCode&#x27;, 500);\n  done();\n}\napi.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3bd5fb95-bf60-4dca-99e2-7f93208b8051&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n\texpect(response).have.property(&#x27;statusCode&#x27;, 200);\n\tdone();\n};\napi.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;496d6e7f-8281-4c9c-954d-b798b385a91d&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;// Manca il catch\nstt.speechToText.returns(Promise.reject(&#x27;Speech to Text Error&#x27;));\ncontext.succeed = function(response)\n{\n\texpect(response).have.property(&#x27;statusCode&#x27;, 500);\n\tdone();\n};\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0ead4d51-e553-4028-9634-ba401218908d&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se lo status della risposta ricevuta dall&#x27;assistente virtuale è diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio &#x27;Errore nel contattare l&#x27;assistente virtuale&#x27;.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se lo status della risposta ricevuta dall&#x27;assistente virtuale è diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio &#x27;Errore nel contattare l&#x27;assistente virtuale&#x27;.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;// Manca il catch\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.reject(errore_VA));\ncontext.succeed = function(response)\n{\n\texpect(response).to.have.deep.property(&#x27;statusCode&#x27;, errore_VA.statusCode);\n\tdone();\n};\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;72719ad5-527a-4333-b8ab-cb83dacfbd08&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 5,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ca4a9b0d-24bc-4e9d-866a-f9a0fd24267d&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e35861dc-5dea-4a5c-9ca4-6be524e51ca2&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b8c336c8-2872-4ecf-aa99-c30c8d16e10c&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2e8f7e23-eacb-441a-9810-a1cef03226fb&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8db79abb-48f9-44d1-bbde-80caed51b679&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;537037f6-244c-484c-8780-32e6c31df918&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUserList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUserList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUserList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUserList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9361af75-3f01-48dc-90d3-7b1395e2f748&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fc8e5f44-dec8-4a92-92e4-82797dbb5cb6&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;aacc9fda-ab84-49e5-8a2a-18a17c21778b&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d8288d8c-8249-4ab1-b318-ca1a24ccab55&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3bba97c1-b319-464f-827c-6580ce0d52e0&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0848e405-6181-4673-9580-19fcbe86f160&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;920da242-edd9-4775-8503-5b1705e4a85b&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          };\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;621f6014-47d4-46ac-b602-7022869028f6&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;dc26f1cd-0b40-4eb9-b96e-2130b6654260&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;49259128-fd49-4f28-8be2-029cdd2a9d7c&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b7e74616-c559-4f09-80bd-2d47b78b9139&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d7e135ae-4bda-4761-997c-33f35525fce3&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;05baabe1-047c-4dab-94a4-69c63d7ad32f&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4bd2ade0-14a4-4948-98c1-049b4b136f61&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;47095238-ed93-401e-afc1-f1b0efc07e79&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f012c1bc-f24f-454a-ad2a-1071b4350b67&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8a8671d5-6a40-4ed9-bc61-441b9458e77d&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;010f819c-071b-4f42-87a5-62c2eace4d6c&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a3060f88-b54d-4d40-bad9-7eb5b7f5077e&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7608b3f8-a644-47b2-b6eb-47aaf6a0f7c9&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;sns.publish.yields(&#x27;Errore&#x27;);\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n\t\t\t\t\tpromise.returns(Promise.resolve(empty_action_response));\ncontext.succeed = function(args)\n{\n  expect(args).to.have.deep.property(&#x27;statusCode&#x27;, 500);\n  done();\n}\napi.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3bd5fb95-bf60-4dca-99e2-7f93208b8051&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n\texpect(response).have.property(&#x27;statusCode&#x27;, 200);\n\tdone();\n};\napi.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;496d6e7f-8281-4c9c-954d-b798b385a91d&quot;,
                        &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 30,
                    &quot;totalPasses&quot;: 30,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 100,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_removeRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;37e52dd5-12f1-47f2-bd1b-48e231369829&quot;,
                        &quot;parentUUID&quot;: &quot;c5310ea9-5894-4fcd-9ffe-eaa881a773d6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;c5310ea9-5894-4fcd-9ffe-eaa881a773d6&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;37e52dd5-12f1-47f2-bd1b-48e231369829&quot;,
                        &quot;parentUUID&quot;: &quot;c5310ea9-5894-4fcd-9ffe-eaa881a773d6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_removeUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;583e4f84-5b23-4d78-b169-fa3bb0921e7f&quot;,
                        &quot;parentUUID&quot;: &quot;ee4448cc-babc-4a19-b605-907e49bc3d6d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;ee4448cc-babc-4a19-b605-907e49bc3d6d&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;583e4f84-5b23-4d78-b169-fa3bb0921e7f&quot;,
                        &quot;parentUUID&quot;: &quot;ee4448cc-babc-4a19-b605-907e49bc3d6d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_resetUserEnrollment&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.resetEnrollments.returns(Rx.Observable.throw(errore));\napi._resetUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;34a78f11-93d3-4a7b-afa3-86bd3a343b6b&quot;,
                        &quot;parentUUID&quot;: &quot;afe55963-c3b0-4977-9865-7ba45e2f5912&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;afe55963-c3b0-4977-9865-7ba45e2f5912&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.resetEnrollments.returns(Rx.Observable.throw(errore));\napi._resetUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;34a78f11-93d3-4a7b-afa3-86bd3a343b6b&quot;,
                        &quot;parentUUID&quot;: &quot;afe55963-c3b0-4977-9865-7ba45e2f5912&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_updateRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;95946469-aace-4e3d-b2e5-bcf64a6b0093&quot;,
                        &quot;parentUUID&quot;: &quot;665bfc66-7676-4f29-8f6d-85b2f669c0a8&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;665bfc66-7676-4f29-8f6d-85b2f669c0a8&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;95946469-aace-4e3d-b2e5-bcf64a6b0093&quot;,
                        &quot;parentUUID&quot;: &quot;665bfc66-7676-4f29-8f6d-85b2f669c0a8&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_updateUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;56f762da-21cb-4578-9ee4-3abc5e29229f&quot;,
                        &quot;parentUUID&quot;: &quot;4f4698b1-8840-4f28-bef3-cc901b03b576&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;4f4698b1-8840-4f28-bef3-cc901b03b576&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;56f762da-21cb-4578-9ee4-3abc5e29229f&quot;,
                        &quot;parentUUID&quot;: &quot;4f4698b1-8840-4f28-bef3-cc901b03b576&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                &quot;uuid&quot;: &quot;8b4967f6-ada6-4fab-8e2d-a2322989c08e&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
            &quot;uuid&quot;: &quot;710e9955-c053-42b3-9883-46078f4d6942&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
        &quot;uuid&quot;: &quot;06e99186-e459-43a2-8e42-ed95975ec2ae&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Users&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;VocalLoginMicrosoftModule&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addEnrollment&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a76a2f2f-9d6b-4cbc-b8c9-2405a0914e1f&quot;,
                        &quot;parentUUID&quot;: &quot;8173a7a6-f364-431f-a588-914ed868cf4f&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;8173a7a6-f364-431f-a588-914ed868cf4f&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a76a2f2f-9d6b-4cbc-b8c9-2405a0914e1f&quot;,
                        &quot;parentUUID&quot;: &quot;8173a7a6-f364-431f-a588-914ed868cf4f&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;createUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7bdbe3eb-a5e9-42af-8ec9-d619eeb5e207&quot;,
                        &quot;parentUUID&quot;: &quot;4418e6a0-b72e-4a4b-81d5-7cfaf855d5d6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;4418e6a0-b72e-4a4b-81d5-7cfaf855d5d6&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7bdbe3eb-a5e9-42af-8ec9-d619eeb5e207&quot;,
                        &quot;parentUUID&quot;: &quot;4418e6a0-b72e-4a4b-81d5-7cfaf855d5d6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;deleteUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f17ed45a-d244-42a5-bd08-f5a25a24334a&quot;,
                        &quot;parentUUID&quot;: &quot;e8f26a91-4e52-4ec8-a3c9-e353376ae924&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;e8f26a91-4e52-4ec8-a3c9-e353376ae924&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f17ed45a-d244-42a5-bd08-f5a25a24334a&quot;,
                        &quot;parentUUID&quot;: &quot;e8f26a91-4e52-4ec8-a3c9-e353376ae924&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;doLogin&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject({ \&quot;result\&quot; : \&quot;Reject\&quot; }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;53ab4df3-2689-4621-a506-833e8b5dd81a&quot;,
                        &quot;parentUUID&quot;: &quot;6d8c1f87-7a5e-4b8a-a163-7504c2c235df&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;6d8c1f87-7a5e-4b8a-a163-7504c2c235df&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject({ \&quot;result\&quot; : \&quot;Reject\&quot; }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;53ab4df3-2689-4621-a506-833e8b5dd81a&quot;,
                        &quot;parentUUID&quot;: &quot;6d8c1f87-7a5e-4b8a-a163-7504c2c235df&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0dd2c718-4d78-4415-9be7-4e85213614a5&quot;,
                        &quot;parentUUID&quot;: &quot;b09acee4-fe6f-4633-8b60-a1fce0c1ae76&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;b09acee4-fe6f-4633-8b60-a1fce0c1ae76&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0dd2c718-4d78-4415-9be7-4e85213614a5&quot;,
                        &quot;parentUUID&quot;: &quot;b09acee4-fe6f-4633-8b60-a1fce0c1ae76&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n  {\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8fda8b33-cb55-4a6b-9322-f3257e9b7de3&quot;,
                        &quot;parentUUID&quot;: &quot;dd5b3c3e-9811-4d83-bd7f-32a07ceb1c84&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;dd5b3c3e-9811-4d83-bd7f-32a07ceb1c84&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n  {\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8fda8b33-cb55-4a6b-9322-f3257e9b7de3&quot;,
                        &quot;parentUUID&quot;: &quot;dd5b3c3e-9811-4d83-bd7f-32a07ceb1c84&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;resetEnrollments&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule resetEnrollments Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.resetEnrollments().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;63a59aa8-4778-4534-afc8-48021be8af20&quot;,
                        &quot;parentUUID&quot;: &quot;ee856de5-34b4-4605-a44a-b9ec16877fa0&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;ee856de5-34b4-4605-a44a-b9ec16877fa0&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule resetEnrollments Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.resetEnrollments().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;63a59aa8-4778-4534-afc8-48021be8af20&quot;,
                        &quot;parentUUID&quot;: &quot;ee856de5-34b4-4605-a44a-b9ec16877fa0&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                &quot;uuid&quot;: &quot;edc7538a-dcee-4e59-9fc7-5b0224b85093&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
            &quot;uuid&quot;: &quot;efa17305-6b17-42e0-923a-0ca521072bce&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
        &quot;uuid&quot;: &quot;6fe43875-e178-42a9-a822-0c27ecc13700&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      }
    ],
    &quot;tests&quot;: [],
    &quot;pending&quot;: [],
    &quot;root&quot;: true,
    &quot;_timeout&quot;: 2000,
    &quot;uuid&quot;: &quot;39d8e598-2a9e-469e-991a-68f1f5a1c8e4&quot;,
    &quot;fullFile&quot;: &quot;&quot;,
    &quot;file&quot;: &quot;&quot;,
    &quot;passes&quot;: [],
    &quot;failures&quot;: [],
    &quot;skipped&quot;: [],
    &quot;hasTests&quot;: false,
    &quot;hasSuites&quot;: true,
    &quot;totalTests&quot;: 0,
    &quot;totalPasses&quot;: 0,
    &quot;totalFailures&quot;: 0,
    &quot;totalPending&quot;: 0,
    &quot;totalSkipped&quot;: 0,
    &quot;hasPasses&quot;: false,
    &quot;hasFailures&quot;: false,
    &quot;hasPending&quot;: false,
    &quot;hasSkipped&quot;: false,
    &quot;duration&quot;: 0,
    &quot;rootEmpty&quot;: true
  },
  &quot;allTests&quot;: [
    {
      &quot;title&quot;: &quot;La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;201c125c-f6b5-4b67-b6b8-e0ab539e4842&quot;,
      &quot;parentUUID&quot;: &quot;6484bb47-e148-4798-a478-e126cd9f5af4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5775b128-2941-4e79-b0f9-2f15bae2e18c&quot;,
      &quot;parentUUID&quot;: &quot;6484bb47-e148-4798-a478-e126cd9f5af4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4da8d2f8-44be-4fc5-bd31-9399d1ae3461&quot;,
      &quot;parentUUID&quot;: &quot;1a1cd1c9-e32c-4605-ab3c-44f3e6c80553&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;600ac6f5-2684-4558-8ea7-87de516f8c5c&quot;,
      &quot;parentUUID&quot;: &quot;1a1cd1c9-e32c-4605-ab3c-44f3e6c80553&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getAgent Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;681c5cee-913f-4bf7-9b44-aeabca68166e&quot;,
      &quot;parentUUID&quot;: &quot;c934c740-0a08-4849-81ea-8a20b57e4b4b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getAgent Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = agents.getAgent(&#x27;mock_name&#x27;);\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;038a2e14-ab14-4ebe-bac6-e00d98b72213&quot;,
      &quot;parentUUID&quot;: &quot;c934c740-0a08-4849-81ea-8a20b57e4b4b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;2&#x27;});\ndynamo_client.scan.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e5cd0e7f-01ac-4fb0-b4eb-bb04696c2ba5&quot;,
      &quot;parentUUID&quot;: &quot;049f22aa-b4ad-48ee-8742-1bf878841a37&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getAgentList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b179bf2e-796b-4e79-805d-cffd322e0b26&quot;,
      &quot;parentUUID&quot;: &quot;049f22aa-b4ad-48ee-8742-1bf878841a37&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeAgent Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\&quot;error removing rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;79b91142-dd47-48bd-9fa1-2957bc46d414&quot;,
      &quot;parentUUID&quot;: &quot;91d34988-c360-4ba4-a4bb-a4b9cbb75abc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeAgent Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\&quot;success\&quot;});\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e4ec6986-86a1-44ae-89f2-6b43c0c935aa&quot;,
      &quot;parentUUID&quot;: &quot;91d34988-c360-4ba4-a4bb-a4b9cbb75abc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateAgent Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c9e304b9-0940-40ee-a2b0-412e32492ff1&quot;,
      &quot;parentUUID&quot;: &quot;8b278e1f-34f1-4b84-bf8e-95c49ae8e66f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateAgent Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9d9e1bc4-9000-4388-9d12-9f089ae581e5&quot;,
      &quot;parentUUID&quot;: &quot;8b278e1f-34f1-4b84-bf8e-95c49ae8e66f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
      &quot;fullTitle&quot;: &quot;query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;892857aa-c38d-463b-83a9-acd3fc8f120a&quot;,
      &quot;parentUUID&quot;: &quot;03ac273a-cbcb-4429-bb54-d233bbdf76da&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
      &quot;fullTitle&quot;: &quot;query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cedd67b2-da02-4f20-b5e8-58eeace39d3c&quot;,
      &quot;parentUUID&quot;: &quot;03ac273a-cbcb-4429-bb54-d233bbdf76da&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \&quot;Requested resource not found\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;56edd907-668d-4063-bb19-8217cca5a6f0&quot;,
      &quot;parentUUID&quot;: &quot;dd30394a-09cb-4e9e-a8f9-5927dd88e4f4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5d18a45e-92d8-4cd2-8938-97f8fe337bd7&quot;,
      &quot;parentUUID&quot;: &quot;dd30394a-09cb-4e9e-a8f9-5927dd88e4f4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \&quot;error adding message\&quot; });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d194eb24-0c42-462f-b421-22aa7e3d460b&quot;,
      &quot;parentUUID&quot;: &quot;8d4834da-337d-4b24-806d-a3a5ec17993a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;615d8d34-d57d-4855-a3c8-7143abe05c42&quot;,
      &quot;parentUUID&quot;: &quot;8d4834da-337d-4b24-806d-a3a5ec17993a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \&quot;error downloading conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ab391d2a-b749-46e6-9140-ed7e02c93382&quot;,
      &quot;parentUUID&quot;: &quot;b5e2d499-efac-4754-ae6c-c6f2760e032b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getConversation Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;449f94e7-2a51-41c5-8b40-96420ade2565&quot;,
      &quot;parentUUID&quot;: &quot;b5e2d499-efac-4754-ae6c-c6f2760e032b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;86d12a60-ec59-4149-b2cd-6110b5e6f02e&quot;,
      &quot;parentUUID&quot;: &quot;9331cd11-da9d-4bb6-a549-ce15952ba0c2&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getConversationList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ce356d05-8bc9-4525-9d1e-d36749e2eb16&quot;,
      &quot;parentUUID&quot;: &quot;9331cd11-da9d-4bb6-a549-ce15952ba0c2&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0ce15b90-37b9-4438-a8cf-06ff889498ad&quot;,
      &quot;parentUUID&quot;: &quot;f940f770-7e3e-4d84-a478-7ad367391deb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;53a18a88-6848-4b64-9cc2-8ee2675fd2b3&quot;,
      &quot;parentUUID&quot;: &quot;f940f770-7e3e-4d84-a478-7ad367391deb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 8,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;body.result.action = &#x27;user.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;admin&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e6e13f06-dc13-484f-945e-5dd2217d7484&quot;,
      &quot;parentUUID&quot;: &quot;4fc2923c-f1f2-4f37-8fae-3076405c0b5b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;body.result.action = &#x27;guest.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;, company : \&quot;Google\&quot;}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;welcome&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b4e6c206-b90d-484b-99fc-9b01000d66bd&quot;,
      &quot;parentUUID&quot;: &quot;4fc2923c-f1f2-4f37-8fae-3076405c0b5b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;expect(obs.next.bind(obs)).to.throw();&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7c5a8cf7-c3a7-4ee6-8d73-f33bbe2cf0ed&quot;,
      &quot;parentUUID&quot;: &quot;cdc0f1c0-5b38-4d08-9a7f-39d0beaefa22&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fd3fabb5-6ce2-4017-a233-ed53abda4369&quot;,
      &quot;parentUUID&quot;: &quot;e15832d4-001c-471f-8eb3-9d46f147d3e0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addGuest Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addGuest(&#x27;mauro&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c33f5247-5d82-4766-9891-8bae8aed8e0f&quot;,
      &quot;parentUUID&quot;: &quot;e15832d4-001c-471f-8eb3-9d46f147d3e0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \&quot;error getting data\&quot; });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e400a3d1-0f97-444b-8d42-6a98bbac998a&quot;,
      &quot;parentUUID&quot;: &quot;4d7bde28-3b1b-49b0-a43f-dac96e770980&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getGuest Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \&quot;Mauro\&quot;);\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\&quot;Zero12\&quot;);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a9510da0-ceb7-45a9-b28e-8898b3774e93&quot;,
      &quot;parentUUID&quot;: &quot;4d7bde28-3b1b-49b0-a43f-dac96e770980&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }], LastEvaluatedKey: &#x27;Luca&#x27;});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;adad55a9-79e2-43b1-b571-fd5d8bc93f74&quot;,
      &quot;parentUUID&quot;: &quot;fb50a842-aba7-401b-8d88-ba5b8cabc0e6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getGuestList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 8,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;52254194-5b02-457d-9b96-3962b59aabeb&quot;,
      &quot;parentUUID&quot;: &quot;fb50a842-aba7-401b-8d88-ba5b8cabc0e6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing guest\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;645b7505-cd3a-4d03-b7de-71d5165bffa6&quot;,
      &quot;parentUUID&quot;: &quot;559c0e51-e662-41e8-b03d-25aa60b9ccf3&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeGuest Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7ff14c2c-ad04-49e7-8090-808d7a93addb&quot;,
      &quot;parentUUID&quot;: &quot;559c0e51-e662-41e8-b03d-25aa60b9ccf3&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating guest\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;da58b96b-8c62-4f1b-85eb-39740939df91&quot;,
      &quot;parentUUID&quot;: &quot;499995c5-faa2-43ef-8b2c-ba41633e99af&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;754b4d11-15fd-40ce-96a0-3479e15d1f46&quot;,
      &quot;parentUUID&quot;: &quot;499995c5-faa2-43ef-8b2c-ba41633e99af&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c8166c54-da6a-4e3e-ae1d-597680253c34&quot;,
      &quot;parentUUID&quot;: &quot;3ae86c4f-6fed-4e0d-bd85-49d57775793c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1cdf300d-39d1-4e18-a54d-247cdcc39d02&quot;,
      &quot;parentUUID&quot;: &quot;3ae86c4f-6fed-4e0d-bd85-49d57775793c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;addMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.addMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7e20bd8e-cb26-4cac-9af6-b7ee0608b286&quot;,
      &quot;parentUUID&quot;: &quot;3fe428d4-204c-47cf-8f62-93e47a030d01&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
      &quot;fullTitle&quot;: &quot;getMember Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t&#x27;ok&#x27;: true,\n\t&#x27;user&#x27;:\n\t{\n\t\t&#x27;id&#x27;: &#x27;U023BECGF&#x27;,\n\t\t&#x27;name&#x27;: &#x27;bobby&#x27;,\n\t\t&#x27;deleted&#x27;: false,\n\t\t&#x27;color&#x27;: &#x27;9f69e7&#x27;,\n\t\t&#x27;profile&#x27;:\n\t\t{\n\t\t\t&#x27;avatar_hash&#x27;: &#x27;ge3b51ca72de&#x27;,\n\t\t\t&#x27;current_status&#x27;: &#x27;:mountain_railway: riding a train&#x27;,\n\t\t\t&#x27;first_name&#x27;: &#x27;Bobby&#x27;,\n\t\t\t&#x27;last_name&#x27;: &#x27;Tables&#x27;,\n\t\t\t&#x27;real_name&#x27;: &#x27;Bobby Tables&#x27;,\n\t\t\t&#x27;email&#x27;: &#x27;bobby@slack.com&#x27;,\n\t\t\t&#x27;skype&#x27;: &#x27;my-skype-name&#x27;,\n\t\t\t&#x27;phone&#x27;: &#x27;+1 (123) 456 7890&#x27;\n\t\t},\n\t\t&#x27;is_admin&#x27;: true,\n\t\t&#x27;is_owner&#x27;: true,\n\t\t&#x27;updated&#x27;: 1490054400,\n\t\t&#x27;has_2fa&#x27;: true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f5aff198-7e6c-496c-a9eb-6ecf1d6de1fe&quot;,
      &quot;parentUUID&quot;: &quot;3381f674-c74c-4cc9-94d6-cccf8c3aea50&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getMember Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;21969e3b-5d80-4e79-966d-388b8c02b590&quot;,
      &quot;parentUUID&quot;: &quot;3381f674-c74c-4cc9-94d6-cccf8c3aea50&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
      &quot;fullTitle&quot;: &quot;getMemberList L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\&quot;ok\&quot;: true,\n\t\&quot;members\&quot;:\n\t[\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECGF\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;mauro\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Mauro Bocciofilo\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t},\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECLL\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;bobby\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;,\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;313b15cc-32f0-4515-ac05-7269b708287b&quot;,
      &quot;parentUUID&quot;: &quot;ff91f221-b873-4648-a873-3ded9e313b2e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getMemberList Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;928f9f7d-fa05-4392-a4cc-7ddbcfb758bd&quot;,
      &quot;parentUUID&quot;: &quot;ff91f221-b873-4648-a873-3ded9e313b2e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;removeMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.removeMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;22183424-d062-4633-a0f9-33115a71c3ff&quot;,
      &quot;parentUUID&quot;: &quot;9541b917-ea95-44ae-b0ae-7ff27606a3fc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;updateMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.updateMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a59f1c23-335f-4238-a817-b005191ad772&quot;,
      &quot;parentUUID&quot;: &quot;df457aae-a51f-4a21-83b7-1ec667a3b385&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(&#x27;errore&#x27;);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n  done();\n}&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9c311b52-f5c8-4852-9a29-2deac3d26db6&quot;,
      &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields(&#x27;errore&#x27;);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;318761ec-5f8a-4dec-9ecc-3ba81bc9bade&quot;,
      &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(&#x27;errore&#x27;);\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;70e4010d-0d73-461d-af4e-72674e144954&quot;,
      &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 200);\n  done();\n}&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;eeb7b1ea-d646-41b4-94fc-4ea1a6aa2ca4&quot;,
      &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {request_event};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(&#x27;errore&#x27;);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: stub cannot yield since it was not yet invoked.\n  at Function.&lt;anonymous&gt; (node_modules\\sinon\\lib\\sinon\\spy.js:414:11)\n  at Function.spyApi.(anonymous function) (node_modules\\sinon\\lib\\sinon\\spy.js:361:34)\n  at Context.&lt;anonymous&gt; (src\\test\\test_NotificationService.js:89:35)\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2f29a161-60fb-4b3e-ad34-247098a6a5ae&quot;,
      &quot;parentUUID&quot;: &quot;2c206f5e-4ebe-485e-9347-381c69ff29d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {request_event};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: stub cannot yield since it was not yet invoked.\n  at Function.&lt;anonymous&gt; (node_modules\\sinon\\lib\\sinon\\spy.js:414:11)\n  at Function.spyApi.(anonymous function) (node_modules\\sinon\\lib\\sinon\\spy.js:361:34)\n  at Context.&lt;anonymous&gt; (src\\test\\test_NotificationService.js:101:35)\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2844f821-55eb-4d34-b908-b6d5917f4c9c&quot;,
      &quot;parentUUID&quot;: &quot;2c206f5e-4ebe-485e-9347-381c69ff29d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;TypeError: Cannot read property &#x27;channel&#x27; of undefined\n  at NotificationService.sendMsg (src\\Back-end\\Notifications\\NotificationService.js:175:39)\n  at Context.&lt;anonymous&gt; (src\\test\\test_NotificationService.js:112:14)\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3595d29e-ca2e-4a2c-a311-c3709da6be72&quot;,
      &quot;parentUUID&quot;: &quot;2c206f5e-4ebe-485e-9347-381c69ff29d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare complete_cb&quot;,
      &quot;fullTitle&quot;: &quot;complete Deve chiamare complete_cb&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \&quot;il callback di complete non è stato chiamato esattamente una volta.\&quot;).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f05c49c7-ff67-4d26-a4aa-f394d94f4612&quot;,
      &quot;parentUUID&quot;: &quot;9a7462f3-8afc-407d-addb-97283a8885e1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;complete Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;73738efc-3aa6-490e-b2c4-3835df6ef3ba&quot;,
      &quot;parentUUID&quot;: &quot;9a7462f3-8afc-407d-addb-97283a8885e1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;complete Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fc9943c7-4942-48d6-9c3d-4bf5a1b0c35e&quot;,
      &quot;parentUUID&quot;: &quot;9a7462f3-8afc-407d-addb-97283a8885e1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare error_cb&quot;,
      &quot;fullTitle&quot;: &quot;error Deve chiamare error_cb&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f16d7a0f-0b7c-4381-99cd-41e1b009a3cb&quot;,
      &quot;parentUUID&quot;: &quot;49c37700-2b2b-44aa-b5cd-cc1086e1e5f8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;error Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onError(success);\nobs.pause();\nobs.error(&#x27;errore&#x27;);\n        expect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;57b06065-1d80-4e60-b718-da166632e1e6&quot;,
      &quot;parentUUID&quot;: &quot;49c37700-2b2b-44aa-b5cd-cc1086e1e5f8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;error Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5c0f7bd7-4cd8-4feb-b788-0c19aae6b1fa&quot;,
      &quot;parentUUID&quot;: &quot;49c37700-2b2b-44aa-b5cd-cc1086e1e5f8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal(&#x27;data&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a91fe3d4-967b-4883-837e-6ec145eeab0f&quot;,
      &quot;parentUUID&quot;: &quot;9e368828-444c-43b3-80d5-5e289809a136&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;next Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.pause();\nobs.next(&#x27;Function called&#x27;);\nexpect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5a4940c3-0031-49b9-9392-544955ffba7c&quot;,
      &quot;parentUUID&quot;: &quot;9e368828-444c-43b3-80d5-5e289809a136&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next(&#x27;other data&#x27;);\nexpect(success.callCount).to.equal(2);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9d9f1afe-a149-4fde-bc35-3b7ce9404fbd&quot;,
      &quot;parentUUID&quot;: &quot;9e368828-444c-43b3-80d5-5e289809a136&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;15eaeb8f-5e68-4844-bee6-3b70dc2cec6c&quot;,
      &quot;parentUUID&quot;: &quot;61f257c4-c5ed-49e0-8733-3565b5574880&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3e346b4c-b95d-4b48-a70a-3cc33ff44e9f&quot;,
      &quot;parentUUID&quot;: &quot;61f257c4-c5ed-49e0-8733-3565b5574880&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;94729610-4e1b-4e1f-9e11-10af6ab45580&quot;,
      &quot;parentUUID&quot;: &quot;edf155e6-cd9b-4e3b-b368-142d412a9ccc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1246fbbc-7dc6-423c-b9d6-a2405b080479&quot;,
      &quot;parentUUID&quot;: &quot;edf155e6-cd9b-4e3b-b368-142d412a9ccc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3e59c6cf-8b9d-430c-a165-6c8c6169cb4d&quot;,
      &quot;parentUUID&quot;: &quot;deb25722-4df7-4922-9822-9af2ef3b4113&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;22a7480d-91eb-44ff-b256-3d8890c00465&quot;,
      &quot;parentUUID&quot;: &quot;deb25722-4df7-4922-9822-9af2ef3b4113&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;//da definire&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0ebfabdd-cafb-4249-90b1-2b16eb281a51&quot;,
      &quot;parentUUID&quot;: &quot;deb25722-4df7-4922-9822-9af2ef3b4113&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeRule Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f1059ebf-1910-4f56-bf60-8b03b9805a30&quot;,
      &quot;parentUUID&quot;: &quot;b6aaee9e-fe16-4aac-aa77-6ef83cc0d682&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeRule Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b8420c32-526c-4419-9a8c-5f10064c8d72&quot;,
      &quot;parentUUID&quot;: &quot;b6aaee9e-fe16-4aac-aa77-6ef83cc0d682&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c15370c4-0d06-42e5-8381-d2bc56c6c6a7&quot;,
      &quot;parentUUID&quot;: &quot;fa881d42-af8e-4f5b-aa13-e813a8623c0f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9d296d35-abb4-4a98-8cc2-1e4d078f5ead&quot;,
      &quot;parentUUID&quot;: &quot;fa881d42-af8e-4f5b-aa13-e813a8623c0f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \&quot;\&quot;};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;98e3dd70-89ce-459f-acdc-641b7bb9c10d&quot;,
      &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3b3e0afa-b7be-46c6-aeeb-9a34d637a900&quot;,
      &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b57b4b04-5426-4250-95b2-f5f4b1da7e66&quot;,
      &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d0fe8168-7054-4d00-9a15-28d037ad92a6&quot;,
      &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e762cf65-5242-4a88-820d-867e9f70a941&quot;,
      &quot;parentUUID&quot;: &quot;b2aa7e66-cdda-4625-87f8-ec110f9bf81c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;adfbf517-ef9e-4d3c-b3e3-a6a9cddd6154&quot;,
      &quot;parentUUID&quot;: &quot;b2aa7e66-cdda-4625-87f8-ec110f9bf81c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);\n};&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b6e6f97e-13c5-4fdc-90ab-cbf66d5dccfc&quot;,
      &quot;parentUUID&quot;: &quot;b2aa7e66-cdda-4625-87f8-ec110f9bf81c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c3e9053a-1c10-40b5-98bc-ffb89faf4b71&quot;,
      &quot;parentUUID&quot;: &quot;94738676-1a13-4e38-94c0-8e7d8b0c2463&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2438f097-3c80-4749-a83f-d3d0bb355fba&quot;,
      &quot;parentUUID&quot;: &quot;94738676-1a13-4e38-94c0-8e7d8b0c2463&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;653a4eca-a6b4-4eb7-aef5-508669e6d640&quot;,
      &quot;parentUUID&quot;: &quot;94738676-1a13-4e38-94c0-8e7d8b0c2463&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7219ab31-1903-4947-9eed-09f807fb27d3&quot;,
      &quot;parentUUID&quot;: &quot;8287b028-21b5-431e-b67a-4041c9c3e44d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a3b4feac-3e21-4c67-866a-65c6ea5bff97&quot;,
      &quot;parentUUID&quot;: &quot;8287b028-21b5-431e-b67a-4041c9c3e44d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c75cb0db-d9af-4c4b-998f-ac49afa95e4b&quot;,
      &quot;parentUUID&quot;: &quot;3c3c777c-2740-489e-84fd-284013434230&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a12a0138-eeeb-43e5-ab8c-189af276fd4e&quot;,
      &quot;parentUUID&quot;: &quot;3c3c777c-2740-489e-84fd-284013434230&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5e977a2c-c68a-4b31-be7d-bb983a9fc576&quot;,
      &quot;parentUUID&quot;: &quot;d4e83ef5-ca80-44bd-b820-4d08c7ba9249&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \&quot;\&quot; , body: \&quot;\&quot;};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fff7249c-ceab-498b-9e7e-a25a820882ef&quot;,
      &quot;parentUUID&quot;: &quot;d4e83ef5-ca80-44bd-b820-4d08c7ba9249&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fd82199a-105f-4c06-b1fc-b0f19ac4b324&quot;,
      &quot;parentUUID&quot;: &quot;d4e83ef5-ca80-44bd-b820-4d08c7ba9249&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
      &quot;fullTitle&quot;: &quot;speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;faf56f43-f076-4f33-aac3-2c3dbe23dfe7&quot;,
      &quot;parentUUID&quot;: &quot;13cd6e76-77c3-4acc-b934-55d12551993d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d6ba4de7-aca1-462a-bb7d-69ab63b9e260&quot;,
      &quot;parentUUID&quot;: &quot;5a594656-005d-44b1-928c-20b5b6343a63&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;08defae6-44e1-4b1c-afe8-1dff06b429d3&quot;,
      &quot;parentUUID&quot;: &quot;5a594656-005d-44b1-928c-20b5b6343a63&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getTask Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTask(&#x27;mock_type&#x27;).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a428e036-b2d4-49bf-ad4e-e2f7f9728912&quot;,
      &quot;parentUUID&quot;: &quot;f25873d1-00b0-4a8f-b334-ded563900812&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getTask Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = tasks.getTask(&#x27;mock_type&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3e7609b0-f517-4d26-87cb-ffbc7180ed15&quot;,
      &quot;parentUUID&quot;: &quot;f25873d1-00b0-4a8f-b334-ded563900812&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \&quot;mock_type3\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;02d9accf-3ca9-41b3-857d-4cd3eee98884&quot;,
      &quot;parentUUID&quot;: &quot;101cfe00-c24e-4229-922d-fbd255aa004e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;73ed2dc2-d926-40af-a3e3-842b60aa7fc7&quot;,
      &quot;parentUUID&quot;: &quot;101cfe00-c24e-4229-922d-fbd255aa004e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1848671c-66e6-44a0-acf2-d290cb6382f0&quot;,
      &quot;parentUUID&quot;: &quot;2ecf9916-8690-4db7-a3f9-11182b852491&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e4f51a84-7020-4a9e-a016-3272c933f00f&quot;,
      &quot;parentUUID&quot;: &quot;2ecf9916-8690-4db7-a3f9-11182b852491&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;454c1179-853e-45e7-bd25-9b034723f652&quot;,
      &quot;parentUUID&quot;: &quot;7a96f36c-94e0-491b-a0ff-ad0ce195e8b5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e235b321-4e3e-4769-aef8-1ca967a429a8&quot;,
      &quot;parentUUID&quot;: &quot;7a96f36c-94e0-491b-a0ff-ad0ce195e8b5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\&quot;Requested resource not found\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;af67856f-3de2-4c43-9202-6b33d74c330c&quot;,
      &quot;parentUUID&quot;: &quot;aeae1446-b11b-4b06-aea9-6ae51733d593&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fb039aa0-b2ea-42f5-9910-52b63ea77179&quot;,
      &quot;parentUUID&quot;: &quot;aeae1446-b11b-4b06-aea9-6ae51733d593&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ac50f261-0403-4af0-93ee-5426e49438cb&quot;,
      &quot;parentUUID&quot;: &quot;ff4ad3b8-0674-4085-8d0d-4132f11d6d31&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = users.getUser(&#x27;mou&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\n\t\t\t\t\texpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0a34898d-bac4-4add-badc-46683e904ce8&quot;,
      &quot;parentUUID&quot;: &quot;ff4ad3b8-0674-4085-8d0d-4132f11d6d31&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}], LastEvaluatedKey: &#x27;marco&#x27;});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;71bec860-59c0-468d-8f31-0096103a781f&quot;,
      &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;63228552-797c-4e0b-b0b4-db7be8027e24&quot;,
      &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;aa5fc92f-6517-4d10-a8db-bae03580113a&quot;,
      &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;,\n\tslack_channel: &#x27;channel&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name and slack_channel = :slack_channel&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:slack_channel&#x27;, &#x27;channel&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9d3b5690-b034-4b69-a0c3-e3f428632869&quot;,
      &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeUser Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \&quot;error removing user\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;58f8769f-fbbb-414b-a799-c445e069e88e&quot;,
      &quot;parentUUID&quot;: &quot;5ac8bd5a-9a5a-400d-bf11-fec8a903e77b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;removeUser Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e9622257-893d-4ddd-b674-b5963c613b76&quot;,
      &quot;parentUUID&quot;: &quot;5ac8bd5a-9a5a-400d-bf11-fec8a903e77b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \&quot;error updating user\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;91850804-7575-40b0-b670-2d4c4896d8b3&quot;,
      &quot;parentUUID&quot;: &quot;fdf1a4b7-c403-4d66-ae64-820fa14f3606&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1d0cc82f-3cc7-4b5b-a7fa-505821648875&quot;,
      &quot;parentUUID&quot;: &quot;fdf1a4b7-c403-4d66-ae64-820fa14f3606&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;089a912a-aecf-4485-9906-76f472715847&quot;,
      &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;63775100-ff4b-4ce0-8fd5-fc200ba95b0f&quot;,
      &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \&quot;\&quot; };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5771b81a-00a2-485e-abca-327039381dd4&quot;,
      &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;df221a75-311d-4738-801a-c49843bcf83e&quot;,
      &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d014fde5-db8e-4e5c-9fa7-f282afc46836&quot;,
      &quot;parentUUID&quot;: &quot;ed489e91-85fb-46c7-8342-e57c0743d069&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f498d75d-7b20-4cc4-884e-3d101a2099f1&quot;,
      &quot;parentUUID&quot;: &quot;ed489e91-85fb-46c7-8342-e57c0743d069&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { pathParameters: { username: &#x27;pippo&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;82a61ea1-4888-4efb-a864-2dedf3e33752&quot;,
      &quot;parentUUID&quot;: &quot;ed489e91-85fb-46c7-8342-e57c0743d069&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9f4940a2-7dd2-477a-9321-d608ac3e0bfa&quot;,
      &quot;parentUUID&quot;: &quot;e2986c45-3325-4cdf-9fb4-37e4a993cd46&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;84767ef0-2309-419a-88b5-7b10056164d8&quot;,
      &quot;parentUUID&quot;: &quot;e2986c45-3325-4cdf-9fb4-37e4a993cd46&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\n          let ev = { pathParameters: { username: &#x27;pippo&#x27;} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ac78051f-0dd2-4da0-ab3e-54e85ca14edc&quot;,
      &quot;parentUUID&quot;: &quot;e2986c45-3325-4cdf-9fb4-37e4a993cd46&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;67fe971b-f87b-4cc9-a541-9999e0423b86&quot;,
      &quot;parentUUID&quot;: &quot;26ec5209-e4c6-4ce1-82e8-d03d68d9c6d6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ users: [{ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cea9fc7d-40bb-434b-94bd-29c6cf0354c9&quot;,
      &quot;parentUUID&quot;: &quot;26ec5209-e4c6-4ce1-82e8-d03d68d9c6d6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9086399a-bda1-40ba-b05f-945023a0a52b&quot;,
      &quot;parentUUID&quot;: &quot;17d3f16f-1440-4e51-927c-e04805295041&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;080c9b1e-b60c-452d-93f7-b8f8564a5e2e&quot;,
      &quot;parentUUID&quot;: &quot;17d3f16f-1440-4e51-927c-e04805295041&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = { pathParameters: \&quot;\&quot;, body: \&quot;\&quot; };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8bfda398-f498-42da-a60f-62633084a0f5&quot;,
      &quot;parentUUID&quot;: &quot;17d3f16f-1440-4e51-927c-e04805295041&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {
        &quot;name&quot;: &quot;AssertionError&quot;,
        &quot;message&quot;: &quot;expected 1 to be above 1&quot;,
        &quot;showDiff&quot;: false,
        &quot;actual&quot;: 1,
        &quot;estack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:54:36)\n&quot;,
        &quot;stack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:54:36)\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4a8e2960-e8a9-4180-a9f9-7ff28e5272c8&quot;,
      &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {
        &quot;name&quot;: &quot;AssertionError&quot;,
        &quot;message&quot;: &quot;expected 1 to be above 1&quot;,
        &quot;showDiff&quot;: false,
        &quot;actual&quot;: 1,
        &quot;estack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:67:36)\n&quot;,
        &quot;stack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:67:36)\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fab7dbb3-a4d2-4ad6-9782-d344f42e70cb&quot;,
      &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;msg&#x27;: &#x27;error getting guest&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3c003d51-33fd-4b06-976f-072340d2b2e6&quot;,
      &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ &#x27;msg&#x27;: &#x27;error adding conversation&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;987b6a01-c708-4bcc-be5f-c895046d9c7b&quot;,
      &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;type&#x27;: &#x27;example&#x27; });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c69a5fbf-7258-4d9b-839b-f789885cb000&quot;,
      &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
      &quot;fullTitle&quot;: &quot;query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith(&#x27;test&#x27;));\n\tlet result = context.succeed.getCall(0).args[0];\n            expect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n            done();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2051a21b-4c35-4779-84e7-f13aa3ae1c2a&quot;,
      &quot;parentUUID&quot;: &quot;9ec9fb3d-1b49-4f6b-be7c-241a74a68141&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
      &quot;fullTitle&quot;: &quot;query Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.reject(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n            done();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1ea70980-80a4-4686-a80f-3ca41b31ca01&quot;,
      &quot;parentUUID&quot;: &quot;9ec9fb3d-1b49-4f6b-be7c-241a74a68141&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b60e4a82-00f8-46d8-abf4-6c086aa3b62b&quot;,
      &quot;parentUUID&quot;: &quot;8e09aa21-be16-4203-a2f9-698a7f9bda2f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cb35b38c-4874-4ddb-864c-1c606affc554&quot;,
      &quot;parentUUID&quot;: &quot;fb6484a0-e7ab-490f-967f-37d7bf3bb4be&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.addEnrollment.returns(Rx.Observable.throw(errore));\napi._addUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8d10e8fe-7ae8-4553-b722-1e948809daa8&quot;,
      &quot;parentUUID&quot;: &quot;8ac3a77d-a36f-486e-b032-d1f969a3dd78&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;de6241a9-9d63-4709-b6b2-1f0d8f49153b&quot;,
      &quot;parentUUID&quot;: &quot;66c308d0-9cc6-43ec-8a14-c5948f490a34&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cc94634f-a9f7-47b7-9598-bd85767c1241&quot;,
      &quot;parentUUID&quot;: &quot;d25fee7e-54b0-4cd6-8f50-39479e231437&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b2b7a2c8-d9a2-44e2-b12f-9f16e0a6af31&quot;,
      &quot;parentUUID&quot;: &quot;90cf3ec7-7575-40c6-8ac9-d78f19b49aeb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3364ab4a-aaf5-4631-910a-b040fb42a8af&quot;,
      &quot;parentUUID&quot;: &quot;c3b82a4c-84d7-43e3-a5e5-c06fe5a799ed&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
      &quot;fullTitle&quot;: &quot;_loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.doLogin.returns(Rx.Observable.throw(errore));\napi._loginUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0e93df58-d56c-409f-803a-35ad1dfc3bad&quot;,
      &quot;parentUUID&quot;: &quot;f98c281f-cbdd-4e0d-9547-931289b28203&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;// Manca il catch\nstt.speechToText.returns(Promise.reject(&#x27;Speech to Text Error&#x27;));\ncontext.succeed = function(response)\n{\n\texpect(response).have.property(&#x27;statusCode&#x27;, 500);\n\tdone();\n};\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0ead4d51-e553-4028-9634-ba401218908d&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se lo status della risposta ricevuta dall&#x27;assistente virtuale è diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio &#x27;Errore nel contattare l&#x27;assistente virtuale&#x27;.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se lo status della risposta ricevuta dall&#x27;assistente virtuale è diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio &#x27;Errore nel contattare l&#x27;assistente virtuale&#x27;.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;// Manca il catch\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.reject(errore_VA));\ncontext.succeed = function(response)\n{\n\texpect(response).to.have.deep.property(&#x27;statusCode&#x27;, errore_VA.statusCode);\n\tdone();\n};\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;72719ad5-527a-4333-b8ab-cb83dacfbd08&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 5,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ca4a9b0d-24bc-4e9d-866a-f9a0fd24267d&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e35861dc-5dea-4a5c-9ca4-6be524e51ca2&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b8c336c8-2872-4ecf-aa99-c30c8d16e10c&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2e8f7e23-eacb-441a-9810-a1cef03226fb&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8db79abb-48f9-44d1-bbde-80caed51b679&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;537037f6-244c-484c-8780-32e6c31df918&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUserList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUserList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUserList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUserList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9361af75-3f01-48dc-90d3-7b1395e2f748&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fc8e5f44-dec8-4a92-92e4-82797dbb5cb6&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;aacc9fda-ab84-49e5-8a2a-18a17c21778b&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d8288d8c-8249-4ab1-b318-ca1a24ccab55&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3bba97c1-b319-464f-827c-6580ce0d52e0&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0848e405-6181-4673-9580-19fcbe86f160&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;920da242-edd9-4775-8503-5b1705e4a85b&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          };\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;621f6014-47d4-46ac-b602-7022869028f6&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;dc26f1cd-0b40-4eb9-b96e-2130b6654260&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;49259128-fd49-4f28-8be2-029cdd2a9d7c&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b7e74616-c559-4f09-80bd-2d47b78b9139&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d7e135ae-4bda-4761-997c-33f35525fce3&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;05baabe1-047c-4dab-94a4-69c63d7ad32f&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4bd2ade0-14a4-4948-98c1-049b4b136f61&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;47095238-ed93-401e-afc1-f1b0efc07e79&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f012c1bc-f24f-454a-ad2a-1071b4350b67&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8a8671d5-6a40-4ed9-bc61-441b9458e77d&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;010f819c-071b-4f42-87a5-62c2eace4d6c&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a3060f88-b54d-4d40-bad9-7eb5b7f5077e&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7608b3f8-a644-47b2-b6eb-47aaf6a0f7c9&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari a 500.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;sns.publish.yields(&#x27;Errore&#x27;);\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n\t\t\t\t\tpromise.returns(Promise.resolve(empty_action_response));\ncontext.succeed = function(args)\n{\n  expect(args).to.have.deep.property(&#x27;statusCode&#x27;, 500);\n  done();\n}\napi.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3bd5fb95-bf60-4dca-99e2-7f93208b8051&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n\texpect(response).have.property(&#x27;statusCode&#x27;, 200);\n\tdone();\n};\napi.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;496d6e7f-8281-4c9c-954d-b798b385a91d&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;37e52dd5-12f1-47f2-bd1b-48e231369829&quot;,
      &quot;parentUUID&quot;: &quot;c5310ea9-5894-4fcd-9ffe-eaa881a773d6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;583e4f84-5b23-4d78-b169-fa3bb0921e7f&quot;,
      &quot;parentUUID&quot;: &quot;ee4448cc-babc-4a19-b605-907e49bc3d6d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.resetEnrollments.returns(Rx.Observable.throw(errore));\napi._resetUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;34a78f11-93d3-4a7b-afa3-86bd3a343b6b&quot;,
      &quot;parentUUID&quot;: &quot;afe55963-c3b0-4977-9865-7ba45e2f5912&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;95946469-aace-4e3d-b2e5-bcf64a6b0093&quot;,
      &quot;parentUUID&quot;: &quot;665bfc66-7676-4f29-8f6d-85b2f669c0a8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;56f762da-21cb-4578-9ee4-3abc5e29229f&quot;,
      &quot;parentUUID&quot;: &quot;4f4698b1-8840-4f28-bef3-cc901b03b576&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a76a2f2f-9d6b-4cbc-b8c9-2405a0914e1f&quot;,
      &quot;parentUUID&quot;: &quot;8173a7a6-f364-431f-a588-914ed868cf4f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7bdbe3eb-a5e9-42af-8ec9-d619eeb5e207&quot;,
      &quot;parentUUID&quot;: &quot;4418e6a0-b72e-4a4b-81d5-7cfaf855d5d6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f17ed45a-d244-42a5-bd08-f5a25a24334a&quot;,
      &quot;parentUUID&quot;: &quot;e8f26a91-4e52-4ec8-a3c9-e353376ae924&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject({ \&quot;result\&quot; : \&quot;Reject\&quot; }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;53ab4df3-2689-4621-a506-833e8b5dd81a&quot;,
      &quot;parentUUID&quot;: &quot;6d8c1f87-7a5e-4b8a-a163-7504c2c235df&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0dd2c718-4d78-4415-9be7-4e85213614a5&quot;,
      &quot;parentUUID&quot;: &quot;b09acee4-fe6f-4633-8b60-a1fce0c1ae76&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n  {\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8fda8b33-cb55-4a6b-9322-f3257e9b7de3&quot;,
      &quot;parentUUID&quot;: &quot;dd5b3c3e-9811-4d83-bd7f-32a07ceb1c84&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;resetEnrollments Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.resetEnrollments().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;63a59aa8-4778-4534-afc8-48021be8af20&quot;,
      &quot;parentUUID&quot;: &quot;ee856de5-34b4-4605-a44a-b9ec16877fa0&quot;,
      &quot;skipped&quot;: false
    }
  ],
  &quot;allPending&quot;: [],
  &quot;allPasses&quot;: [
    {
      &quot;title&quot;: &quot;La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;201c125c-f6b5-4b67-b6b8-e0ab539e4842&quot;,
      &quot;parentUUID&quot;: &quot;6484bb47-e148-4798-a478-e126cd9f5af4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5775b128-2941-4e79-b0f9-2f15bae2e18c&quot;,
      &quot;parentUUID&quot;: &quot;6484bb47-e148-4798-a478-e126cd9f5af4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4da8d2f8-44be-4fc5-bd31-9399d1ae3461&quot;,
      &quot;parentUUID&quot;: &quot;1a1cd1c9-e32c-4605-ab3c-44f3e6c80553&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;600ac6f5-2684-4558-8ea7-87de516f8c5c&quot;,
      &quot;parentUUID&quot;: &quot;1a1cd1c9-e32c-4605-ab3c-44f3e6c80553&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getAgent Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;681c5cee-913f-4bf7-9b44-aeabca68166e&quot;,
      &quot;parentUUID&quot;: &quot;c934c740-0a08-4849-81ea-8a20b57e4b4b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getAgent Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = agents.getAgent(&#x27;mock_name&#x27;);\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;038a2e14-ab14-4ebe-bac6-e00d98b72213&quot;,
      &quot;parentUUID&quot;: &quot;c934c740-0a08-4849-81ea-8a20b57e4b4b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;2&#x27;});\ndynamo_client.scan.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e5cd0e7f-01ac-4fb0-b4eb-bb04696c2ba5&quot;,
      &quot;parentUUID&quot;: &quot;049f22aa-b4ad-48ee-8742-1bf878841a37&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getAgentList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b179bf2e-796b-4e79-805d-cffd322e0b26&quot;,
      &quot;parentUUID&quot;: &quot;049f22aa-b4ad-48ee-8742-1bf878841a37&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeAgent Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\&quot;error removing rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;79b91142-dd47-48bd-9fa1-2957bc46d414&quot;,
      &quot;parentUUID&quot;: &quot;91d34988-c360-4ba4-a4bb-a4b9cbb75abc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeAgent Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\&quot;success\&quot;});\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e4ec6986-86a1-44ae-89f2-6b43c0c935aa&quot;,
      &quot;parentUUID&quot;: &quot;91d34988-c360-4ba4-a4bb-a4b9cbb75abc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateAgent Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c9e304b9-0940-40ee-a2b0-412e32492ff1&quot;,
      &quot;parentUUID&quot;: &quot;8b278e1f-34f1-4b84-bf8e-95c49ae8e66f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateAgent Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9d9e1bc4-9000-4388-9d12-9f089ae581e5&quot;,
      &quot;parentUUID&quot;: &quot;8b278e1f-34f1-4b84-bf8e-95c49ae8e66f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
      &quot;fullTitle&quot;: &quot;query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;892857aa-c38d-463b-83a9-acd3fc8f120a&quot;,
      &quot;parentUUID&quot;: &quot;03ac273a-cbcb-4429-bb54-d233bbdf76da&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
      &quot;fullTitle&quot;: &quot;query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cedd67b2-da02-4f20-b5e8-58eeace39d3c&quot;,
      &quot;parentUUID&quot;: &quot;03ac273a-cbcb-4429-bb54-d233bbdf76da&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \&quot;Requested resource not found\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;56edd907-668d-4063-bb19-8217cca5a6f0&quot;,
      &quot;parentUUID&quot;: &quot;dd30394a-09cb-4e9e-a8f9-5927dd88e4f4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5d18a45e-92d8-4cd2-8938-97f8fe337bd7&quot;,
      &quot;parentUUID&quot;: &quot;dd30394a-09cb-4e9e-a8f9-5927dd88e4f4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \&quot;error adding message\&quot; });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d194eb24-0c42-462f-b421-22aa7e3d460b&quot;,
      &quot;parentUUID&quot;: &quot;8d4834da-337d-4b24-806d-a3a5ec17993a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;615d8d34-d57d-4855-a3c8-7143abe05c42&quot;,
      &quot;parentUUID&quot;: &quot;8d4834da-337d-4b24-806d-a3a5ec17993a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \&quot;error downloading conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ab391d2a-b749-46e6-9140-ed7e02c93382&quot;,
      &quot;parentUUID&quot;: &quot;b5e2d499-efac-4754-ae6c-c6f2760e032b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getConversation Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;449f94e7-2a51-41c5-8b40-96420ade2565&quot;,
      &quot;parentUUID&quot;: &quot;b5e2d499-efac-4754-ae6c-c6f2760e032b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;86d12a60-ec59-4149-b2cd-6110b5e6f02e&quot;,
      &quot;parentUUID&quot;: &quot;9331cd11-da9d-4bb6-a549-ce15952ba0c2&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getConversationList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ce356d05-8bc9-4525-9d1e-d36749e2eb16&quot;,
      &quot;parentUUID&quot;: &quot;9331cd11-da9d-4bb6-a549-ce15952ba0c2&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0ce15b90-37b9-4438-a8cf-06ff889498ad&quot;,
      &quot;parentUUID&quot;: &quot;f940f770-7e3e-4d84-a478-7ad367391deb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;53a18a88-6848-4b64-9cc2-8ee2675fd2b3&quot;,
      &quot;parentUUID&quot;: &quot;f940f770-7e3e-4d84-a478-7ad367391deb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 8,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;body.result.action = &#x27;user.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;admin&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e6e13f06-dc13-484f-945e-5dd2217d7484&quot;,
      &quot;parentUUID&quot;: &quot;4fc2923c-f1f2-4f37-8fae-3076405c0b5b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;body.result.action = &#x27;guest.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;, company : \&quot;Google\&quot;}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;welcome&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b4e6c206-b90d-484b-99fc-9b01000d66bd&quot;,
      &quot;parentUUID&quot;: &quot;4fc2923c-f1f2-4f37-8fae-3076405c0b5b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;expect(obs.next.bind(obs)).to.throw();&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7c5a8cf7-c3a7-4ee6-8d73-f33bbe2cf0ed&quot;,
      &quot;parentUUID&quot;: &quot;cdc0f1c0-5b38-4d08-9a7f-39d0beaefa22&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fd3fabb5-6ce2-4017-a233-ed53abda4369&quot;,
      &quot;parentUUID&quot;: &quot;e15832d4-001c-471f-8eb3-9d46f147d3e0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addGuest Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addGuest(&#x27;mauro&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c33f5247-5d82-4766-9891-8bae8aed8e0f&quot;,
      &quot;parentUUID&quot;: &quot;e15832d4-001c-471f-8eb3-9d46f147d3e0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \&quot;error getting data\&quot; });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e400a3d1-0f97-444b-8d42-6a98bbac998a&quot;,
      &quot;parentUUID&quot;: &quot;4d7bde28-3b1b-49b0-a43f-dac96e770980&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getGuest Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \&quot;Mauro\&quot;);\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\&quot;Zero12\&quot;);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a9510da0-ceb7-45a9-b28e-8898b3774e93&quot;,
      &quot;parentUUID&quot;: &quot;4d7bde28-3b1b-49b0-a43f-dac96e770980&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }], LastEvaluatedKey: &#x27;Luca&#x27;});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;adad55a9-79e2-43b1-b571-fd5d8bc93f74&quot;,
      &quot;parentUUID&quot;: &quot;fb50a842-aba7-401b-8d88-ba5b8cabc0e6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getGuestList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 8,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;52254194-5b02-457d-9b96-3962b59aabeb&quot;,
      &quot;parentUUID&quot;: &quot;fb50a842-aba7-401b-8d88-ba5b8cabc0e6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing guest\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;645b7505-cd3a-4d03-b7de-71d5165bffa6&quot;,
      &quot;parentUUID&quot;: &quot;559c0e51-e662-41e8-b03d-25aa60b9ccf3&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeGuest Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7ff14c2c-ad04-49e7-8090-808d7a93addb&quot;,
      &quot;parentUUID&quot;: &quot;559c0e51-e662-41e8-b03d-25aa60b9ccf3&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating guest\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;da58b96b-8c62-4f1b-85eb-39740939df91&quot;,
      &quot;parentUUID&quot;: &quot;499995c5-faa2-43ef-8b2c-ba41633e99af&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;754b4d11-15fd-40ce-96a0-3479e15d1f46&quot;,
      &quot;parentUUID&quot;: &quot;499995c5-faa2-43ef-8b2c-ba41633e99af&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c8166c54-da6a-4e3e-ae1d-597680253c34&quot;,
      &quot;parentUUID&quot;: &quot;3ae86c4f-6fed-4e0d-bd85-49d57775793c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1cdf300d-39d1-4e18-a54d-247cdcc39d02&quot;,
      &quot;parentUUID&quot;: &quot;3ae86c4f-6fed-4e0d-bd85-49d57775793c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;addMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.addMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7e20bd8e-cb26-4cac-9af6-b7ee0608b286&quot;,
      &quot;parentUUID&quot;: &quot;3fe428d4-204c-47cf-8f62-93e47a030d01&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
      &quot;fullTitle&quot;: &quot;getMember Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t&#x27;ok&#x27;: true,\n\t&#x27;user&#x27;:\n\t{\n\t\t&#x27;id&#x27;: &#x27;U023BECGF&#x27;,\n\t\t&#x27;name&#x27;: &#x27;bobby&#x27;,\n\t\t&#x27;deleted&#x27;: false,\n\t\t&#x27;color&#x27;: &#x27;9f69e7&#x27;,\n\t\t&#x27;profile&#x27;:\n\t\t{\n\t\t\t&#x27;avatar_hash&#x27;: &#x27;ge3b51ca72de&#x27;,\n\t\t\t&#x27;current_status&#x27;: &#x27;:mountain_railway: riding a train&#x27;,\n\t\t\t&#x27;first_name&#x27;: &#x27;Bobby&#x27;,\n\t\t\t&#x27;last_name&#x27;: &#x27;Tables&#x27;,\n\t\t\t&#x27;real_name&#x27;: &#x27;Bobby Tables&#x27;,\n\t\t\t&#x27;email&#x27;: &#x27;bobby@slack.com&#x27;,\n\t\t\t&#x27;skype&#x27;: &#x27;my-skype-name&#x27;,\n\t\t\t&#x27;phone&#x27;: &#x27;+1 (123) 456 7890&#x27;\n\t\t},\n\t\t&#x27;is_admin&#x27;: true,\n\t\t&#x27;is_owner&#x27;: true,\n\t\t&#x27;updated&#x27;: 1490054400,\n\t\t&#x27;has_2fa&#x27;: true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f5aff198-7e6c-496c-a9eb-6ecf1d6de1fe&quot;,
      &quot;parentUUID&quot;: &quot;3381f674-c74c-4cc9-94d6-cccf8c3aea50&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getMember Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;21969e3b-5d80-4e79-966d-388b8c02b590&quot;,
      &quot;parentUUID&quot;: &quot;3381f674-c74c-4cc9-94d6-cccf8c3aea50&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
      &quot;fullTitle&quot;: &quot;getMemberList L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\&quot;ok\&quot;: true,\n\t\&quot;members\&quot;:\n\t[\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECGF\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;mauro\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Mauro Bocciofilo\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t},\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECLL\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;bobby\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;,\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;313b15cc-32f0-4515-ac05-7269b708287b&quot;,
      &quot;parentUUID&quot;: &quot;ff91f221-b873-4648-a873-3ded9e313b2e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getMemberList Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;928f9f7d-fa05-4392-a4cc-7ddbcfb758bd&quot;,
      &quot;parentUUID&quot;: &quot;ff91f221-b873-4648-a873-3ded9e313b2e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;removeMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.removeMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;22183424-d062-4633-a0f9-33115a71c3ff&quot;,
      &quot;parentUUID&quot;: &quot;9541b917-ea95-44ae-b0ae-7ff27606a3fc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;updateMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.updateMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a59f1c23-335f-4238-a817-b005191ad772&quot;,
      &quot;parentUUID&quot;: &quot;df457aae-a51f-4a21-83b7-1ec667a3b385&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(&#x27;errore&#x27;);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n  done();\n}&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9c311b52-f5c8-4852-9a29-2deac3d26db6&quot;,
      &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields(&#x27;errore&#x27;);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;318761ec-5f8a-4dec-9ecc-3ba81bc9bade&quot;,
      &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(&#x27;errore&#x27;);\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;70e4010d-0d73-461d-af4e-72674e144954&quot;,
      &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 200);\n  done();\n}&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;eeb7b1ea-d646-41b4-94fc-4ea1a6aa2ca4&quot;,
      &quot;parentUUID&quot;: &quot;a6316270-12a2-42b6-b7ab-45f7d7687a54&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare complete_cb&quot;,
      &quot;fullTitle&quot;: &quot;complete Deve chiamare complete_cb&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \&quot;il callback di complete non è stato chiamato esattamente una volta.\&quot;).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f05c49c7-ff67-4d26-a4aa-f394d94f4612&quot;,
      &quot;parentUUID&quot;: &quot;9a7462f3-8afc-407d-addb-97283a8885e1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;complete Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;73738efc-3aa6-490e-b2c4-3835df6ef3ba&quot;,
      &quot;parentUUID&quot;: &quot;9a7462f3-8afc-407d-addb-97283a8885e1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;complete Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fc9943c7-4942-48d6-9c3d-4bf5a1b0c35e&quot;,
      &quot;parentUUID&quot;: &quot;9a7462f3-8afc-407d-addb-97283a8885e1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare error_cb&quot;,
      &quot;fullTitle&quot;: &quot;error Deve chiamare error_cb&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f16d7a0f-0b7c-4381-99cd-41e1b009a3cb&quot;,
      &quot;parentUUID&quot;: &quot;49c37700-2b2b-44aa-b5cd-cc1086e1e5f8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;error Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onError(success);\nobs.pause();\nobs.error(&#x27;errore&#x27;);\n        expect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;57b06065-1d80-4e60-b718-da166632e1e6&quot;,
      &quot;parentUUID&quot;: &quot;49c37700-2b2b-44aa-b5cd-cc1086e1e5f8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;error Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5c0f7bd7-4cd8-4feb-b788-0c19aae6b1fa&quot;,
      &quot;parentUUID&quot;: &quot;49c37700-2b2b-44aa-b5cd-cc1086e1e5f8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal(&#x27;data&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a91fe3d4-967b-4883-837e-6ec145eeab0f&quot;,
      &quot;parentUUID&quot;: &quot;9e368828-444c-43b3-80d5-5e289809a136&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;next Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.pause();\nobs.next(&#x27;Function called&#x27;);\nexpect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5a4940c3-0031-49b9-9392-544955ffba7c&quot;,
      &quot;parentUUID&quot;: &quot;9e368828-444c-43b3-80d5-5e289809a136&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next(&#x27;other data&#x27;);\nexpect(success.callCount).to.equal(2);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9d9f1afe-a149-4fde-bc35-3b7ce9404fbd&quot;,
      &quot;parentUUID&quot;: &quot;9e368828-444c-43b3-80d5-5e289809a136&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;15eaeb8f-5e68-4844-bee6-3b70dc2cec6c&quot;,
      &quot;parentUUID&quot;: &quot;61f257c4-c5ed-49e0-8733-3565b5574880&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3e346b4c-b95d-4b48-a70a-3cc33ff44e9f&quot;,
      &quot;parentUUID&quot;: &quot;61f257c4-c5ed-49e0-8733-3565b5574880&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;94729610-4e1b-4e1f-9e11-10af6ab45580&quot;,
      &quot;parentUUID&quot;: &quot;edf155e6-cd9b-4e3b-b368-142d412a9ccc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1246fbbc-7dc6-423c-b9d6-a2405b080479&quot;,
      &quot;parentUUID&quot;: &quot;edf155e6-cd9b-4e3b-b368-142d412a9ccc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3e59c6cf-8b9d-430c-a165-6c8c6169cb4d&quot;,
      &quot;parentUUID&quot;: &quot;deb25722-4df7-4922-9822-9af2ef3b4113&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;22a7480d-91eb-44ff-b256-3d8890c00465&quot;,
      &quot;parentUUID&quot;: &quot;deb25722-4df7-4922-9822-9af2ef3b4113&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;//da definire&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0ebfabdd-cafb-4249-90b1-2b16eb281a51&quot;,
      &quot;parentUUID&quot;: &quot;deb25722-4df7-4922-9822-9af2ef3b4113&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeRule Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f1059ebf-1910-4f56-bf60-8b03b9805a30&quot;,
      &quot;parentUUID&quot;: &quot;b6aaee9e-fe16-4aac-aa77-6ef83cc0d682&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeRule Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b8420c32-526c-4419-9a8c-5f10064c8d72&quot;,
      &quot;parentUUID&quot;: &quot;b6aaee9e-fe16-4aac-aa77-6ef83cc0d682&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c15370c4-0d06-42e5-8381-d2bc56c6c6a7&quot;,
      &quot;parentUUID&quot;: &quot;fa881d42-af8e-4f5b-aa13-e813a8623c0f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9d296d35-abb4-4a98-8cc2-1e4d078f5ead&quot;,
      &quot;parentUUID&quot;: &quot;fa881d42-af8e-4f5b-aa13-e813a8623c0f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \&quot;\&quot;};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;98e3dd70-89ce-459f-acdc-641b7bb9c10d&quot;,
      &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3b3e0afa-b7be-46c6-aeeb-9a34d637a900&quot;,
      &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b57b4b04-5426-4250-95b2-f5f4b1da7e66&quot;,
      &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d0fe8168-7054-4d00-9a15-28d037ad92a6&quot;,
      &quot;parentUUID&quot;: &quot;f1733899-61a8-4336-a08b-695b063d9c92&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e762cf65-5242-4a88-820d-867e9f70a941&quot;,
      &quot;parentUUID&quot;: &quot;b2aa7e66-cdda-4625-87f8-ec110f9bf81c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;adfbf517-ef9e-4d3c-b3e3-a6a9cddd6154&quot;,
      &quot;parentUUID&quot;: &quot;b2aa7e66-cdda-4625-87f8-ec110f9bf81c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);\n};&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b6e6f97e-13c5-4fdc-90ab-cbf66d5dccfc&quot;,
      &quot;parentUUID&quot;: &quot;b2aa7e66-cdda-4625-87f8-ec110f9bf81c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c3e9053a-1c10-40b5-98bc-ffb89faf4b71&quot;,
      &quot;parentUUID&quot;: &quot;94738676-1a13-4e38-94c0-8e7d8b0c2463&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2438f097-3c80-4749-a83f-d3d0bb355fba&quot;,
      &quot;parentUUID&quot;: &quot;94738676-1a13-4e38-94c0-8e7d8b0c2463&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;653a4eca-a6b4-4eb7-aef5-508669e6d640&quot;,
      &quot;parentUUID&quot;: &quot;94738676-1a13-4e38-94c0-8e7d8b0c2463&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7219ab31-1903-4947-9eed-09f807fb27d3&quot;,
      &quot;parentUUID&quot;: &quot;8287b028-21b5-431e-b67a-4041c9c3e44d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a3b4feac-3e21-4c67-866a-65c6ea5bff97&quot;,
      &quot;parentUUID&quot;: &quot;8287b028-21b5-431e-b67a-4041c9c3e44d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c75cb0db-d9af-4c4b-998f-ac49afa95e4b&quot;,
      &quot;parentUUID&quot;: &quot;3c3c777c-2740-489e-84fd-284013434230&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a12a0138-eeeb-43e5-ab8c-189af276fd4e&quot;,
      &quot;parentUUID&quot;: &quot;3c3c777c-2740-489e-84fd-284013434230&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5e977a2c-c68a-4b31-be7d-bb983a9fc576&quot;,
      &quot;parentUUID&quot;: &quot;d4e83ef5-ca80-44bd-b820-4d08c7ba9249&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \&quot;\&quot; , body: \&quot;\&quot;};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fff7249c-ceab-498b-9e7e-a25a820882ef&quot;,
      &quot;parentUUID&quot;: &quot;d4e83ef5-ca80-44bd-b820-4d08c7ba9249&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fd82199a-105f-4c06-b1fc-b0f19ac4b324&quot;,
      &quot;parentUUID&quot;: &quot;d4e83ef5-ca80-44bd-b820-4d08c7ba9249&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
      &quot;fullTitle&quot;: &quot;speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;faf56f43-f076-4f33-aac3-2c3dbe23dfe7&quot;,
      &quot;parentUUID&quot;: &quot;13cd6e76-77c3-4acc-b934-55d12551993d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d6ba4de7-aca1-462a-bb7d-69ab63b9e260&quot;,
      &quot;parentUUID&quot;: &quot;5a594656-005d-44b1-928c-20b5b6343a63&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;08defae6-44e1-4b1c-afe8-1dff06b429d3&quot;,
      &quot;parentUUID&quot;: &quot;5a594656-005d-44b1-928c-20b5b6343a63&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getTask Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTask(&#x27;mock_type&#x27;).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a428e036-b2d4-49bf-ad4e-e2f7f9728912&quot;,
      &quot;parentUUID&quot;: &quot;f25873d1-00b0-4a8f-b334-ded563900812&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getTask Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = tasks.getTask(&#x27;mock_type&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3e7609b0-f517-4d26-87cb-ffbc7180ed15&quot;,
      &quot;parentUUID&quot;: &quot;f25873d1-00b0-4a8f-b334-ded563900812&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \&quot;mock_type3\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;02d9accf-3ca9-41b3-857d-4cd3eee98884&quot;,
      &quot;parentUUID&quot;: &quot;101cfe00-c24e-4229-922d-fbd255aa004e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;73ed2dc2-d926-40af-a3e3-842b60aa7fc7&quot;,
      &quot;parentUUID&quot;: &quot;101cfe00-c24e-4229-922d-fbd255aa004e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1848671c-66e6-44a0-acf2-d290cb6382f0&quot;,
      &quot;parentUUID&quot;: &quot;2ecf9916-8690-4db7-a3f9-11182b852491&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e4f51a84-7020-4a9e-a016-3272c933f00f&quot;,
      &quot;parentUUID&quot;: &quot;2ecf9916-8690-4db7-a3f9-11182b852491&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;454c1179-853e-45e7-bd25-9b034723f652&quot;,
      &quot;parentUUID&quot;: &quot;7a96f36c-94e0-491b-a0ff-ad0ce195e8b5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e235b321-4e3e-4769-aef8-1ca967a429a8&quot;,
      &quot;parentUUID&quot;: &quot;7a96f36c-94e0-491b-a0ff-ad0ce195e8b5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\&quot;Requested resource not found\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;af67856f-3de2-4c43-9202-6b33d74c330c&quot;,
      &quot;parentUUID&quot;: &quot;aeae1446-b11b-4b06-aea9-6ae51733d593&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fb039aa0-b2ea-42f5-9910-52b63ea77179&quot;,
      &quot;parentUUID&quot;: &quot;aeae1446-b11b-4b06-aea9-6ae51733d593&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ac50f261-0403-4af0-93ee-5426e49438cb&quot;,
      &quot;parentUUID&quot;: &quot;ff4ad3b8-0674-4085-8d0d-4132f11d6d31&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = users.getUser(&#x27;mou&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\n\t\t\t\t\texpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0a34898d-bac4-4add-badc-46683e904ce8&quot;,
      &quot;parentUUID&quot;: &quot;ff4ad3b8-0674-4085-8d0d-4132f11d6d31&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}], LastEvaluatedKey: &#x27;marco&#x27;});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;71bec860-59c0-468d-8f31-0096103a781f&quot;,
      &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;63228552-797c-4e0b-b0b4-db7be8027e24&quot;,
      &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;aa5fc92f-6517-4d10-a8db-bae03580113a&quot;,
      &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;,\n\tslack_channel: &#x27;channel&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name and slack_channel = :slack_channel&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:slack_channel&#x27;, &#x27;channel&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9d3b5690-b034-4b69-a0c3-e3f428632869&quot;,
      &quot;parentUUID&quot;: &quot;f3539935-4525-4e7b-a163-0eeae5866c1c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeUser Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \&quot;error removing user\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;58f8769f-fbbb-414b-a799-c445e069e88e&quot;,
      &quot;parentUUID&quot;: &quot;5ac8bd5a-9a5a-400d-bf11-fec8a903e77b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;removeUser Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e9622257-893d-4ddd-b674-b5963c613b76&quot;,
      &quot;parentUUID&quot;: &quot;5ac8bd5a-9a5a-400d-bf11-fec8a903e77b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \&quot;error updating user\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;91850804-7575-40b0-b670-2d4c4896d8b3&quot;,
      &quot;parentUUID&quot;: &quot;fdf1a4b7-c403-4d66-ae64-820fa14f3606&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1d0cc82f-3cc7-4b5b-a7fa-505821648875&quot;,
      &quot;parentUUID&quot;: &quot;fdf1a4b7-c403-4d66-ae64-820fa14f3606&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;089a912a-aecf-4485-9906-76f472715847&quot;,
      &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;63775100-ff4b-4ce0-8fd5-fc200ba95b0f&quot;,
      &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \&quot;\&quot; };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5771b81a-00a2-485e-abca-327039381dd4&quot;,
      &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;df221a75-311d-4738-801a-c49843bcf83e&quot;,
      &quot;parentUUID&quot;: &quot;9bcdfdfc-9d04-47c8-9956-49b4e3f58081&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d014fde5-db8e-4e5c-9fa7-f282afc46836&quot;,
      &quot;parentUUID&quot;: &quot;ed489e91-85fb-46c7-8342-e57c0743d069&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f498d75d-7b20-4cc4-884e-3d101a2099f1&quot;,
      &quot;parentUUID&quot;: &quot;ed489e91-85fb-46c7-8342-e57c0743d069&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { pathParameters: { username: &#x27;pippo&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;82a61ea1-4888-4efb-a864-2dedf3e33752&quot;,
      &quot;parentUUID&quot;: &quot;ed489e91-85fb-46c7-8342-e57c0743d069&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9f4940a2-7dd2-477a-9321-d608ac3e0bfa&quot;,
      &quot;parentUUID&quot;: &quot;e2986c45-3325-4cdf-9fb4-37e4a993cd46&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;84767ef0-2309-419a-88b5-7b10056164d8&quot;,
      &quot;parentUUID&quot;: &quot;e2986c45-3325-4cdf-9fb4-37e4a993cd46&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\n          let ev = { pathParameters: { username: &#x27;pippo&#x27;} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ac78051f-0dd2-4da0-ab3e-54e85ca14edc&quot;,
      &quot;parentUUID&quot;: &quot;e2986c45-3325-4cdf-9fb4-37e4a993cd46&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;67fe971b-f87b-4cc9-a541-9999e0423b86&quot;,
      &quot;parentUUID&quot;: &quot;26ec5209-e4c6-4ce1-82e8-d03d68d9c6d6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ users: [{ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cea9fc7d-40bb-434b-94bd-29c6cf0354c9&quot;,
      &quot;parentUUID&quot;: &quot;26ec5209-e4c6-4ce1-82e8-d03d68d9c6d6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9086399a-bda1-40ba-b05f-945023a0a52b&quot;,
      &quot;parentUUID&quot;: &quot;17d3f16f-1440-4e51-927c-e04805295041&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;080c9b1e-b60c-452d-93f7-b8f8564a5e2e&quot;,
      &quot;parentUUID&quot;: &quot;17d3f16f-1440-4e51-927c-e04805295041&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = { pathParameters: \&quot;\&quot;, body: \&quot;\&quot; };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8bfda398-f498-42da-a60f-62633084a0f5&quot;,
      &quot;parentUUID&quot;: &quot;17d3f16f-1440-4e51-927c-e04805295041&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;msg&#x27;: &#x27;error getting guest&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3c003d51-33fd-4b06-976f-072340d2b2e6&quot;,
      &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ &#x27;msg&#x27;: &#x27;error adding conversation&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;987b6a01-c708-4bcc-be5f-c895046d9c7b&quot;,
      &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;type&#x27;: &#x27;example&#x27; });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c69a5fbf-7258-4d9b-839b-f789885cb000&quot;,
      &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
      &quot;fullTitle&quot;: &quot;query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith(&#x27;test&#x27;));\n\tlet result = context.succeed.getCall(0).args[0];\n            expect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n            done();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2051a21b-4c35-4779-84e7-f13aa3ae1c2a&quot;,
      &quot;parentUUID&quot;: &quot;9ec9fb3d-1b49-4f6b-be7c-241a74a68141&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
      &quot;fullTitle&quot;: &quot;query Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.reject(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n            done();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1ea70980-80a4-4686-a80f-3ca41b31ca01&quot;,
      &quot;parentUUID&quot;: &quot;9ec9fb3d-1b49-4f6b-be7c-241a74a68141&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b60e4a82-00f8-46d8-abf4-6c086aa3b62b&quot;,
      &quot;parentUUID&quot;: &quot;8e09aa21-be16-4203-a2f9-698a7f9bda2f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cb35b38c-4874-4ddb-864c-1c606affc554&quot;,
      &quot;parentUUID&quot;: &quot;fb6484a0-e7ab-490f-967f-37d7bf3bb4be&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.addEnrollment.returns(Rx.Observable.throw(errore));\napi._addUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8d10e8fe-7ae8-4553-b722-1e948809daa8&quot;,
      &quot;parentUUID&quot;: &quot;8ac3a77d-a36f-486e-b032-d1f969a3dd78&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;de6241a9-9d63-4709-b6b2-1f0d8f49153b&quot;,
      &quot;parentUUID&quot;: &quot;66c308d0-9cc6-43ec-8a14-c5948f490a34&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cc94634f-a9f7-47b7-9598-bd85767c1241&quot;,
      &quot;parentUUID&quot;: &quot;d25fee7e-54b0-4cd6-8f50-39479e231437&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b2b7a2c8-d9a2-44e2-b12f-9f16e0a6af31&quot;,
      &quot;parentUUID&quot;: &quot;90cf3ec7-7575-40c6-8ac9-d78f19b49aeb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3364ab4a-aaf5-4631-910a-b040fb42a8af&quot;,
      &quot;parentUUID&quot;: &quot;c3b82a4c-84d7-43e3-a5e5-c06fe5a799ed&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
      &quot;fullTitle&quot;: &quot;_loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.doLogin.returns(Rx.Observable.throw(errore));\napi._loginUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0e93df58-d56c-409f-803a-35ad1dfc3bad&quot;,
      &quot;parentUUID&quot;: &quot;f98c281f-cbdd-4e0d-9547-931289b28203&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;// Manca il catch\nstt.speechToText.returns(Promise.reject(&#x27;Speech to Text Error&#x27;));\ncontext.succeed = function(response)\n{\n\texpect(response).have.property(&#x27;statusCode&#x27;, 500);\n\tdone();\n};\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0ead4d51-e553-4028-9634-ba401218908d&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se lo status della risposta ricevuta dall&#x27;assistente virtuale è diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio &#x27;Errore nel contattare l&#x27;assistente virtuale&#x27;.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se lo status della risposta ricevuta dall&#x27;assistente virtuale è diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio &#x27;Errore nel contattare l&#x27;assistente virtuale&#x27;.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;// Manca il catch\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.reject(errore_VA));\ncontext.succeed = function(response)\n{\n\texpect(response).to.have.deep.property(&#x27;statusCode&#x27;, errore_VA.statusCode);\n\tdone();\n};\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;72719ad5-527a-4333-b8ab-cb83dacfbd08&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 5,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ca4a9b0d-24bc-4e9d-866a-f9a0fd24267d&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e35861dc-5dea-4a5c-9ca4-6be524e51ca2&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b8c336c8-2872-4ecf-aa99-c30c8d16e10c&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2e8f7e23-eacb-441a-9810-a1cef03226fb&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8db79abb-48f9-44d1-bbde-80caed51b679&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;537037f6-244c-484c-8780-32e6c31df918&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUserList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUserList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUserList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUserList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9361af75-3f01-48dc-90d3-7b1395e2f748&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fc8e5f44-dec8-4a92-92e4-82797dbb5cb6&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;aacc9fda-ab84-49e5-8a2a-18a17c21778b&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d8288d8c-8249-4ab1-b318-ca1a24ccab55&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3bba97c1-b319-464f-827c-6580ce0d52e0&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0848e405-6181-4673-9580-19fcbe86f160&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;920da242-edd9-4775-8503-5b1705e4a85b&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          };\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;621f6014-47d4-46ac-b602-7022869028f6&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;dc26f1cd-0b40-4eb9-b96e-2130b6654260&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;49259128-fd49-4f28-8be2-029cdd2a9d7c&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b7e74616-c559-4f09-80bd-2d47b78b9139&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d7e135ae-4bda-4761-997c-33f35525fce3&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;05baabe1-047c-4dab-94a4-69c63d7ad32f&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4bd2ade0-14a4-4948-98c1-049b4b136f61&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;47095238-ed93-401e-afc1-f1b0efc07e79&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f012c1bc-f24f-454a-ad2a-1071b4350b67&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8a8671d5-6a40-4ed9-bc61-441b9458e77d&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;010f819c-071b-4f42-87a5-62c2eace4d6c&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a3060f88-b54d-4d40-bad9-7eb5b7f5077e&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7608b3f8-a644-47b2-b6eb-47aaf6a0f7c9&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari a 500.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;sns.publish.yields(&#x27;Errore&#x27;);\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n\t\t\t\t\tpromise.returns(Promise.resolve(empty_action_response));\ncontext.succeed = function(args)\n{\n  expect(args).to.have.deep.property(&#x27;statusCode&#x27;, 500);\n  done();\n}\napi.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3bd5fb95-bf60-4dca-99e2-7f93208b8051&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n\texpect(response).have.property(&#x27;statusCode&#x27;, 200);\n\tdone();\n};\napi.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;496d6e7f-8281-4c9c-954d-b798b385a91d&quot;,
      &quot;parentUUID&quot;: &quot;6bc7bbe9-9cba-435c-81b4-d5ab5bcfbcd4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;37e52dd5-12f1-47f2-bd1b-48e231369829&quot;,
      &quot;parentUUID&quot;: &quot;c5310ea9-5894-4fcd-9ffe-eaa881a773d6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;583e4f84-5b23-4d78-b169-fa3bb0921e7f&quot;,
      &quot;parentUUID&quot;: &quot;ee4448cc-babc-4a19-b605-907e49bc3d6d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.resetEnrollments.returns(Rx.Observable.throw(errore));\napi._resetUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;34a78f11-93d3-4a7b-afa3-86bd3a343b6b&quot;,
      &quot;parentUUID&quot;: &quot;afe55963-c3b0-4977-9865-7ba45e2f5912&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;95946469-aace-4e3d-b2e5-bcf64a6b0093&quot;,
      &quot;parentUUID&quot;: &quot;665bfc66-7676-4f29-8f6d-85b2f669c0a8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;56f762da-21cb-4578-9ee4-3abc5e29229f&quot;,
      &quot;parentUUID&quot;: &quot;4f4698b1-8840-4f28-bef3-cc901b03b576&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a76a2f2f-9d6b-4cbc-b8c9-2405a0914e1f&quot;,
      &quot;parentUUID&quot;: &quot;8173a7a6-f364-431f-a588-914ed868cf4f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7bdbe3eb-a5e9-42af-8ec9-d619eeb5e207&quot;,
      &quot;parentUUID&quot;: &quot;4418e6a0-b72e-4a4b-81d5-7cfaf855d5d6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f17ed45a-d244-42a5-bd08-f5a25a24334a&quot;,
      &quot;parentUUID&quot;: &quot;e8f26a91-4e52-4ec8-a3c9-e353376ae924&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject({ \&quot;result\&quot; : \&quot;Reject\&quot; }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;53ab4df3-2689-4621-a506-833e8b5dd81a&quot;,
      &quot;parentUUID&quot;: &quot;6d8c1f87-7a5e-4b8a-a163-7504c2c235df&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0dd2c718-4d78-4415-9be7-4e85213614a5&quot;,
      &quot;parentUUID&quot;: &quot;b09acee4-fe6f-4633-8b60-a1fce0c1ae76&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n  {\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8fda8b33-cb55-4a6b-9322-f3257e9b7de3&quot;,
      &quot;parentUUID&quot;: &quot;dd5b3c3e-9811-4d83-bd7f-32a07ceb1c84&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;resetEnrollments Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.resetEnrollments().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;63a59aa8-4778-4534-afc8-48021be8af20&quot;,
      &quot;parentUUID&quot;: &quot;ee856de5-34b4-4605-a44a-b9ec16877fa0&quot;,
      &quot;skipped&quot;: false
    }
  ],
  &quot;allFailures&quot;: [
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {request_event};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(&#x27;errore&#x27;);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: stub cannot yield since it was not yet invoked.\n  at Function.&lt;anonymous&gt; (node_modules\\sinon\\lib\\sinon\\spy.js:414:11)\n  at Function.spyApi.(anonymous function) (node_modules\\sinon\\lib\\sinon\\spy.js:361:34)\n  at Context.&lt;anonymous&gt; (src\\test\\test_NotificationService.js:89:35)\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2f29a161-60fb-4b3e-ad34-247098a6a5ae&quot;,
      &quot;parentUUID&quot;: &quot;2c206f5e-4ebe-485e-9347-381c69ff29d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {request_event};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: stub cannot yield since it was not yet invoked.\n  at Function.&lt;anonymous&gt; (node_modules\\sinon\\lib\\sinon\\spy.js:414:11)\n  at Function.spyApi.(anonymous function) (node_modules\\sinon\\lib\\sinon\\spy.js:361:34)\n  at Context.&lt;anonymous&gt; (src\\test\\test_NotificationService.js:101:35)\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2844f821-55eb-4d34-b908-b6d5917f4c9c&quot;,
      &quot;parentUUID&quot;: &quot;2c206f5e-4ebe-485e-9347-381c69ff29d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;TypeError: Cannot read property &#x27;channel&#x27; of undefined\n  at NotificationService.sendMsg (src\\Back-end\\Notifications\\NotificationService.js:175:39)\n  at Context.&lt;anonymous&gt; (src\\test\\test_NotificationService.js:112:14)\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3595d29e-ca2e-4a2c-a311-c3709da6be72&quot;,
      &quot;parentUUID&quot;: &quot;2c206f5e-4ebe-485e-9347-381c69ff29d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {
        &quot;name&quot;: &quot;AssertionError&quot;,
        &quot;message&quot;: &quot;expected 1 to be above 1&quot;,
        &quot;showDiff&quot;: false,
        &quot;actual&quot;: 1,
        &quot;estack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:54:36)\n&quot;,
        &quot;stack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:54:36)\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4a8e2960-e8a9-4180-a9f9-7ff28e5272c8&quot;,
      &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {
        &quot;name&quot;: &quot;AssertionError&quot;,
        &quot;message&quot;: &quot;expected 1 to be above 1&quot;,
        &quot;showDiff&quot;: false,
        &quot;actual&quot;: 1,
        &quot;estack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:67:36)\n&quot;,
        &quot;stack&quot;: &quot;AssertionError: expected 1 to be above 1\n  at Context.&lt;anonymous&gt; (src\\test\\test_VAMessageListener.js:67:36)\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fab7dbb3-a4d2-4ad6-9782-d344f42e70cb&quot;,
      &quot;parentUUID&quot;: &quot;1c0bf2e5-89d4-4cc4-9e3c-e0d369731327&quot;,
      &quot;skipped&quot;: false
    }
  ],
  &quot;copyrightYear&quot;: 2017
}" data-config="{&quot;reportDir&quot;:&quot;mochawesome-report&quot;,&quot;reportTitle&quot;:&quot;AtAVi&quot;,&quot;reportPageTitle&quot;:&quot;Mochawesome Report&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;charts&quot;:true,&quot;enableCharts&quot;:true,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;dev&quot;:false,&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;saveJson&quot;:true,&quot;jsonFile&quot;:&quot;H:\\src\\git\\AtAVi\\mochawesome-report\\mochawesome.json&quot;,&quot;htmlFile&quot;:&quot;H:\\src\\git\\AtAVi\\mochawesome-report\\mochawesome.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>