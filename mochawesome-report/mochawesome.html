<!doctype html>
<html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Mochawesome Report</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{
  &quot;stats&quot;: {
    &quot;suites&quot;: 136,
    &quot;tests&quot;: 181,
    &quot;passes&quot;: 176,
    &quot;pending&quot;: 0,
    &quot;failures&quot;: 5,
    &quot;start&quot;: &quot;2017-05-06T21:30:23.439Z&quot;,
    &quot;end&quot;: &quot;2017-05-06T21:30:34.231Z&quot;,
    &quot;duration&quot;: 10792,
    &quot;testsRegistered&quot;: 181,
    &quot;passPercent&quot;: 97.2,
    &quot;pendingPercent&quot;: 0,
    &quot;other&quot;: 0,
    &quot;hasOther&quot;: false,
    &quot;skipped&quot;: 0,
    &quot;hasSkipped&quot;: false,
    &quot;passPercentClass&quot;: &quot;success&quot;,
    &quot;pendingPercentClass&quot;: &quot;danger&quot;
  },
  &quot;suites&quot;: {
    &quot;title&quot;: &quot;&quot;,
    &quot;suites&quot;: [
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;AdministrationWebhookService&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;webhook&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
                    &quot;fullTitle&quot;: &quot;AdministrationWebhookService webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;failed&quot;,
                    &quot;pass&quot;: false,
                    &quot;fail&quot;: true,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});&quot;,
                    &quot;err&quot;: {
                      &quot;estack&quot;: &quot;TypeError: service.webhook is not a function\n  at Context.&lt;anonymous&gt; (src\\test\\test_AdministrationWebhookService.js:72:17)\n&quot;
                    },
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;2d5a2027-bd8a-4eea-b514-7611333dc194&quot;,
                    &quot;parentUUID&quot;: &quot;16aae3bd-d389-4ce8-be37-12bb842af39e&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
                    &quot;fullTitle&quot;: &quot;AdministrationWebhookService webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;failed&quot;,
                    &quot;pass&quot;: false,
                    &quot;fail&quot;: true,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});&quot;,
                    &quot;err&quot;: {
                      &quot;estack&quot;: &quot;TypeError: service.webhook is not a function\n  at Context.&lt;anonymous&gt; (src\\test\\test_AdministrationWebhookService.js:78:17)\n&quot;
                    },
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;47923f23-8044-4ac7-84a5-5aa854f730e5&quot;,
                    &quot;parentUUID&quot;: &quot;16aae3bd-d389-4ce8-be37-12bb842af39e&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_AdministrationWebhookService.js&quot;,
                &quot;uuid&quot;: &quot;16aae3bd-d389-4ce8-be37-12bb842af39e&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AdministrationWebhookService.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [
                  {
                    &quot;title&quot;: &quot;La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
                    &quot;fullTitle&quot;: &quot;AdministrationWebhookService webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;failed&quot;,
                    &quot;pass&quot;: false,
                    &quot;fail&quot;: true,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});&quot;,
                    &quot;err&quot;: {
                      &quot;estack&quot;: &quot;TypeError: service.webhook is not a function\n  at Context.&lt;anonymous&gt; (src\\test\\test_AdministrationWebhookService.js:72:17)\n&quot;
                    },
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;2d5a2027-bd8a-4eea-b514-7611333dc194&quot;,
                    &quot;parentUUID&quot;: &quot;16aae3bd-d389-4ce8-be37-12bb842af39e&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
                    &quot;fullTitle&quot;: &quot;AdministrationWebhookService webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;failed&quot;,
                    &quot;pass&quot;: false,
                    &quot;fail&quot;: true,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});&quot;,
                    &quot;err&quot;: {
                      &quot;estack&quot;: &quot;TypeError: service.webhook is not a function\n  at Context.&lt;anonymous&gt; (src\\test\\test_AdministrationWebhookService.js:78:17)\n&quot;
                    },
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;47923f23-8044-4ac7-84a5-5aa854f730e5&quot;,
                    &quot;parentUUID&quot;: &quot;16aae3bd-d389-4ce8-be37-12bb842af39e&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 2,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 2,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: true,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 1,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_AdministrationWebhookService.js&quot;,
            &quot;uuid&quot;: &quot;f4f24c71-0f19-4023-b456-b4c762416049&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AdministrationWebhookService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_AdministrationWebhookService.js&quot;,
        &quot;uuid&quot;: &quot;e906f7b2-628e-4f0c-b327-79ef39f70dbd&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AdministrationWebhookService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Agents&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;AgentsDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addAgent&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;323df3b3-ed51-4e2a-9304-88849a3d0e5b&quot;,
                        &quot;parentUUID&quot;: &quot;9594918e-0827-4c03-b74d-20002a26911a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;06edb568-7970-48b4-a45c-976077ef2d71&quot;,
                        &quot;parentUUID&quot;: &quot;9594918e-0827-4c03-b74d-20002a26911a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;9594918e-0827-4c03-b74d-20002a26911a&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;323df3b3-ed51-4e2a-9304-88849a3d0e5b&quot;,
                        &quot;parentUUID&quot;: &quot;9594918e-0827-4c03-b74d-20002a26911a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;06edb568-7970-48b4-a45c-976077ef2d71&quot;,
                        &quot;parentUUID&quot;: &quot;9594918e-0827-4c03-b74d-20002a26911a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 5,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getAgent&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgent Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7f19c384-de7b-4c99-abbf-36b6c8e8234d&quot;,
                        &quot;parentUUID&quot;: &quot;3a926ecc-ddc9-4e67-aedb-76dda206b610&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgent Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = agents.getAgent(&#x27;mock_name&#x27;);\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a9f94659-f673-41e2-8a02-a82ddcf1ed14&quot;,
                        &quot;parentUUID&quot;: &quot;3a926ecc-ddc9-4e67-aedb-76dda206b610&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;3a926ecc-ddc9-4e67-aedb-76dda206b610&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgent Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7f19c384-de7b-4c99-abbf-36b6c8e8234d&quot;,
                        &quot;parentUUID&quot;: &quot;3a926ecc-ddc9-4e67-aedb-76dda206b610&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgent Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = agents.getAgent(&#x27;mock_name&#x27;);\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a9f94659-f673-41e2-8a02-a82ddcf1ed14&quot;,
                        &quot;parentUUID&quot;: &quot;3a926ecc-ddc9-4e67-aedb-76dda206b610&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getAgentList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;2&#x27;});\ndynamo_client.scan.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4d1d717f-fcbe-478e-a381-5b53601ada0b&quot;,
                        &quot;parentUUID&quot;: &quot;96e4d162-f61e-4af5-8cd6-f83f663798d0&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgentList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e08ca80c-2ca7-47d1-b513-6971eabf39b7&quot;,
                        &quot;parentUUID&quot;: &quot;96e4d162-f61e-4af5-8cd6-f83f663798d0&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;96e4d162-f61e-4af5-8cd6-f83f663798d0&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;2&#x27;});\ndynamo_client.scan.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4d1d717f-fcbe-478e-a381-5b53601ada0b&quot;,
                        &quot;parentUUID&quot;: &quot;96e4d162-f61e-4af5-8cd6-f83f663798d0&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgentList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e08ca80c-2ca7-47d1-b513-6971eabf39b7&quot;,
                        &quot;parentUUID&quot;: &quot;96e4d162-f61e-4af5-8cd6-f83f663798d0&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 5,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeAgent&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB removeAgent Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\&quot;error removing rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d298e2be-44aa-4561-aca8-d83922a6ef69&quot;,
                        &quot;parentUUID&quot;: &quot;ced7a107-e669-44c0-9209-fecc09ded95d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB removeAgent Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\&quot;success\&quot;});\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;92dabb8f-ebe5-4e8d-852c-a00784491d2e&quot;,
                        &quot;parentUUID&quot;: &quot;ced7a107-e669-44c0-9209-fecc09ded95d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;ced7a107-e669-44c0-9209-fecc09ded95d&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB removeAgent Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\&quot;error removing rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d298e2be-44aa-4561-aca8-d83922a6ef69&quot;,
                        &quot;parentUUID&quot;: &quot;ced7a107-e669-44c0-9209-fecc09ded95d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB removeAgent Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\&quot;success\&quot;});\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;92dabb8f-ebe5-4e8d-852c-a00784491d2e&quot;,
                        &quot;parentUUID&quot;: &quot;ced7a107-e669-44c0-9209-fecc09ded95d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateAgent&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB updateAgent Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 5,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ef631d93-7562-4059-94e4-4388897b154d&quot;,
                        &quot;parentUUID&quot;: &quot;e0d8e836-0862-4359-9b37-851ca825eb03&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB updateAgent Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c7b7d4c3-fefb-47df-95ef-58007d409a92&quot;,
                        &quot;parentUUID&quot;: &quot;e0d8e836-0862-4359-9b37-851ca825eb03&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;e0d8e836-0862-4359-9b37-851ca825eb03&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB updateAgent Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 5,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ef631d93-7562-4059-94e4-4388897b154d&quot;,
                        &quot;parentUUID&quot;: &quot;e0d8e836-0862-4359-9b37-851ca825eb03&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB updateAgent Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c7b7d4c3-fefb-47df-95ef-58007d409a92&quot;,
                        &quot;parentUUID&quot;: &quot;e0d8e836-0862-4359-9b37-851ca825eb03&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 6,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;fa933d45-272e-41db-9841-c773929d0d3f&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;86051ac0-00d6-4913-b99d-4bef7ab6bebf&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;4a8a2ce9-6dbc-4ad4-8ab2-e595db14646f&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;VirtualAssistant&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;ApiAiVAAdapter&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;query&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
                        &quot;fullTitle&quot;: &quot;ApiAiVAAdapter query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;29b5ccf9-c97a-42bb-8779-81157c19139a&quot;,
                        &quot;parentUUID&quot;: &quot;802aa6cf-a946-4742-aa12-eb6b596c6a8c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
                        &quot;fullTitle&quot;: &quot;ApiAiVAAdapter query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3e358c25-16ae-48bd-a1a0-b66dc7bd35ee&quot;,
                        &quot;parentUUID&quot;: &quot;802aa6cf-a946-4742-aa12-eb6b596c6a8c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ApiAiVAAdapter.js&quot;,
                    &quot;uuid&quot;: &quot;802aa6cf-a946-4742-aa12-eb6b596c6a8c&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
                        &quot;fullTitle&quot;: &quot;ApiAiVAAdapter query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;29b5ccf9-c97a-42bb-8779-81157c19139a&quot;,
                        &quot;parentUUID&quot;: &quot;802aa6cf-a946-4742-aa12-eb6b596c6a8c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
                        &quot;fullTitle&quot;: &quot;ApiAiVAAdapter query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3e358c25-16ae-48bd-a1a0-b66dc7bd35ee&quot;,
                        &quot;parentUUID&quot;: &quot;802aa6cf-a946-4742-aa12-eb6b596c6a8c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 6,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ApiAiVAAdapter.js&quot;,
                &quot;uuid&quot;: &quot;32019915-d1cf-4495-87a0-895c1b46e8de&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ApiAiVAAdapter.js&quot;,
            &quot;uuid&quot;: &quot;49aaaf08-962c-436f-bb6c-35cf91cc3051&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ApiAiVAAdapter.js&quot;,
        &quot;uuid&quot;: &quot;14e3898d-c506-44de-88ce-c4bc617f7ddf&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Conversations&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;ConversationsDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addConversation&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \&quot;Requested resource not found\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5668bdfd-c977-4457-8117-551210a0aeac&quot;,
                        &quot;parentUUID&quot;: &quot;6559be4c-fb2f-467f-a445-405ec898518e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7a38e270-a340-4edf-9fa6-9f62384fce9c&quot;,
                        &quot;parentUUID&quot;: &quot;6559be4c-fb2f-467f-a445-405ec898518e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;6559be4c-fb2f-467f-a445-405ec898518e&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \&quot;Requested resource not found\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5668bdfd-c977-4457-8117-551210a0aeac&quot;,
                        &quot;parentUUID&quot;: &quot;6559be4c-fb2f-467f-a445-405ec898518e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7a38e270-a340-4edf-9fa6-9f62384fce9c&quot;,
                        &quot;parentUUID&quot;: &quot;6559be4c-fb2f-467f-a445-405ec898518e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;addMessage&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \&quot;error adding message\&quot; });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;368ca2cb-2c11-46ce-914b-22278d5221c2&quot;,
                        &quot;parentUUID&quot;: &quot;fda16baa-e7db-45f3-b5d5-1e0b0e6e3cc6&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;bc373be5-705e-46cc-8c7a-b0409ac0dac0&quot;,
                        &quot;parentUUID&quot;: &quot;fda16baa-e7db-45f3-b5d5-1e0b0e6e3cc6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;fda16baa-e7db-45f3-b5d5-1e0b0e6e3cc6&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \&quot;error adding message\&quot; });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;368ca2cb-2c11-46ce-914b-22278d5221c2&quot;,
                        &quot;parentUUID&quot;: &quot;fda16baa-e7db-45f3-b5d5-1e0b0e6e3cc6&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;bc373be5-705e-46cc-8c7a-b0409ac0dac0&quot;,
                        &quot;parentUUID&quot;: &quot;fda16baa-e7db-45f3-b5d5-1e0b0e6e3cc6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getConversation&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \&quot;error downloading conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4f3caf75-bc54-4edc-9b6f-8ff2f19cd364&quot;,
                        &quot;parentUUID&quot;: &quot;d7852712-1502-476b-a089-e33ffd23803a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversation Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;157cb40b-76b0-4ffa-914e-2a4561400385&quot;,
                        &quot;parentUUID&quot;: &quot;d7852712-1502-476b-a089-e33ffd23803a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;d7852712-1502-476b-a089-e33ffd23803a&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \&quot;error downloading conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4f3caf75-bc54-4edc-9b6f-8ff2f19cd364&quot;,
                        &quot;parentUUID&quot;: &quot;d7852712-1502-476b-a089-e33ffd23803a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversation Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;157cb40b-76b0-4ffa-914e-2a4561400385&quot;,
                        &quot;parentUUID&quot;: &quot;d7852712-1502-476b-a089-e33ffd23803a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getConversationList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;deaca613-014c-4192-b897-34fe8a71ecbe&quot;,
                        &quot;parentUUID&quot;: &quot;62d98a05-f03c-45e4-8e33-77916f9a4cdf&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversationList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5b128857-9589-48f7-9090-1d3446fa8623&quot;,
                        &quot;parentUUID&quot;: &quot;62d98a05-f03c-45e4-8e33-77916f9a4cdf&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;62d98a05-f03c-45e4-8e33-77916f9a4cdf&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;deaca613-014c-4192-b897-34fe8a71ecbe&quot;,
                        &quot;parentUUID&quot;: &quot;62d98a05-f03c-45e4-8e33-77916f9a4cdf&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversationList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5b128857-9589-48f7-9090-1d3446fa8623&quot;,
                        &quot;parentUUID&quot;: &quot;62d98a05-f03c-45e4-8e33-77916f9a4cdf&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeConversation&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6edf9515-761a-4cbd-bfd6-48de37ad0e83&quot;,
                        &quot;parentUUID&quot;: &quot;c55533c5-9c61-45c9-a569-b29fef9e08e4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c352c821-931d-42fa-b5d3-2b541cf09beb&quot;,
                        &quot;parentUUID&quot;: &quot;c55533c5-9c61-45c9-a569-b29fef9e08e4&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;c55533c5-9c61-45c9-a569-b29fef9e08e4&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6edf9515-761a-4cbd-bfd6-48de37ad0e83&quot;,
                        &quot;parentUUID&quot;: &quot;c55533c5-9c61-45c9-a569-b29fef9e08e4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c352c821-931d-42fa-b5d3-2b541cf09beb&quot;,
                        &quot;parentUUID&quot;: &quot;c55533c5-9c61-45c9-a569-b29fef9e08e4&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;8be2469f-ba01-40e5-9c3f-ef32f22872bf&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;6228ace7-29e5-40b2-b7dc-2de368305742&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;14d18328-f1b0-404f-93d9-a2d23cd838f6&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;ConversationWebhookService&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;webhook&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
                    &quot;fullTitle&quot;: &quot;ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 7,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;body.result.action = &#x27;user.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;admin&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;809d7d6d-f37c-4b0e-bae0-e2254b96a1ea&quot;,
                    &quot;parentUUID&quot;: &quot;739deb20-8b18-4cdb-8a8d-9ddb1f047c3b&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
                    &quot;fullTitle&quot;: &quot;ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;body.result.action = &#x27;guest.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;, company : \&quot;Google\&quot;}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;welcome&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;5a70baa2-af0b-4740-809d-fcdac967b827&quot;,
                    &quot;parentUUID&quot;: &quot;739deb20-8b18-4cdb-8a8d-9ddb1f047c3b&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ConversationWebhookService.js&quot;,
                &quot;uuid&quot;: &quot;739deb20-8b18-4cdb-8a8d-9ddb1f047c3b&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationWebhookService.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
                    &quot;fullTitle&quot;: &quot;ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 7,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;body.result.action = &#x27;user.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;admin&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;809d7d6d-f37c-4b0e-bae0-e2254b96a1ea&quot;,
                    &quot;parentUUID&quot;: &quot;739deb20-8b18-4cdb-8a8d-9ddb1f047c3b&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
                    &quot;fullTitle&quot;: &quot;ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;body.result.action = &#x27;guest.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;, company : \&quot;Google\&quot;}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;welcome&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;5a70baa2-af0b-4740-809d-fcdac967b827&quot;,
                    &quot;parentUUID&quot;: &quot;739deb20-8b18-4cdb-8a8d-9ddb1f047c3b&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 2,
                &quot;totalPasses&quot;: 2,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 10,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ConversationWebhookService.js&quot;,
            &quot;uuid&quot;: &quot;263e9fc1-0a95-4033-8628-3030bae55ad6&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationWebhookService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ConversationWebhookService.js&quot;,
        &quot;uuid&quot;: &quot;3d36b30f-9dac-47f2-8cff-4453d7d31240&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationWebhookService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Libs&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;ErrorObserver&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;next&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ErrorObserver next Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;expect(obs.next.bind(obs)).to.throw();&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;cc60460d-6efe-4cc6-a304-41eab39865e1&quot;,
                    &quot;parentUUID&quot;: &quot;b312ec6d-2e5f-4bd2-a195-33ee58376e0b&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ErrorObserver.js&quot;,
                &quot;uuid&quot;: &quot;b312ec6d-2e5f-4bd2-a195-33ee58376e0b&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ErrorObserver.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ErrorObserver next Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;expect(obs.next.bind(obs)).to.throw();&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;cc60460d-6efe-4cc6-a304-41eab39865e1&quot;,
                    &quot;parentUUID&quot;: &quot;b312ec6d-2e5f-4bd2-a195-33ee58376e0b&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 1,
                &quot;totalPasses&quot;: 1,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 1,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ErrorObserver.js&quot;,
            &quot;uuid&quot;: &quot;621e956a-8c84-43e8-8a29-d29bdb4176d4&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ErrorObserver.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ErrorObserver.js&quot;,
        &quot;uuid&quot;: &quot;d0a438a5-b3d3-4a8f-9778-37f75ba1d8e9&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ErrorObserver.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Guests&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;GuestsDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addGuest&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;753dbb52-26d3-4f90-b1f6-70561c4a8a3b&quot;,
                        &quot;parentUUID&quot;: &quot;0278ab44-e86f-4644-8549-af97c2e6a21e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addGuest Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addGuest(&#x27;mauro&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8c5fba9d-c2c2-463b-92dc-3ec00fcbb05a&quot;,
                        &quot;parentUUID&quot;: &quot;0278ab44-e86f-4644-8549-af97c2e6a21e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;0278ab44-e86f-4644-8549-af97c2e6a21e&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;753dbb52-26d3-4f90-b1f6-70561c4a8a3b&quot;,
                        &quot;parentUUID&quot;: &quot;0278ab44-e86f-4644-8549-af97c2e6a21e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addGuest Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addGuest(&#x27;mauro&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8c5fba9d-c2c2-463b-92dc-3ec00fcbb05a&quot;,
                        &quot;parentUUID&quot;: &quot;0278ab44-e86f-4644-8549-af97c2e6a21e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getGuest&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \&quot;error getting data\&quot; });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b262d94a-d279-4046-9e36-43a0a6ecb5a8&quot;,
                        &quot;parentUUID&quot;: &quot;c1c6188c-beb0-4712-a42f-e5a6e951d9d0&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuest Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \&quot;Mauro\&quot;);\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\&quot;Zero12\&quot;);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;60c965d0-1766-48ef-bb55-6f004ab99351&quot;,
                        &quot;parentUUID&quot;: &quot;c1c6188c-beb0-4712-a42f-e5a6e951d9d0&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;c1c6188c-beb0-4712-a42f-e5a6e951d9d0&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \&quot;error getting data\&quot; });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b262d94a-d279-4046-9e36-43a0a6ecb5a8&quot;,
                        &quot;parentUUID&quot;: &quot;c1c6188c-beb0-4712-a42f-e5a6e951d9d0&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuest Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \&quot;Mauro\&quot;);\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\&quot;Zero12\&quot;);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;60c965d0-1766-48ef-bb55-6f004ab99351&quot;,
                        &quot;parentUUID&quot;: &quot;c1c6188c-beb0-4712-a42f-e5a6e951d9d0&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getGuestList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }], LastEvaluatedKey: &#x27;Luca&#x27;});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8776d3d8-1043-42f1-8b31-5b814cd33129&quot;,
                        &quot;parentUUID&quot;: &quot;0eccf4f9-5b92-4dec-acfb-11ea3cbfef31&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuestList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1fef49e6-822a-42d7-b42b-8826debe5cf0&quot;,
                        &quot;parentUUID&quot;: &quot;0eccf4f9-5b92-4dec-acfb-11ea3cbfef31&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;0eccf4f9-5b92-4dec-acfb-11ea3cbfef31&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }], LastEvaluatedKey: &#x27;Luca&#x27;});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8776d3d8-1043-42f1-8b31-5b814cd33129&quot;,
                        &quot;parentUUID&quot;: &quot;0eccf4f9-5b92-4dec-acfb-11ea3cbfef31&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuestList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1fef49e6-822a-42d7-b42b-8826debe5cf0&quot;,
                        &quot;parentUUID&quot;: &quot;0eccf4f9-5b92-4dec-acfb-11ea3cbfef31&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeGuest&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing guest\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8d25fdf0-1be4-4750-ac84-15b3e8ba4888&quot;,
                        &quot;parentUUID&quot;: &quot;9f7bec2a-b42d-425b-bb2f-a1fb2021a9fc&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB removeGuest Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e86c864f-323d-451d-9ad0-047bd5ce7dda&quot;,
                        &quot;parentUUID&quot;: &quot;9f7bec2a-b42d-425b-bb2f-a1fb2021a9fc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;9f7bec2a-b42d-425b-bb2f-a1fb2021a9fc&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing guest\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8d25fdf0-1be4-4750-ac84-15b3e8ba4888&quot;,
                        &quot;parentUUID&quot;: &quot;9f7bec2a-b42d-425b-bb2f-a1fb2021a9fc&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB removeGuest Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e86c864f-323d-451d-9ad0-047bd5ce7dda&quot;,
                        &quot;parentUUID&quot;: &quot;9f7bec2a-b42d-425b-bb2f-a1fb2021a9fc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateGuest&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating guest\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3371d654-5c3b-42d2-a4ab-537d8da7f4c3&quot;,
                        &quot;parentUUID&quot;: &quot;075a1914-526b-4c1e-b946-ac9bc2bfbcb1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6670ef9b-b7da-4ea5-bd1c-3ef6f8f68588&quot;,
                        &quot;parentUUID&quot;: &quot;075a1914-526b-4c1e-b946-ac9bc2bfbcb1&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;075a1914-526b-4c1e-b946-ac9bc2bfbcb1&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating guest\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3371d654-5c3b-42d2-a4ab-537d8da7f4c3&quot;,
                        &quot;parentUUID&quot;: &quot;075a1914-526b-4c1e-b946-ac9bc2bfbcb1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6670ef9b-b7da-4ea5-bd1c-3ef6f8f68588&quot;,
                        &quot;parentUUID&quot;: &quot;075a1914-526b-4c1e-b946-ac9bc2bfbcb1&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;addConversation&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addConversation Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;544e1ed9-7c43-41ee-963c-c821171d7fc7&quot;,
                        &quot;parentUUID&quot;: &quot;aaa121bd-0faf-4ccd-857d-acabe82fb00d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addConversation Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;580adbdf-8ace-47a3-ab2d-40cff2ba6a99&quot;,
                        &quot;parentUUID&quot;: &quot;aaa121bd-0faf-4ccd-857d-acabe82fb00d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;aaa121bd-0faf-4ccd-857d-acabe82fb00d&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addConversation Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;544e1ed9-7c43-41ee-963c-c821171d7fc7&quot;,
                        &quot;parentUUID&quot;: &quot;aaa121bd-0faf-4ccd-857d-acabe82fb00d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addConversation Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;580adbdf-8ace-47a3-ab2d-40cff2ba6a99&quot;,
                        &quot;parentUUID&quot;: &quot;aaa121bd-0faf-4ccd-857d-acabe82fb00d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;39717cde-829c-458c-b547-37992d0b97ab&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;86f38473-4d6f-484b-a668-92b809931e79&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;94ea4d45-9304-42e3-a467-4742a54668c8&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Members&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;MembersDAOSlack&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addMember&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack addMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.addMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;67b8b705-9b39-436d-876d-fc1258636321&quot;,
                        &quot;parentUUID&quot;: &quot;9620d65a-bd4b-4e12-ba9f-cf08728b82cf&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;9620d65a-bd4b-4e12-ba9f-cf08728b82cf&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack addMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.addMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;67b8b705-9b39-436d-876d-fc1258636321&quot;,
                        &quot;parentUUID&quot;: &quot;9620d65a-bd4b-4e12-ba9f-cf08728b82cf&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getMember&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMember Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t&#x27;ok&#x27;: true,\n\t&#x27;user&#x27;:\n\t{\n\t\t&#x27;id&#x27;: &#x27;U023BECGF&#x27;,\n\t\t&#x27;name&#x27;: &#x27;bobby&#x27;,\n\t\t&#x27;deleted&#x27;: false,\n\t\t&#x27;color&#x27;: &#x27;9f69e7&#x27;,\n\t\t&#x27;profile&#x27;:\n\t\t{\n\t\t\t&#x27;avatar_hash&#x27;: &#x27;ge3b51ca72de&#x27;,\n\t\t\t&#x27;current_status&#x27;: &#x27;:mountain_railway: riding a train&#x27;,\n\t\t\t&#x27;first_name&#x27;: &#x27;Bobby&#x27;,\n\t\t\t&#x27;last_name&#x27;: &#x27;Tables&#x27;,\n\t\t\t&#x27;real_name&#x27;: &#x27;Bobby Tables&#x27;,\n\t\t\t&#x27;email&#x27;: &#x27;bobby@slack.com&#x27;,\n\t\t\t&#x27;skype&#x27;: &#x27;my-skype-name&#x27;,\n\t\t\t&#x27;phone&#x27;: &#x27;+1 (123) 456 7890&#x27;\n\t\t},\n\t\t&#x27;is_admin&#x27;: true,\n\t\t&#x27;is_owner&#x27;: true,\n\t\t&#x27;updated&#x27;: 1490054400,\n\t\t&#x27;has_2fa&#x27;: true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;375c8d11-bc06-4ac8-8244-21c9fbfc83c3&quot;,
                        &quot;parentUUID&quot;: &quot;13b7d5d4-e1cc-4c51-8bc1-c7c42a6cf4ef&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMember Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1fad7301-530a-4f1b-aee9-2f7a7858bd77&quot;,
                        &quot;parentUUID&quot;: &quot;13b7d5d4-e1cc-4c51-8bc1-c7c42a6cf4ef&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;13b7d5d4-e1cc-4c51-8bc1-c7c42a6cf4ef&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMember Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t&#x27;ok&#x27;: true,\n\t&#x27;user&#x27;:\n\t{\n\t\t&#x27;id&#x27;: &#x27;U023BECGF&#x27;,\n\t\t&#x27;name&#x27;: &#x27;bobby&#x27;,\n\t\t&#x27;deleted&#x27;: false,\n\t\t&#x27;color&#x27;: &#x27;9f69e7&#x27;,\n\t\t&#x27;profile&#x27;:\n\t\t{\n\t\t\t&#x27;avatar_hash&#x27;: &#x27;ge3b51ca72de&#x27;,\n\t\t\t&#x27;current_status&#x27;: &#x27;:mountain_railway: riding a train&#x27;,\n\t\t\t&#x27;first_name&#x27;: &#x27;Bobby&#x27;,\n\t\t\t&#x27;last_name&#x27;: &#x27;Tables&#x27;,\n\t\t\t&#x27;real_name&#x27;: &#x27;Bobby Tables&#x27;,\n\t\t\t&#x27;email&#x27;: &#x27;bobby@slack.com&#x27;,\n\t\t\t&#x27;skype&#x27;: &#x27;my-skype-name&#x27;,\n\t\t\t&#x27;phone&#x27;: &#x27;+1 (123) 456 7890&#x27;\n\t\t},\n\t\t&#x27;is_admin&#x27;: true,\n\t\t&#x27;is_owner&#x27;: true,\n\t\t&#x27;updated&#x27;: 1490054400,\n\t\t&#x27;has_2fa&#x27;: true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;375c8d11-bc06-4ac8-8244-21c9fbfc83c3&quot;,
                        &quot;parentUUID&quot;: &quot;13b7d5d4-e1cc-4c51-8bc1-c7c42a6cf4ef&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMember Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1fad7301-530a-4f1b-aee9-2f7a7858bd77&quot;,
                        &quot;parentUUID&quot;: &quot;13b7d5d4-e1cc-4c51-8bc1-c7c42a6cf4ef&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getMemberList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMemberList L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\&quot;ok\&quot;: true,\n\t\&quot;members\&quot;:\n\t[\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECGF\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;mauro\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Mauro Bocciofilo\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t},\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECLL\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;bobby\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;,\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6a4197ec-c29f-4653-982b-2731b5650a78&quot;,
                        &quot;parentUUID&quot;: &quot;632e1d25-798f-496d-904a-16c4abd01939&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMemberList Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f535844e-2430-47fc-b33d-d47b15b1b096&quot;,
                        &quot;parentUUID&quot;: &quot;632e1d25-798f-496d-904a-16c4abd01939&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;632e1d25-798f-496d-904a-16c4abd01939&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMemberList L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\&quot;ok\&quot;: true,\n\t\&quot;members\&quot;:\n\t[\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECGF\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;mauro\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Mauro Bocciofilo\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t},\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECLL\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;bobby\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;,\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6a4197ec-c29f-4653-982b-2731b5650a78&quot;,
                        &quot;parentUUID&quot;: &quot;632e1d25-798f-496d-904a-16c4abd01939&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMemberList Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f535844e-2430-47fc-b33d-d47b15b1b096&quot;,
                        &quot;parentUUID&quot;: &quot;632e1d25-798f-496d-904a-16c4abd01939&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeMember&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack removeMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.removeMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b3e3371d-9288-4bdd-8dd7-4592988c5cbb&quot;,
                        &quot;parentUUID&quot;: &quot;262f348a-b96e-47bf-b040-a54baf6a0849&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;262f348a-b96e-47bf-b040-a54baf6a0849&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack removeMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.removeMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b3e3371d-9288-4bdd-8dd7-4592988c5cbb&quot;,
                        &quot;parentUUID&quot;: &quot;262f348a-b96e-47bf-b040-a54baf6a0849&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateMember&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack updateMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.updateMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;63451431-bb02-4a30-8895-0fd1a19a8473&quot;,
                        &quot;parentUUID&quot;: &quot;172fd663-3c3c-4e85-9e46-26a3184907bc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;172fd663-3c3c-4e85-9e46-26a3184907bc&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack updateMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.updateMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;63451431-bb02-4a30-8895-0fd1a19a8473&quot;,
                        &quot;parentUUID&quot;: &quot;172fd663-3c3c-4e85-9e46-26a3184907bc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                &quot;uuid&quot;: &quot;4aa2265b-10c2-4792-a6c4-82014652f5a4&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
            &quot;uuid&quot;: &quot;41575b5f-d7da-4a30-a008-abdbfdb5b772&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
        &quot;uuid&quot;: &quot;ae3a23ca-6379-4dda-8426-a0a080b08bfa&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Notifications&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;NotificationService&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;getChannelList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(&#x27;errore&#x27;);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n  done();\n}&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;193b13c0-c7fb-4e69-889f-940987b019db&quot;,
                        &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields(&#x27;errore&#x27;);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2156a6ac-1c2b-4366-ba8e-418bcff81951&quot;,
                        &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(&#x27;errore&#x27;);\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d8c15434-9efe-4724-a587-716172c2bfa7&quot;,
                        &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 200);\n  done();\n}&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7342ee25-ef4a-44f6-9843-7b66f537919d&quot;,
                        &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
                    &quot;uuid&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(&#x27;errore&#x27;);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n  done();\n}&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;193b13c0-c7fb-4e69-889f-940987b019db&quot;,
                        &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields(&#x27;errore&#x27;);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2156a6ac-1c2b-4366-ba8e-418bcff81951&quot;,
                        &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(&#x27;errore&#x27;);\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d8c15434-9efe-4724-a587-716172c2bfa7&quot;,
                        &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 200);\n  done();\n}&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7342ee25-ef4a-44f6-9843-7b66f537919d&quot;,
                        &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 4,
                    &quot;totalPasses&quot;: 4,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 6,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;sendMsg&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(&#x27;errore&#x27;);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ae0ceb3d-f4da-4b11-ba0d-aa27a37595c1&quot;,
                        &quot;parentUUID&quot;: &quot;b82d5dc7-3536-4ab6-9f33-73fdef730387&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;766cab3f-44ee-47b9-a7ec-306059516b65&quot;,
                        &quot;parentUUID&quot;: &quot;b82d5dc7-3536-4ab6-9f33-73fdef730387&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\n\nexpect(context.succeed.callCount).to.equal(1);\t\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cdcf8f35-5178-4b82-9894-0b963eca8740&quot;,
                        &quot;parentUUID&quot;: &quot;b82d5dc7-3536-4ab6-9f33-73fdef730387&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
                    &quot;uuid&quot;: &quot;b82d5dc7-3536-4ab6-9f33-73fdef730387&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(&#x27;errore&#x27;);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ae0ceb3d-f4da-4b11-ba0d-aa27a37595c1&quot;,
                        &quot;parentUUID&quot;: &quot;b82d5dc7-3536-4ab6-9f33-73fdef730387&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;766cab3f-44ee-47b9-a7ec-306059516b65&quot;,
                        &quot;parentUUID&quot;: &quot;b82d5dc7-3536-4ab6-9f33-73fdef730387&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\n\nexpect(context.succeed.callCount).to.equal(1);\t\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cdcf8f35-5178-4b82-9894-0b963eca8740&quot;,
                        &quot;parentUUID&quot;: &quot;b82d5dc7-3536-4ab6-9f33-73fdef730387&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
                &quot;uuid&quot;: &quot;01e6427e-ec3f-45c9-87ba-2136c5aac102&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
            &quot;uuid&quot;: &quot;527826dd-f6fd-4f8f-8abf-1d0470133bf4&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
        &quot;uuid&quot;: &quot;3dfa8af5-512e-4982-9915-661e27803867&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Libs&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;ObserverAdapter&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;complete&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare complete_cb&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Deve chiamare complete_cb&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \&quot;il callback di complete non è stato chiamato esattamente una volta.\&quot;).to.equal(1);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;164b4e50-d696-451e-860c-72375fd7a329&quot;,
                    &quot;parentUUID&quot;: &quot;71a63949-b02a-45da-9d82-bb3cdae43e28&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;b4de0c6d-5cf4-4313-993b-3189d5ec1724&quot;,
                    &quot;parentUUID&quot;: &quot;71a63949-b02a-45da-9d82-bb3cdae43e28&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;f48a24c6-305f-45a2-a75f-1bbd55fc4a41&quot;,
                    &quot;parentUUID&quot;: &quot;71a63949-b02a-45da-9d82-bb3cdae43e28&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;uuid&quot;: &quot;71a63949-b02a-45da-9d82-bb3cdae43e28&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare complete_cb&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Deve chiamare complete_cb&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \&quot;il callback di complete non è stato chiamato esattamente una volta.\&quot;).to.equal(1);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;164b4e50-d696-451e-860c-72375fd7a329&quot;,
                    &quot;parentUUID&quot;: &quot;71a63949-b02a-45da-9d82-bb3cdae43e28&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;b4de0c6d-5cf4-4313-993b-3189d5ec1724&quot;,
                    &quot;parentUUID&quot;: &quot;71a63949-b02a-45da-9d82-bb3cdae43e28&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;f48a24c6-305f-45a2-a75f-1bbd55fc4a41&quot;,
                    &quot;parentUUID&quot;: &quot;71a63949-b02a-45da-9d82-bb3cdae43e28&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 3,
                &quot;totalPasses&quot;: 3,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              },
              {
                &quot;title&quot;: &quot;error&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare error_cb&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Deve chiamare error_cb&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;da3569fc-a24e-441b-a2f4-8829e6eec349&quot;,
                    &quot;parentUUID&quot;: &quot;204d1bdd-22c0-4850-94ab-0c82770bd4b4&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onError(success);\nobs.pause();\nobs.error(&#x27;errore&#x27;);\n        expect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;65e1072f-f459-42dc-8f7c-9db51ff6fc20&quot;,
                    &quot;parentUUID&quot;: &quot;204d1bdd-22c0-4850-94ab-0c82770bd4b4&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;13860a7e-713e-449d-94c9-71a7e65b7b4f&quot;,
                    &quot;parentUUID&quot;: &quot;204d1bdd-22c0-4850-94ab-0c82770bd4b4&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;uuid&quot;: &quot;204d1bdd-22c0-4850-94ab-0c82770bd4b4&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare error_cb&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Deve chiamare error_cb&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;da3569fc-a24e-441b-a2f4-8829e6eec349&quot;,
                    &quot;parentUUID&quot;: &quot;204d1bdd-22c0-4850-94ab-0c82770bd4b4&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onError(success);\nobs.pause();\nobs.error(&#x27;errore&#x27;);\n        expect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;65e1072f-f459-42dc-8f7c-9db51ff6fc20&quot;,
                    &quot;parentUUID&quot;: &quot;204d1bdd-22c0-4850-94ab-0c82770bd4b4&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;13860a7e-713e-449d-94c9-71a7e65b7b4f&quot;,
                    &quot;parentUUID&quot;: &quot;204d1bdd-22c0-4850-94ab-0c82770bd4b4&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 3,
                &quot;totalPasses&quot;: 3,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 1,
                &quot;rootEmpty&quot;: false
              },
              {
                &quot;title&quot;: &quot;next&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal(&#x27;data&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;8cb58066-4208-4eac-90c2-ee97394123bb&quot;,
                    &quot;parentUUID&quot;: &quot;ba3d019e-1ebb-4126-b37b-87886bf6b99f&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.pause();\nobs.next(&#x27;Function called&#x27;);\nexpect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;3a79d872-a40c-4c3c-8e5b-dc6efc2b3252&quot;,
                    &quot;parentUUID&quot;: &quot;ba3d019e-1ebb-4126-b37b-87886bf6b99f&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next(&#x27;other data&#x27;);\nexpect(success.callCount).to.equal(2);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;bf55b7ae-26fa-4b00-9585-a3fdf3edbb10&quot;,
                    &quot;parentUUID&quot;: &quot;ba3d019e-1ebb-4126-b37b-87886bf6b99f&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;uuid&quot;: &quot;ba3d019e-1ebb-4126-b37b-87886bf6b99f&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal(&#x27;data&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;8cb58066-4208-4eac-90c2-ee97394123bb&quot;,
                    &quot;parentUUID&quot;: &quot;ba3d019e-1ebb-4126-b37b-87886bf6b99f&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.pause();\nobs.next(&#x27;Function called&#x27;);\nexpect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;3a79d872-a40c-4c3c-8e5b-dc6efc2b3252&quot;,
                    &quot;parentUUID&quot;: &quot;ba3d019e-1ebb-4126-b37b-87886bf6b99f&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next(&#x27;other data&#x27;);\nexpect(success.callCount).to.equal(2);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;bf55b7ae-26fa-4b00-9585-a3fdf3edbb10&quot;,
                    &quot;parentUUID&quot;: &quot;ba3d019e-1ebb-4126-b37b-87886bf6b99f&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 3,
                &quot;totalPasses&quot;: 3,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 1,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
            &quot;uuid&quot;: &quot;5aa17d31-b074-41a4-8369-b01ef23009ad&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
        &quot;uuid&quot;: &quot;7111afa9-8dc8-448d-8bd6-029c6d4b7f4e&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Rules&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;RulesDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB addRule Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;934e4d87-01be-444f-acf3-15460f34536a&quot;,
                        &quot;parentUUID&quot;: &quot;bf1363d3-41b8-4990-a222-6f3a85fdfef2&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB addRule Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;503cfc1b-beba-4010-8279-0dcd837d9f20&quot;,
                        &quot;parentUUID&quot;: &quot;bf1363d3-41b8-4990-a222-6f3a85fdfef2&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;bf1363d3-41b8-4990-a222-6f3a85fdfef2&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB addRule Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;934e4d87-01be-444f-acf3-15460f34536a&quot;,
                        &quot;parentUUID&quot;: &quot;bf1363d3-41b8-4990-a222-6f3a85fdfef2&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB addRule Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;503cfc1b-beba-4010-8279-0dcd837d9f20&quot;,
                        &quot;parentUUID&quot;: &quot;bf1363d3-41b8-4990-a222-6f3a85fdfef2&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRule Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;21dc619c-91e6-40c6-ad11-1442868ac06e&quot;,
                        &quot;parentUUID&quot;: &quot;05b253d1-4b06-475d-8369-e3533b9fcadc&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRule Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;345df0f6-fa34-4840-94b1-b70d9eb5d099&quot;,
                        &quot;parentUUID&quot;: &quot;05b253d1-4b06-475d-8369-e3533b9fcadc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;05b253d1-4b06-475d-8369-e3533b9fcadc&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRule Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;21dc619c-91e6-40c6-ad11-1442868ac06e&quot;,
                        &quot;parentUUID&quot;: &quot;05b253d1-4b06-475d-8369-e3533b9fcadc&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRule Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;345df0f6-fa34-4840-94b1-b70d9eb5d099&quot;,
                        &quot;parentUUID&quot;: &quot;05b253d1-4b06-475d-8369-e3533b9fcadc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getRuleList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d4a87f6a-2a70-4e9c-8324-3218f7b80b41&quot;,
                        &quot;parentUUID&quot;: &quot;796a2f4e-c5ba-4b56-8e5f-ad0836ca3af1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;03a52eed-d228-4ce0-ba73-bf66dd2c67eb&quot;,
                        &quot;parentUUID&quot;: &quot;796a2f4e-c5ba-4b56-8e5f-ad0836ca3af1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;//da definire&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;85e87854-923e-4963-bc32-c5b333ff66bb&quot;,
                        &quot;parentUUID&quot;: &quot;796a2f4e-c5ba-4b56-8e5f-ad0836ca3af1&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;796a2f4e-c5ba-4b56-8e5f-ad0836ca3af1&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d4a87f6a-2a70-4e9c-8324-3218f7b80b41&quot;,
                        &quot;parentUUID&quot;: &quot;796a2f4e-c5ba-4b56-8e5f-ad0836ca3af1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;03a52eed-d228-4ce0-ba73-bf66dd2c67eb&quot;,
                        &quot;parentUUID&quot;: &quot;796a2f4e-c5ba-4b56-8e5f-ad0836ca3af1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;//da definire&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;85e87854-923e-4963-bc32-c5b333ff66bb&quot;,
                        &quot;parentUUID&quot;: &quot;796a2f4e-c5ba-4b56-8e5f-ad0836ca3af1&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB removeRule Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;bced9eb7-0935-4d60-9908-f9ccfb02dead&quot;,
                        &quot;parentUUID&quot;: &quot;a02b0b04-9bbe-4cd2-bf7b-17ecc041275e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB removeRule Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e3e011d3-501d-46f6-9b90-1cdb72936702&quot;,
                        &quot;parentUUID&quot;: &quot;a02b0b04-9bbe-4cd2-bf7b-17ecc041275e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;a02b0b04-9bbe-4cd2-bf7b-17ecc041275e&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB removeRule Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;bced9eb7-0935-4d60-9908-f9ccfb02dead&quot;,
                        &quot;parentUUID&quot;: &quot;a02b0b04-9bbe-4cd2-bf7b-17ecc041275e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB removeRule Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e3e011d3-501d-46f6-9b90-1cdb72936702&quot;,
                        &quot;parentUUID&quot;: &quot;a02b0b04-9bbe-4cd2-bf7b-17ecc041275e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5c7da28f-01a5-43d5-b23d-da7e128d55a8&quot;,
                        &quot;parentUUID&quot;: &quot;3430135a-ac18-4acd-88fb-01bd4659c0b5&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;447686e3-caa4-44c9-ad92-ec66ddf71e3d&quot;,
                        &quot;parentUUID&quot;: &quot;3430135a-ac18-4acd-88fb-01bd4659c0b5&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;3430135a-ac18-4acd-88fb-01bd4659c0b5&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5c7da28f-01a5-43d5-b23d-da7e128d55a8&quot;,
                        &quot;parentUUID&quot;: &quot;3430135a-ac18-4acd-88fb-01bd4659c0b5&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;447686e3-caa4-44c9-ad92-ec66ddf71e3d&quot;,
                        &quot;parentUUID&quot;: &quot;3430135a-ac18-4acd-88fb-01bd4659c0b5&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;d226ccff-6f43-4eac-bd01-b98c79d872a3&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;33322c66-e599-491b-981d-2437fc224aa6&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;62650b35-2f82-494b-a845-7f76c700a1b4&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Rules&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;RulesService&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \&quot;\&quot;};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1674d18a-5a83-4caf-8846-12583e8cd6c0&quot;,
                        &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;de153504-a563-4490-a27b-661ae53e130a&quot;,
                        &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6b942434-fc86-4f3c-9e37-9538706a122d&quot;,
                        &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;24d0af1b-2539-48ca-8e56-1ac8af8f5f8c&quot;,
                        &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \&quot;\&quot;};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1674d18a-5a83-4caf-8846-12583e8cd6c0&quot;,
                        &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;de153504-a563-4490-a27b-661ae53e130a&quot;,
                        &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6b942434-fc86-4f3c-9e37-9538706a122d&quot;,
                        &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;24d0af1b-2539-48ca-8e56-1ac8af8f5f8c&quot;,
                        &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 4,
                    &quot;totalPasses&quot;: 4,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 4,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;deleteRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;361ad7bf-ee31-49ea-bf21-9bc46909f363&quot;,
                        &quot;parentUUID&quot;: &quot;78918e59-adcc-4e96-93fd-f9fa31c3ead3&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;70f32ba1-df22-443b-9957-30963e0ca8b2&quot;,
                        &quot;parentUUID&quot;: &quot;78918e59-adcc-4e96-93fd-f9fa31c3ead3&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);\n};&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;80eed219-b4c0-4c48-9cab-b2d5962fcae1&quot;,
                        &quot;parentUUID&quot;: &quot;78918e59-adcc-4e96-93fd-f9fa31c3ead3&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;78918e59-adcc-4e96-93fd-f9fa31c3ead3&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;361ad7bf-ee31-49ea-bf21-9bc46909f363&quot;,
                        &quot;parentUUID&quot;: &quot;78918e59-adcc-4e96-93fd-f9fa31c3ead3&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;70f32ba1-df22-443b-9957-30963e0ca8b2&quot;,
                        &quot;parentUUID&quot;: &quot;78918e59-adcc-4e96-93fd-f9fa31c3ead3&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);\n};&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;80eed219-b4c0-4c48-9cab-b2d5962fcae1&quot;,
                        &quot;parentUUID&quot;: &quot;78918e59-adcc-4e96-93fd-f9fa31c3ead3&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;dd96d9e9-73ad-4b34-8c50-913c43728867&quot;,
                        &quot;parentUUID&quot;: &quot;87f5b940-cacc-47f6-a220-04c266d28f86&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8c54c567-b5e3-4e35-b84c-e47a0f9f381b&quot;,
                        &quot;parentUUID&quot;: &quot;87f5b940-cacc-47f6-a220-04c266d28f86&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;749eb433-b190-4ec6-9811-771631eb928d&quot;,
                        &quot;parentUUID&quot;: &quot;87f5b940-cacc-47f6-a220-04c266d28f86&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;87f5b940-cacc-47f6-a220-04c266d28f86&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;dd96d9e9-73ad-4b34-8c50-913c43728867&quot;,
                        &quot;parentUUID&quot;: &quot;87f5b940-cacc-47f6-a220-04c266d28f86&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8c54c567-b5e3-4e35-b84c-e47a0f9f381b&quot;,
                        &quot;parentUUID&quot;: &quot;87f5b940-cacc-47f6-a220-04c266d28f86&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;749eb433-b190-4ec6-9811-771631eb928d&quot;,
                        &quot;parentUUID&quot;: &quot;87f5b940-cacc-47f6-a220-04c266d28f86&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getRuleList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;24a91b29-1fb3-456d-89a1-b84f022bbe85&quot;,
                        &quot;parentUUID&quot;: &quot;6c012c69-dca6-4f4e-a7bf-3bb04e611dbb&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;02c0b11a-ac3d-4d15-9285-a93c10989d27&quot;,
                        &quot;parentUUID&quot;: &quot;6c012c69-dca6-4f4e-a7bf-3bb04e611dbb&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;6c012c69-dca6-4f4e-a7bf-3bb04e611dbb&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;24a91b29-1fb3-456d-89a1-b84f022bbe85&quot;,
                        &quot;parentUUID&quot;: &quot;6c012c69-dca6-4f4e-a7bf-3bb04e611dbb&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;02c0b11a-ac3d-4d15-9285-a93c10989d27&quot;,
                        &quot;parentUUID&quot;: &quot;6c012c69-dca6-4f4e-a7bf-3bb04e611dbb&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getTaskList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;de0c99e0-dc0b-4bb3-b240-aa39ffb3253f&quot;,
                        &quot;parentUUID&quot;: &quot;35f3fa36-00bf-4d8b-bd5f-d1a6a924ef8d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a341108f-a681-4925-be66-f3b2e866edd0&quot;,
                        &quot;parentUUID&quot;: &quot;35f3fa36-00bf-4d8b-bd5f-d1a6a924ef8d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;35f3fa36-00bf-4d8b-bd5f-d1a6a924ef8d&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;de0c99e0-dc0b-4bb3-b240-aa39ffb3253f&quot;,
                        &quot;parentUUID&quot;: &quot;35f3fa36-00bf-4d8b-bd5f-d1a6a924ef8d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a341108f-a681-4925-be66-f3b2e866edd0&quot;,
                        &quot;parentUUID&quot;: &quot;35f3fa36-00bf-4d8b-bd5f-d1a6a924ef8d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;707839fe-6576-4a1f-bb39-718966de647a&quot;,
                        &quot;parentUUID&quot;: &quot;f359a61f-53e0-4849-9350-f676a79cdc49&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \&quot;\&quot; , body: \&quot;\&quot;};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;61296071-82c7-481b-bb79-aa83e584e793&quot;,
                        &quot;parentUUID&quot;: &quot;f359a61f-53e0-4849-9350-f676a79cdc49&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5b610349-3571-45f4-8a04-a13584e3c7b9&quot;,
                        &quot;parentUUID&quot;: &quot;f359a61f-53e0-4849-9350-f676a79cdc49&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;f359a61f-53e0-4849-9350-f676a79cdc49&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;707839fe-6576-4a1f-bb39-718966de647a&quot;,
                        &quot;parentUUID&quot;: &quot;f359a61f-53e0-4849-9350-f676a79cdc49&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \&quot;\&quot; , body: \&quot;\&quot;};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;61296071-82c7-481b-bb79-aa83e584e793&quot;,
                        &quot;parentUUID&quot;: &quot;f359a61f-53e0-4849-9350-f676a79cdc49&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5b610349-3571-45f4-8a04-a13584e3c7b9&quot;,
                        &quot;parentUUID&quot;: &quot;f359a61f-53e0-4849-9350-f676a79cdc49&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                &quot;uuid&quot;: &quot;4ecfe921-2127-466c-80ce-f602d515698c&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
            &quot;uuid&quot;: &quot;2e90b7d8-9366-4009-a5ae-4b4fcebe5bf9&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
        &quot;uuid&quot;: &quot;a33ab96b-5860-4d1f-9162-e156fd31b350&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;STT&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;STTWatsonAdapter&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;speechToText&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
                        &quot;fullTitle&quot;: &quot;STTWatsonAdapter speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3c0189b2-57ed-4624-b102-f0f3368eca31&quot;,
                        &quot;parentUUID&quot;: &quot;c2a6a27f-970f-4b54-aac1-55dab2da64e9&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_STTWatsonAdapter.js&quot;,
                    &quot;uuid&quot;: &quot;c2a6a27f-970f-4b54-aac1-55dab2da64e9&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
                        &quot;fullTitle&quot;: &quot;STTWatsonAdapter speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3c0189b2-57ed-4624-b102-f0f3368eca31&quot;,
                        &quot;parentUUID&quot;: &quot;c2a6a27f-970f-4b54-aac1-55dab2da64e9&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_STTWatsonAdapter.js&quot;,
                &quot;uuid&quot;: &quot;18e2e45e-af1d-49f5-b680-f1433754d2d2&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_STTWatsonAdapter.js&quot;,
            &quot;uuid&quot;: &quot;d2849209-c25b-455f-a22f-7bae511b6a33&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_STTWatsonAdapter.js&quot;,
        &quot;uuid&quot;: &quot;dd61722b-8b03-406a-b851-c77c03b42510&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Tasks&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;TasksDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addTask&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5bac7e4d-6ace-419b-b143-e9926c97fd91&quot;,
                        &quot;parentUUID&quot;: &quot;91b18b66-4766-489b-8b7f-13f9944c23f4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;42f93b22-bdc4-4875-b595-5023c1452e15&quot;,
                        &quot;parentUUID&quot;: &quot;91b18b66-4766-489b-8b7f-13f9944c23f4&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;91b18b66-4766-489b-8b7f-13f9944c23f4&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5bac7e4d-6ace-419b-b143-e9926c97fd91&quot;,
                        &quot;parentUUID&quot;: &quot;91b18b66-4766-489b-8b7f-13f9944c23f4&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;42f93b22-bdc4-4875-b595-5023c1452e15&quot;,
                        &quot;parentUUID&quot;: &quot;91b18b66-4766-489b-8b7f-13f9944c23f4&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getTask&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTask Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTask(&#x27;mock_type&#x27;).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3cfd4d56-7c37-4a09-aad0-501abbaa9130&quot;,
                        &quot;parentUUID&quot;: &quot;099c502d-b5e9-45d7-8547-25e35212d3d8&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTask Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = tasks.getTask(&#x27;mock_type&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cec36c77-a3a1-478d-8ef1-e9188d14c3cf&quot;,
                        &quot;parentUUID&quot;: &quot;099c502d-b5e9-45d7-8547-25e35212d3d8&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;099c502d-b5e9-45d7-8547-25e35212d3d8&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTask Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTask(&#x27;mock_type&#x27;).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3cfd4d56-7c37-4a09-aad0-501abbaa9130&quot;,
                        &quot;parentUUID&quot;: &quot;099c502d-b5e9-45d7-8547-25e35212d3d8&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTask Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = tasks.getTask(&#x27;mock_type&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cec36c77-a3a1-478d-8ef1-e9188d14c3cf&quot;,
                        &quot;parentUUID&quot;: &quot;099c502d-b5e9-45d7-8547-25e35212d3d8&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getTaskList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \&quot;mock_type3\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b7ea70d0-04f4-4cf0-928b-61b8ce7b6a55&quot;,
                        &quot;parentUUID&quot;: &quot;1b6a918c-e231-43ba-8b1e-c2745b127421&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTaskList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8f938647-2fef-4dbb-a072-6318ef9cad47&quot;,
                        &quot;parentUUID&quot;: &quot;1b6a918c-e231-43ba-8b1e-c2745b127421&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;1b6a918c-e231-43ba-8b1e-c2745b127421&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \&quot;mock_type3\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b7ea70d0-04f4-4cf0-928b-61b8ce7b6a55&quot;,
                        &quot;parentUUID&quot;: &quot;1b6a918c-e231-43ba-8b1e-c2745b127421&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTaskList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8f938647-2fef-4dbb-a072-6318ef9cad47&quot;,
                        &quot;parentUUID&quot;: &quot;1b6a918c-e231-43ba-8b1e-c2745b127421&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeTask&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1243fdb4-4787-4a29-b7ad-282b21e87191&quot;,
                        &quot;parentUUID&quot;: &quot;ddd2deae-dc67-4fa1-acbb-783f728a0c68&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;659e1a19-d564-46bf-b881-4dc2187ad8fc&quot;,
                        &quot;parentUUID&quot;: &quot;ddd2deae-dc67-4fa1-acbb-783f728a0c68&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;ddd2deae-dc67-4fa1-acbb-783f728a0c68&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1243fdb4-4787-4a29-b7ad-282b21e87191&quot;,
                        &quot;parentUUID&quot;: &quot;ddd2deae-dc67-4fa1-acbb-783f728a0c68&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;659e1a19-d564-46bf-b881-4dc2187ad8fc&quot;,
                        &quot;parentUUID&quot;: &quot;ddd2deae-dc67-4fa1-acbb-783f728a0c68&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateTask&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8504f966-68d3-4836-81ad-ad5cada735c1&quot;,
                        &quot;parentUUID&quot;: &quot;5fa06823-14a6-401d-b42f-033e00297dcb&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;28aa9f5a-915d-4b3a-acaa-dfaec7c73215&quot;,
                        &quot;parentUUID&quot;: &quot;5fa06823-14a6-401d-b42f-033e00297dcb&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;5fa06823-14a6-401d-b42f-033e00297dcb&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8504f966-68d3-4836-81ad-ad5cada735c1&quot;,
                        &quot;parentUUID&quot;: &quot;5fa06823-14a6-401d-b42f-033e00297dcb&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;28aa9f5a-915d-4b3a-acaa-dfaec7c73215&quot;,
                        &quot;parentUUID&quot;: &quot;5fa06823-14a6-401d-b42f-033e00297dcb&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;9949f0a0-0ce3-4bee-a103-766e1814ff8d&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;2d7e2650-1a73-4aeb-bcce-348046b14b22&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;4dbc63c1-1034-4563-b2a4-edada79edfdd&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Users&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;UsersDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB addUser Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\&quot;Requested resource not found\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2433a75a-55dc-4c45-8002-333e240b3fed&quot;,
                        &quot;parentUUID&quot;: &quot;6fac0e24-fc7b-4864-a248-232b6ca6035b&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB addUser Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;71d8a601-23b5-4b1c-aab0-15532fba3a8c&quot;,
                        &quot;parentUUID&quot;: &quot;6fac0e24-fc7b-4864-a248-232b6ca6035b&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;6fac0e24-fc7b-4864-a248-232b6ca6035b&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB addUser Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\&quot;Requested resource not found\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2433a75a-55dc-4c45-8002-333e240b3fed&quot;,
                        &quot;parentUUID&quot;: &quot;6fac0e24-fc7b-4864-a248-232b6ca6035b&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB addUser Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;71d8a601-23b5-4b1c-aab0-15532fba3a8c&quot;,
                        &quot;parentUUID&quot;: &quot;6fac0e24-fc7b-4864-a248-232b6ca6035b&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUser Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8e647fbb-14a2-4528-a7ea-0cce4231b29a&quot;,
                        &quot;parentUUID&quot;: &quot;bcf95ab7-ada2-4f61-ab33-f4b854eb1061&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUser Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = users.getUser(&#x27;mou&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\n\t\t\t\t\texpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;71b1ff63-6baf-48f8-a201-3fd68b3fcb3a&quot;,
                        &quot;parentUUID&quot;: &quot;bcf95ab7-ada2-4f61-ab33-f4b854eb1061&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;bcf95ab7-ada2-4f61-ab33-f4b854eb1061&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUser Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8e647fbb-14a2-4528-a7ea-0cce4231b29a&quot;,
                        &quot;parentUUID&quot;: &quot;bcf95ab7-ada2-4f61-ab33-f4b854eb1061&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUser Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = users.getUser(&#x27;mou&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\n\t\t\t\t\texpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;71b1ff63-6baf-48f8-a201-3fd68b3fcb3a&quot;,
                        &quot;parentUUID&quot;: &quot;bcf95ab7-ada2-4f61-ab33-f4b854eb1061&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUserList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}], LastEvaluatedKey: &#x27;marco&#x27;});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a3e8042e-1b92-41b5-97a5-34db559918b1&quot;,
                        &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5a305065-883c-4efc-957a-001b810df4a2&quot;,
                        &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a249c586-c79d-4f2b-abf2-acd05ccd7b26&quot;,
                        &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;,\n\tslack_channel: &#x27;channel&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name and slack_channel = :slack_channel&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:slack_channel&#x27;, &#x27;channel&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f776324b-dd8c-4398-b072-c422452452ba&quot;,
                        &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}], LastEvaluatedKey: &#x27;marco&#x27;});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a3e8042e-1b92-41b5-97a5-34db559918b1&quot;,
                        &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5a305065-883c-4efc-957a-001b810df4a2&quot;,
                        &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a249c586-c79d-4f2b-abf2-acd05ccd7b26&quot;,
                        &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;,\n\tslack_channel: &#x27;channel&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name and slack_channel = :slack_channel&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:slack_channel&#x27;, &#x27;channel&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f776324b-dd8c-4398-b072-c422452452ba&quot;,
                        &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 4,
                    &quot;totalPasses&quot;: 4,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 4,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB removeUser Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \&quot;error removing user\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;70ecaf17-d8cc-4dcc-8e66-fbc752b593e0&quot;,
                        &quot;parentUUID&quot;: &quot;ea0ad7ca-3878-41be-88fc-70e538015e5b&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB removeUser Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;24cd4871-5284-4146-9984-f989a46d6967&quot;,
                        &quot;parentUUID&quot;: &quot;ea0ad7ca-3878-41be-88fc-70e538015e5b&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;ea0ad7ca-3878-41be-88fc-70e538015e5b&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB removeUser Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \&quot;error removing user\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;70ecaf17-d8cc-4dcc-8e66-fbc752b593e0&quot;,
                        &quot;parentUUID&quot;: &quot;ea0ad7ca-3878-41be-88fc-70e538015e5b&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB removeUser Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;24cd4871-5284-4146-9984-f989a46d6967&quot;,
                        &quot;parentUUID&quot;: &quot;ea0ad7ca-3878-41be-88fc-70e538015e5b&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB updateUser Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \&quot;error updating user\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;12dec5a4-3114-4254-8c1b-4de61a05c51c&quot;,
                        &quot;parentUUID&quot;: &quot;516606e8-a45a-4765-a379-77ad44f54277&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB updateUser Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cf1757ff-525d-4351-9cc1-af9d61d15f5d&quot;,
                        &quot;parentUUID&quot;: &quot;516606e8-a45a-4765-a379-77ad44f54277&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;516606e8-a45a-4765-a379-77ad44f54277&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB updateUser Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \&quot;error updating user\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;12dec5a4-3114-4254-8c1b-4de61a05c51c&quot;,
                        &quot;parentUUID&quot;: &quot;516606e8-a45a-4765-a379-77ad44f54277&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB updateUser Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cf1757ff-525d-4351-9cc1-af9d61d15f5d&quot;,
                        &quot;parentUUID&quot;: &quot;516606e8-a45a-4765-a379-77ad44f54277&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;6bca3bdf-3cd7-4391-bfab-72789721eacc&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;eb78edcd-0069-40d2-a15f-8c0d10039966&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;4cb1c481-2ea6-4d7e-b34b-948aa16b6bf5&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Users&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;UsersService&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;584e0bde-9cbe-474b-9b6f-f910cb839772&quot;,
                        &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4c7de136-9b70-4865-a84b-e86ac58eb34c&quot;,
                        &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \&quot;\&quot; };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;dcf6e942-f678-4f00-8a8e-8bf44321913c&quot;,
                        &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ffc49c2b-e8f8-4489-86d6-d22d9e60a775&quot;,
                        &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;584e0bde-9cbe-474b-9b6f-f910cb839772&quot;,
                        &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4c7de136-9b70-4865-a84b-e86ac58eb34c&quot;,
                        &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \&quot;\&quot; };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;dcf6e942-f678-4f00-8a8e-8bf44321913c&quot;,
                        &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ffc49c2b-e8f8-4489-86d6-d22d9e60a775&quot;,
                        &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 4,
                    &quot;totalPasses&quot;: 4,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;deleteUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;527798db-4117-4d43-9e24-bb78024275f7&quot;,
                        &quot;parentUUID&quot;: &quot;542ca549-4e45-4cb6-852b-c7889f87c2af&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2af69d0c-4bea-4975-87ce-4e145481423d&quot;,
                        &quot;parentUUID&quot;: &quot;542ca549-4e45-4cb6-852b-c7889f87c2af&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { pathParameters: { username: &#x27;pippo&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9e0ac3ba-43b5-48b4-a156-aacacd78c0a9&quot;,
                        &quot;parentUUID&quot;: &quot;542ca549-4e45-4cb6-852b-c7889f87c2af&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;542ca549-4e45-4cb6-852b-c7889f87c2af&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;527798db-4117-4d43-9e24-bb78024275f7&quot;,
                        &quot;parentUUID&quot;: &quot;542ca549-4e45-4cb6-852b-c7889f87c2af&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2af69d0c-4bea-4975-87ce-4e145481423d&quot;,
                        &quot;parentUUID&quot;: &quot;542ca549-4e45-4cb6-852b-c7889f87c2af&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { pathParameters: { username: &#x27;pippo&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9e0ac3ba-43b5-48b4-a156-aacacd78c0a9&quot;,
                        &quot;parentUUID&quot;: &quot;542ca549-4e45-4cb6-852b-c7889f87c2af&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9ba417d8-2bba-4ca1-a11c-f523c4794c8d&quot;,
                        &quot;parentUUID&quot;: &quot;a4782cf0-880d-486a-91e3-c1251b9691d5&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c4fa0022-1aba-435b-bbe9-92af173cecf2&quot;,
                        &quot;parentUUID&quot;: &quot;a4782cf0-880d-486a-91e3-c1251b9691d5&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\n          let ev = { pathParameters: { username: &#x27;pippo&#x27;} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;13fb6b81-085c-4919-a6aa-c34c43a07112&quot;,
                        &quot;parentUUID&quot;: &quot;a4782cf0-880d-486a-91e3-c1251b9691d5&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;a4782cf0-880d-486a-91e3-c1251b9691d5&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9ba417d8-2bba-4ca1-a11c-f523c4794c8d&quot;,
                        &quot;parentUUID&quot;: &quot;a4782cf0-880d-486a-91e3-c1251b9691d5&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c4fa0022-1aba-435b-bbe9-92af173cecf2&quot;,
                        &quot;parentUUID&quot;: &quot;a4782cf0-880d-486a-91e3-c1251b9691d5&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\n          let ev = { pathParameters: { username: &#x27;pippo&#x27;} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;13fb6b81-085c-4919-a6aa-c34c43a07112&quot;,
                        &quot;parentUUID&quot;: &quot;a4782cf0-880d-486a-91e3-c1251b9691d5&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUserList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;70819cd4-26ac-494c-9a6a-364c9f708a56&quot;,
                        &quot;parentUUID&quot;: &quot;d98c2df1-5efa-4cf8-8328-5fafa3b8e9fe&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ users: [{ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;427574cc-a0b2-4674-85ed-98eb964196f4&quot;,
                        &quot;parentUUID&quot;: &quot;d98c2df1-5efa-4cf8-8328-5fafa3b8e9fe&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;d98c2df1-5efa-4cf8-8328-5fafa3b8e9fe&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;70819cd4-26ac-494c-9a6a-364c9f708a56&quot;,
                        &quot;parentUUID&quot;: &quot;d98c2df1-5efa-4cf8-8328-5fafa3b8e9fe&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ users: [{ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;427574cc-a0b2-4674-85ed-98eb964196f4&quot;,
                        &quot;parentUUID&quot;: &quot;d98c2df1-5efa-4cf8-8328-5fafa3b8e9fe&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;332976fa-5130-40b7-8f05-0453f492dafe&quot;,
                        &quot;parentUUID&quot;: &quot;52ba070d-3a13-444f-985d-5b832579633e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;61c99b34-10db-4968-8d2e-7717a326d5e6&quot;,
                        &quot;parentUUID&quot;: &quot;52ba070d-3a13-444f-985d-5b832579633e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = { pathParameters: \&quot;\&quot;, body: \&quot;\&quot; };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4f17a565-39dc-45d1-9026-de65d6850c53&quot;,
                        &quot;parentUUID&quot;: &quot;52ba070d-3a13-444f-985d-5b832579633e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;52ba070d-3a13-444f-985d-5b832579633e&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;332976fa-5130-40b7-8f05-0453f492dafe&quot;,
                        &quot;parentUUID&quot;: &quot;52ba070d-3a13-444f-985d-5b832579633e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;61c99b34-10db-4968-8d2e-7717a326d5e6&quot;,
                        &quot;parentUUID&quot;: &quot;52ba070d-3a13-444f-985d-5b832579633e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = { pathParameters: \&quot;\&quot;, body: \&quot;\&quot; };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4f17a565-39dc-45d1-9026-de65d6850c53&quot;,
                        &quot;parentUUID&quot;: &quot;52ba070d-3a13-444f-985d-5b832579633e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                &quot;uuid&quot;: &quot;dbcc9f04-8840-4ae2-8c5b-8d9ee9765591&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
            &quot;uuid&quot;: &quot;8541b9b3-907a-4f3e-91b2-07c3eab023f9&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
        &quot;uuid&quot;: &quot;7632b266-0aa8-4110-9f78-2d08cf016c48&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Events&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;VAMessageListener&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;onMessage&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;445aa1eb-908a-4bc9-a1e1-fa54c2a5caa9&quot;,
                        &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fdde9ab2-e797-4b53-8eb3-532a66ae2a8b&quot;,
                        &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;msg&#x27;: &#x27;error getting guest&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5adb5032-e2b4-48f4-9355-909020f3b1da&quot;,
                        &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ &#x27;msg&#x27;: &#x27;error adding conversation&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;22ecbdd2-e85b-4695-bd0c-2a8d97a51537&quot;,
                        &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;type&#x27;: &#x27;example&#x27; });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;459505e4-3403-4fcb-8c5d-34125494bd74&quot;,
                        &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VAMessageListener.js&quot;,
                    &quot;uuid&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;445aa1eb-908a-4bc9-a1e1-fa54c2a5caa9&quot;,
                        &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fdde9ab2-e797-4b53-8eb3-532a66ae2a8b&quot;,
                        &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;msg&#x27;: &#x27;error getting guest&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5adb5032-e2b4-48f4-9355-909020f3b1da&quot;,
                        &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ &#x27;msg&#x27;: &#x27;error adding conversation&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;22ecbdd2-e85b-4695-bd0c-2a8d97a51537&quot;,
                        &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;type&#x27;: &#x27;example&#x27; });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;459505e4-3403-4fcb-8c5d-34125494bd74&quot;,
                        &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 5,
                    &quot;totalPasses&quot;: 5,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_VAMessageListener.js&quot;,
                &quot;uuid&quot;: &quot;78aaab95-5fa6-4008-898e-75999ffe29ee&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_VAMessageListener.js&quot;,
            &quot;uuid&quot;: &quot;b21c9fa3-8ef8-4b42-ad04-2ed61664baf1&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_VAMessageListener.js&quot;,
        &quot;uuid&quot;: &quot;8f0d3a3b-679d-41b3-aa7b-5fd94f9ac583&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;VirtualAssistant&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;VAService&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;query&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;VAService query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith(&#x27;test&#x27;));\n\tlet result = context.succeed.getCall(0).args[0];\n            expect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n            done();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;226cf9e1-13b9-4856-a032-040122b5641b&quot;,
                        &quot;parentUUID&quot;: &quot;1452e88c-5d82-48e6-a29a-37bcfef2191c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
                        &quot;fullTitle&quot;: &quot;VAService query Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.reject(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n            done();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9e8e83cb-5035-4258-8a63-7e375bf0da82&quot;,
                        &quot;parentUUID&quot;: &quot;1452e88c-5d82-48e6-a29a-37bcfef2191c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VAService.js&quot;,
                    &quot;uuid&quot;: &quot;1452e88c-5d82-48e6-a29a-37bcfef2191c&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;VAService query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith(&#x27;test&#x27;));\n\tlet result = context.succeed.getCall(0).args[0];\n            expect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n            done();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;226cf9e1-13b9-4856-a032-040122b5641b&quot;,
                        &quot;parentUUID&quot;: &quot;1452e88c-5d82-48e6-a29a-37bcfef2191c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
                        &quot;fullTitle&quot;: &quot;VAService query Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.reject(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n            done();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9e8e83cb-5035-4258-8a63-7e375bf0da82&quot;,
                        &quot;parentUUID&quot;: &quot;1452e88c-5d82-48e6-a29a-37bcfef2191c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 6,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_VAService.js&quot;,
                &quot;uuid&quot;: &quot;d38e3021-b43f-4b32-b6ca-aa17357ce951&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_VAService.js&quot;,
            &quot;uuid&quot;: &quot;7201b2e5-15e3-4cda-8668-578728efc4f0&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_VAService.js&quot;,
        &quot;uuid&quot;: &quot;d07b8eac-1534-40fb-826c-a088c8f6005d&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;APIGateway&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;VocalAPI&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;_addRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;29caa929-a0f0-4dde-b8c0-65472fc4cc40&quot;,
                        &quot;parentUUID&quot;: &quot;9daec29c-268a-4c98-88ed-d54afc57c5b9&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;9daec29c-268a-4c98-88ed-d54afc57c5b9&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;29caa929-a0f0-4dde-b8c0-65472fc4cc40&quot;,
                        &quot;parentUUID&quot;: &quot;9daec29c-268a-4c98-88ed-d54afc57c5b9&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_addUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9ec12e84-282b-4290-8c1d-08f49a54fd3a&quot;,
                        &quot;parentUUID&quot;: &quot;9f7c5468-bd18-461e-aec0-24783382a75b&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;9f7c5468-bd18-461e-aec0-24783382a75b&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9ec12e84-282b-4290-8c1d-08f49a54fd3a&quot;,
                        &quot;parentUUID&quot;: &quot;9f7c5468-bd18-461e-aec0-24783382a75b&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_addUserEnrollment&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.addEnrollment.returns(Rx.Observable.throw(errore));\napi._addUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;55d2c52c-f810-4ac8-ac11-a6cb50c8c8e2&quot;,
                        &quot;parentUUID&quot;: &quot;db0e07f5-b977-44d4-bdfd-cfa75e777175&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;db0e07f5-b977-44d4-bdfd-cfa75e777175&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.addEnrollment.returns(Rx.Observable.throw(errore));\napi._addUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;55d2c52c-f810-4ac8-ac11-a6cb50c8c8e2&quot;,
                        &quot;parentUUID&quot;: &quot;db0e07f5-b977-44d4-bdfd-cfa75e777175&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_getRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;66bcaf1d-f8e5-4520-a7dc-8ab14b474f47&quot;,
                        &quot;parentUUID&quot;: &quot;b6a175e2-678e-438c-88ba-ea67fc2550de&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;b6a175e2-678e-438c-88ba-ea67fc2550de&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;66bcaf1d-f8e5-4520-a7dc-8ab14b474f47&quot;,
                        &quot;parentUUID&quot;: &quot;b6a175e2-678e-438c-88ba-ea67fc2550de&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_getRuleList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c4da9def-8688-417c-9f3a-38db852bbf48&quot;,
                        &quot;parentUUID&quot;: &quot;8623eed6-bd3a-408a-bdab-618a75deccec&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;8623eed6-bd3a-408a-bdab-618a75deccec&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c4da9def-8688-417c-9f3a-38db852bbf48&quot;,
                        &quot;parentUUID&quot;: &quot;8623eed6-bd3a-408a-bdab-618a75deccec&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_getUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3bcc2dbc-0f81-45c2-bd2b-06227ec1a581&quot;,
                        &quot;parentUUID&quot;: &quot;157be1f0-5ab2-4cb4-90d1-f99ffe481390&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;157be1f0-5ab2-4cb4-90d1-f99ffe481390&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3bcc2dbc-0f81-45c2-bd2b-06227ec1a581&quot;,
                        &quot;parentUUID&quot;: &quot;157be1f0-5ab2-4cb4-90d1-f99ffe481390&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_getUserList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e03f0367-9493-4836-9fcc-fe7f2684c069&quot;,
                        &quot;parentUUID&quot;: &quot;29bcb080-578d-44b7-9aa0-7ad7c49addfd&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;29bcb080-578d-44b7-9aa0-7ad7c49addfd&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e03f0367-9493-4836-9fcc-fe7f2684c069&quot;,
                        &quot;parentUUID&quot;: &quot;29bcb080-578d-44b7-9aa0-7ad7c49addfd&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_loginUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.doLogin.returns(Rx.Observable.throw(errore));\napi._loginUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2cb6af96-dd0c-43f5-b2b7-4bc98907d069&quot;,
                        &quot;parentUUID&quot;: &quot;6d144e37-05cd-4b1d-bd6a-af9caf5d6da2&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;6d144e37-05cd-4b1d-bd6a-af9caf5d6da2&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.doLogin.returns(Rx.Observable.throw(errore));\napi._loginUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2cb6af96-dd0c-43f5-b2b7-4bc98907d069&quot;,
                        &quot;parentUUID&quot;: &quot;6d144e37-05cd-4b1d-bd6a-af9caf5d6da2&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;queryLambda&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e9be47bb-b3a8-40d2-a705-9f34c224d4db&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0d2db1ce-12e6-423b-972b-919d74a62c27&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c17cffc9-cbb0-4262-a727-5e3883ebd21d&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0258c1f8-cc77-47eb-adb8-de39de1ed05e&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7a71e6a7-3ef0-490e-96cb-82d6a0784c21&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ceb5e112-a980-4e35-9588-2de71d9e751d&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUserList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUserList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUserList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUserList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d0d6e44e-17fe-4e16-99d4-030961a873a7&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;eee55e6f-64f1-4cf9-b5c3-2a93ce2c937c&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;02528382-11e8-436f-a85a-883661b030ff&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d5a7ad63-3857-44ef-8e15-fcc681004fe2&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;50564916-2705-43b7-b023-723f28e84fca&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f5152a41-73c4-427a-86df-1264e6428b89&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f6601963-6104-4bc6-acd0-d60c4db4978f&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          };\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3920593b-60d8-4173-90c0-00fa78228d6d&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fe586a9b-9cfb-47e5-8060-efe54dcc13b2&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;179debc5-0ca0-411a-b89f-e6a063daea36&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c7d70b15-1a25-4000-a623-4adc4e0c8864&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;577517dd-c6b0-48e0-a430-b36a99b215f5&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;26702530-3986-48a5-8b1f-4337b93ff030&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3e21f911-412e-4774-81f8-6a3f6ac81405&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0c621c18-c68d-4171-ad1b-cc81b59732b6&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;62e5fe6d-ec9f-4f79-ad57-4563b2fcec3c&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2001,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c0ac97e5-01a4-459e-bf68-0ffb06b44d76&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;45163cfe-77e8-404f-a3f6-9e5d25852876&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7940c317-be8f-4d95-adc6-4ecf313a3d69&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n\texpect(response).have.property(&#x27;statusCode&#x27;, 200);\n\tdone();\n};\napi.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7d22f55f-8de9-411f-a188-5a3e159a15d3&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e9be47bb-b3a8-40d2-a705-9f34c224d4db&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0d2db1ce-12e6-423b-972b-919d74a62c27&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c17cffc9-cbb0-4262-a727-5e3883ebd21d&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0258c1f8-cc77-47eb-adb8-de39de1ed05e&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7a71e6a7-3ef0-490e-96cb-82d6a0784c21&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ceb5e112-a980-4e35-9588-2de71d9e751d&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUserList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUserList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUserList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUserList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d0d6e44e-17fe-4e16-99d4-030961a873a7&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;02528382-11e8-436f-a85a-883661b030ff&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d5a7ad63-3857-44ef-8e15-fcc681004fe2&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f5152a41-73c4-427a-86df-1264e6428b89&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f6601963-6104-4bc6-acd0-d60c4db4978f&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          };\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3920593b-60d8-4173-90c0-00fa78228d6d&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fe586a9b-9cfb-47e5-8060-efe54dcc13b2&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;179debc5-0ca0-411a-b89f-e6a063daea36&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c7d70b15-1a25-4000-a623-4adc4e0c8864&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;577517dd-c6b0-48e0-a430-b36a99b215f5&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;26702530-3986-48a5-8b1f-4337b93ff030&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3e21f911-412e-4774-81f8-6a3f6ac81405&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0c621c18-c68d-4171-ad1b-cc81b59732b6&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;62e5fe6d-ec9f-4f79-ad57-4563b2fcec3c&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;45163cfe-77e8-404f-a3f6-9e5d25852876&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7940c317-be8f-4d95-adc6-4ecf313a3d69&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n\texpect(response).have.property(&#x27;statusCode&#x27;, 200);\n\tdone();\n};\napi.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7d22f55f-8de9-411f-a188-5a3e159a15d3&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;eee55e6f-64f1-4cf9-b5c3-2a93ce2c937c&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;50564916-2705-43b7-b023-723f28e84fca&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2001,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c0ac97e5-01a4-459e-bf68-0ffb06b44d76&quot;,
                        &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 26,
                    &quot;totalPasses&quot;: 23,
                    &quot;totalFailures&quot;: 3,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: true,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 6028,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_removeRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6164b5aa-cbe7-4b99-8de0-527c13c04dfb&quot;,
                        &quot;parentUUID&quot;: &quot;7414a44c-cd25-4628-a939-b8c14ec206ef&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;7414a44c-cd25-4628-a939-b8c14ec206ef&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6164b5aa-cbe7-4b99-8de0-527c13c04dfb&quot;,
                        &quot;parentUUID&quot;: &quot;7414a44c-cd25-4628-a939-b8c14ec206ef&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 4,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_removeUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1366acd4-54ab-4fb3-b06b-7f7af4530b8b&quot;,
                        &quot;parentUUID&quot;: &quot;b204672a-88dc-4d7d-8a82-525ff9f20f21&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;b204672a-88dc-4d7d-8a82-525ff9f20f21&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1366acd4-54ab-4fb3-b06b-7f7af4530b8b&quot;,
                        &quot;parentUUID&quot;: &quot;b204672a-88dc-4d7d-8a82-525ff9f20f21&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_resetUserEnrollment&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.resetEnrollments.returns(Rx.Observable.throw(errore));\napi._resetUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0f3e30dd-da36-4ce0-b853-a7c78f26117f&quot;,
                        &quot;parentUUID&quot;: &quot;f7bbc907-3c7f-4875-bd3c-7368d7c20372&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;f7bbc907-3c7f-4875-bd3c-7368d7c20372&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.resetEnrollments.returns(Rx.Observable.throw(errore));\napi._resetUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0f3e30dd-da36-4ce0-b853-a7c78f26117f&quot;,
                        &quot;parentUUID&quot;: &quot;f7bbc907-3c7f-4875-bd3c-7368d7c20372&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_updateRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c008806e-3dae-4783-88c5-5108c410473c&quot;,
                        &quot;parentUUID&quot;: &quot;3f7a4964-796c-49fc-949b-6b5497f0e3e4&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;3f7a4964-796c-49fc-949b-6b5497f0e3e4&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c008806e-3dae-4783-88c5-5108c410473c&quot;,
                        &quot;parentUUID&quot;: &quot;3f7a4964-796c-49fc-949b-6b5497f0e3e4&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_updateUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;af55b24f-0b28-4a2b-a729-614aabe5eab4&quot;,
                        &quot;parentUUID&quot;: &quot;e0027bec-1f86-4e5a-b778-599fadef77be&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;e0027bec-1f86-4e5a-b778-599fadef77be&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;af55b24f-0b28-4a2b-a729-614aabe5eab4&quot;,
                        &quot;parentUUID&quot;: &quot;e0027bec-1f86-4e5a-b778-599fadef77be&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                &quot;uuid&quot;: &quot;c26a5695-5bac-49fa-b4a8-5b46d4ae36f0&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
            &quot;uuid&quot;: &quot;1245e438-a19b-41d0-bc37-e18e0353193e&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
        &quot;uuid&quot;: &quot;c7291b69-7336-4882-a74c-3252935f40bb&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Users&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;VocalLoginMicrosoftModule&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addEnrollment&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;21d74ef5-bcff-4ec0-97b8-066355ba0025&quot;,
                        &quot;parentUUID&quot;: &quot;22d0f8fc-99fc-4896-95d9-15117854e377&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;22d0f8fc-99fc-4896-95d9-15117854e377&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;21d74ef5-bcff-4ec0-97b8-066355ba0025&quot;,
                        &quot;parentUUID&quot;: &quot;22d0f8fc-99fc-4896-95d9-15117854e377&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;createUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9b0cd785-4086-44e0-8471-507707ae5934&quot;,
                        &quot;parentUUID&quot;: &quot;cd564caa-de06-4f4d-a345-925a55e76f54&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;cd564caa-de06-4f4d-a345-925a55e76f54&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9b0cd785-4086-44e0-8471-507707ae5934&quot;,
                        &quot;parentUUID&quot;: &quot;cd564caa-de06-4f4d-a345-925a55e76f54&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;deleteUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;46004f32-315f-4401-a645-01e1e64b87be&quot;,
                        &quot;parentUUID&quot;: &quot;b44f757b-06f8-4809-bad4-5a91709f600c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;b44f757b-06f8-4809-bad4-5a91709f600c&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;46004f32-315f-4401-a645-01e1e64b87be&quot;,
                        &quot;parentUUID&quot;: &quot;b44f757b-06f8-4809-bad4-5a91709f600c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;doLogin&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 8,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject({ \&quot;result\&quot; : \&quot;Reject\&quot; }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;115d1b30-517b-426a-a80c-b631e1a9cf59&quot;,
                        &quot;parentUUID&quot;: &quot;ec7f4af6-7c21-4174-9b25-39b2ee2a2907&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;ec7f4af6-7c21-4174-9b25-39b2ee2a2907&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 8,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject({ \&quot;result\&quot; : \&quot;Reject\&quot; }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;115d1b30-517b-426a-a80c-b631e1a9cf59&quot;,
                        &quot;parentUUID&quot;: &quot;ec7f4af6-7c21-4174-9b25-39b2ee2a2907&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 8,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4acf7496-49a4-4f64-abe5-a01a4bdf3966&quot;,
                        &quot;parentUUID&quot;: &quot;87ae3466-151b-4856-831e-b19f3b57e4b6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;87ae3466-151b-4856-831e-b19f3b57e4b6&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4acf7496-49a4-4f64-abe5-a01a4bdf3966&quot;,
                        &quot;parentUUID&quot;: &quot;87ae3466-151b-4856-831e-b19f3b57e4b6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n  {\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;02556f8d-d023-4d71-bb9c-3b5e96aeb5c0&quot;,
                        &quot;parentUUID&quot;: &quot;021dcfd3-efa1-4d09-a4f5-99e1e8770480&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;021dcfd3-efa1-4d09-a4f5-99e1e8770480&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n  {\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;02556f8d-d023-4d71-bb9c-3b5e96aeb5c0&quot;,
                        &quot;parentUUID&quot;: &quot;021dcfd3-efa1-4d09-a4f5-99e1e8770480&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;resetEnrollments&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule resetEnrollments Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.resetEnrollments().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a3e78da8-834c-433e-b156-03a4b4aa5a05&quot;,
                        &quot;parentUUID&quot;: &quot;dab3d1f9-ee78-4886-85c5-61147dc1fcb1&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;dab3d1f9-ee78-4886-85c5-61147dc1fcb1&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule resetEnrollments Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.resetEnrollments().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a3e78da8-834c-433e-b156-03a4b4aa5a05&quot;,
                        &quot;parentUUID&quot;: &quot;dab3d1f9-ee78-4886-85c5-61147dc1fcb1&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                &quot;uuid&quot;: &quot;c1ab16fd-e4d7-478e-8d6c-4e5ffd951049&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
            &quot;uuid&quot;: &quot;80ebd517-8a4e-442a-8090-1b5c94bf4f8a&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
        &quot;uuid&quot;: &quot;7f525469-eede-4ba4-989e-1e5643759d87&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      }
    ],
    &quot;tests&quot;: [],
    &quot;pending&quot;: [],
    &quot;root&quot;: true,
    &quot;_timeout&quot;: 2000,
    &quot;uuid&quot;: &quot;2cd99c5a-fb80-4f48-8e4e-e92df1081994&quot;,
    &quot;fullFile&quot;: &quot;&quot;,
    &quot;file&quot;: &quot;&quot;,
    &quot;passes&quot;: [],
    &quot;failures&quot;: [],
    &quot;skipped&quot;: [],
    &quot;hasTests&quot;: false,
    &quot;hasSuites&quot;: true,
    &quot;totalTests&quot;: 0,
    &quot;totalPasses&quot;: 0,
    &quot;totalFailures&quot;: 0,
    &quot;totalPending&quot;: 0,
    &quot;totalSkipped&quot;: 0,
    &quot;hasPasses&quot;: false,
    &quot;hasFailures&quot;: false,
    &quot;hasPending&quot;: false,
    &quot;hasSkipped&quot;: false,
    &quot;duration&quot;: 0,
    &quot;rootEmpty&quot;: true
  },
  &quot;allTests&quot;: [
    {
      &quot;title&quot;: &quot;La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;TypeError: service.webhook is not a function\n  at Context.&lt;anonymous&gt; (src\\test\\test_AdministrationWebhookService.js:72:17)\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2d5a2027-bd8a-4eea-b514-7611333dc194&quot;,
      &quot;parentUUID&quot;: &quot;16aae3bd-d389-4ce8-be37-12bb842af39e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;TypeError: service.webhook is not a function\n  at Context.&lt;anonymous&gt; (src\\test\\test_AdministrationWebhookService.js:78:17)\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;47923f23-8044-4ac7-84a5-5aa854f730e5&quot;,
      &quot;parentUUID&quot;: &quot;16aae3bd-d389-4ce8-be37-12bb842af39e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;323df3b3-ed51-4e2a-9304-88849a3d0e5b&quot;,
      &quot;parentUUID&quot;: &quot;9594918e-0827-4c03-b74d-20002a26911a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;06edb568-7970-48b4-a45c-976077ef2d71&quot;,
      &quot;parentUUID&quot;: &quot;9594918e-0827-4c03-b74d-20002a26911a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getAgent Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7f19c384-de7b-4c99-abbf-36b6c8e8234d&quot;,
      &quot;parentUUID&quot;: &quot;3a926ecc-ddc9-4e67-aedb-76dda206b610&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getAgent Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = agents.getAgent(&#x27;mock_name&#x27;);\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a9f94659-f673-41e2-8a02-a82ddcf1ed14&quot;,
      &quot;parentUUID&quot;: &quot;3a926ecc-ddc9-4e67-aedb-76dda206b610&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;2&#x27;});\ndynamo_client.scan.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4d1d717f-fcbe-478e-a381-5b53601ada0b&quot;,
      &quot;parentUUID&quot;: &quot;96e4d162-f61e-4af5-8cd6-f83f663798d0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getAgentList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e08ca80c-2ca7-47d1-b513-6971eabf39b7&quot;,
      &quot;parentUUID&quot;: &quot;96e4d162-f61e-4af5-8cd6-f83f663798d0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeAgent Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\&quot;error removing rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d298e2be-44aa-4561-aca8-d83922a6ef69&quot;,
      &quot;parentUUID&quot;: &quot;ced7a107-e669-44c0-9209-fecc09ded95d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeAgent Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\&quot;success\&quot;});\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;92dabb8f-ebe5-4e8d-852c-a00784491d2e&quot;,
      &quot;parentUUID&quot;: &quot;ced7a107-e669-44c0-9209-fecc09ded95d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateAgent Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 5,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ef631d93-7562-4059-94e4-4388897b154d&quot;,
      &quot;parentUUID&quot;: &quot;e0d8e836-0862-4359-9b37-851ca825eb03&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateAgent Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c7b7d4c3-fefb-47df-95ef-58007d409a92&quot;,
      &quot;parentUUID&quot;: &quot;e0d8e836-0862-4359-9b37-851ca825eb03&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
      &quot;fullTitle&quot;: &quot;query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;29b5ccf9-c97a-42bb-8779-81157c19139a&quot;,
      &quot;parentUUID&quot;: &quot;802aa6cf-a946-4742-aa12-eb6b596c6a8c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
      &quot;fullTitle&quot;: &quot;query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3e358c25-16ae-48bd-a1a0-b66dc7bd35ee&quot;,
      &quot;parentUUID&quot;: &quot;802aa6cf-a946-4742-aa12-eb6b596c6a8c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \&quot;Requested resource not found\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5668bdfd-c977-4457-8117-551210a0aeac&quot;,
      &quot;parentUUID&quot;: &quot;6559be4c-fb2f-467f-a445-405ec898518e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7a38e270-a340-4edf-9fa6-9f62384fce9c&quot;,
      &quot;parentUUID&quot;: &quot;6559be4c-fb2f-467f-a445-405ec898518e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \&quot;error adding message\&quot; });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;368ca2cb-2c11-46ce-914b-22278d5221c2&quot;,
      &quot;parentUUID&quot;: &quot;fda16baa-e7db-45f3-b5d5-1e0b0e6e3cc6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bc373be5-705e-46cc-8c7a-b0409ac0dac0&quot;,
      &quot;parentUUID&quot;: &quot;fda16baa-e7db-45f3-b5d5-1e0b0e6e3cc6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \&quot;error downloading conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4f3caf75-bc54-4edc-9b6f-8ff2f19cd364&quot;,
      &quot;parentUUID&quot;: &quot;d7852712-1502-476b-a089-e33ffd23803a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getConversation Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;157cb40b-76b0-4ffa-914e-2a4561400385&quot;,
      &quot;parentUUID&quot;: &quot;d7852712-1502-476b-a089-e33ffd23803a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;deaca613-014c-4192-b897-34fe8a71ecbe&quot;,
      &quot;parentUUID&quot;: &quot;62d98a05-f03c-45e4-8e33-77916f9a4cdf&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getConversationList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5b128857-9589-48f7-9090-1d3446fa8623&quot;,
      &quot;parentUUID&quot;: &quot;62d98a05-f03c-45e4-8e33-77916f9a4cdf&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6edf9515-761a-4cbd-bfd6-48de37ad0e83&quot;,
      &quot;parentUUID&quot;: &quot;c55533c5-9c61-45c9-a569-b29fef9e08e4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c352c821-931d-42fa-b5d3-2b541cf09beb&quot;,
      &quot;parentUUID&quot;: &quot;c55533c5-9c61-45c9-a569-b29fef9e08e4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 7,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;body.result.action = &#x27;user.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;admin&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;809d7d6d-f37c-4b0e-bae0-e2254b96a1ea&quot;,
      &quot;parentUUID&quot;: &quot;739deb20-8b18-4cdb-8a8d-9ddb1f047c3b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;body.result.action = &#x27;guest.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;, company : \&quot;Google\&quot;}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;welcome&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5a70baa2-af0b-4740-809d-fcdac967b827&quot;,
      &quot;parentUUID&quot;: &quot;739deb20-8b18-4cdb-8a8d-9ddb1f047c3b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;expect(obs.next.bind(obs)).to.throw();&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cc60460d-6efe-4cc6-a304-41eab39865e1&quot;,
      &quot;parentUUID&quot;: &quot;b312ec6d-2e5f-4bd2-a195-33ee58376e0b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;753dbb52-26d3-4f90-b1f6-70561c4a8a3b&quot;,
      &quot;parentUUID&quot;: &quot;0278ab44-e86f-4644-8549-af97c2e6a21e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addGuest Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addGuest(&#x27;mauro&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8c5fba9d-c2c2-463b-92dc-3ec00fcbb05a&quot;,
      &quot;parentUUID&quot;: &quot;0278ab44-e86f-4644-8549-af97c2e6a21e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \&quot;error getting data\&quot; });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b262d94a-d279-4046-9e36-43a0a6ecb5a8&quot;,
      &quot;parentUUID&quot;: &quot;c1c6188c-beb0-4712-a42f-e5a6e951d9d0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getGuest Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \&quot;Mauro\&quot;);\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\&quot;Zero12\&quot;);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;60c965d0-1766-48ef-bb55-6f004ab99351&quot;,
      &quot;parentUUID&quot;: &quot;c1c6188c-beb0-4712-a42f-e5a6e951d9d0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }], LastEvaluatedKey: &#x27;Luca&#x27;});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8776d3d8-1043-42f1-8b31-5b814cd33129&quot;,
      &quot;parentUUID&quot;: &quot;0eccf4f9-5b92-4dec-acfb-11ea3cbfef31&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getGuestList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1fef49e6-822a-42d7-b42b-8826debe5cf0&quot;,
      &quot;parentUUID&quot;: &quot;0eccf4f9-5b92-4dec-acfb-11ea3cbfef31&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing guest\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8d25fdf0-1be4-4750-ac84-15b3e8ba4888&quot;,
      &quot;parentUUID&quot;: &quot;9f7bec2a-b42d-425b-bb2f-a1fb2021a9fc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeGuest Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e86c864f-323d-451d-9ad0-047bd5ce7dda&quot;,
      &quot;parentUUID&quot;: &quot;9f7bec2a-b42d-425b-bb2f-a1fb2021a9fc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating guest\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3371d654-5c3b-42d2-a4ab-537d8da7f4c3&quot;,
      &quot;parentUUID&quot;: &quot;075a1914-526b-4c1e-b946-ac9bc2bfbcb1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6670ef9b-b7da-4ea5-bd1c-3ef6f8f68588&quot;,
      &quot;parentUUID&quot;: &quot;075a1914-526b-4c1e-b946-ac9bc2bfbcb1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;544e1ed9-7c43-41ee-963c-c821171d7fc7&quot;,
      &quot;parentUUID&quot;: &quot;aaa121bd-0faf-4ccd-857d-acabe82fb00d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;580adbdf-8ace-47a3-ab2d-40cff2ba6a99&quot;,
      &quot;parentUUID&quot;: &quot;aaa121bd-0faf-4ccd-857d-acabe82fb00d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;addMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.addMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;67b8b705-9b39-436d-876d-fc1258636321&quot;,
      &quot;parentUUID&quot;: &quot;9620d65a-bd4b-4e12-ba9f-cf08728b82cf&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
      &quot;fullTitle&quot;: &quot;getMember Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t&#x27;ok&#x27;: true,\n\t&#x27;user&#x27;:\n\t{\n\t\t&#x27;id&#x27;: &#x27;U023BECGF&#x27;,\n\t\t&#x27;name&#x27;: &#x27;bobby&#x27;,\n\t\t&#x27;deleted&#x27;: false,\n\t\t&#x27;color&#x27;: &#x27;9f69e7&#x27;,\n\t\t&#x27;profile&#x27;:\n\t\t{\n\t\t\t&#x27;avatar_hash&#x27;: &#x27;ge3b51ca72de&#x27;,\n\t\t\t&#x27;current_status&#x27;: &#x27;:mountain_railway: riding a train&#x27;,\n\t\t\t&#x27;first_name&#x27;: &#x27;Bobby&#x27;,\n\t\t\t&#x27;last_name&#x27;: &#x27;Tables&#x27;,\n\t\t\t&#x27;real_name&#x27;: &#x27;Bobby Tables&#x27;,\n\t\t\t&#x27;email&#x27;: &#x27;bobby@slack.com&#x27;,\n\t\t\t&#x27;skype&#x27;: &#x27;my-skype-name&#x27;,\n\t\t\t&#x27;phone&#x27;: &#x27;+1 (123) 456 7890&#x27;\n\t\t},\n\t\t&#x27;is_admin&#x27;: true,\n\t\t&#x27;is_owner&#x27;: true,\n\t\t&#x27;updated&#x27;: 1490054400,\n\t\t&#x27;has_2fa&#x27;: true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;375c8d11-bc06-4ac8-8244-21c9fbfc83c3&quot;,
      &quot;parentUUID&quot;: &quot;13b7d5d4-e1cc-4c51-8bc1-c7c42a6cf4ef&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getMember Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1fad7301-530a-4f1b-aee9-2f7a7858bd77&quot;,
      &quot;parentUUID&quot;: &quot;13b7d5d4-e1cc-4c51-8bc1-c7c42a6cf4ef&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
      &quot;fullTitle&quot;: &quot;getMemberList L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\&quot;ok\&quot;: true,\n\t\&quot;members\&quot;:\n\t[\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECGF\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;mauro\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Mauro Bocciofilo\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t},\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECLL\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;bobby\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;,\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6a4197ec-c29f-4653-982b-2731b5650a78&quot;,
      &quot;parentUUID&quot;: &quot;632e1d25-798f-496d-904a-16c4abd01939&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getMemberList Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f535844e-2430-47fc-b33d-d47b15b1b096&quot;,
      &quot;parentUUID&quot;: &quot;632e1d25-798f-496d-904a-16c4abd01939&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;removeMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.removeMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b3e3371d-9288-4bdd-8dd7-4592988c5cbb&quot;,
      &quot;parentUUID&quot;: &quot;262f348a-b96e-47bf-b040-a54baf6a0849&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;updateMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.updateMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;63451431-bb02-4a30-8895-0fd1a19a8473&quot;,
      &quot;parentUUID&quot;: &quot;172fd663-3c3c-4e85-9e46-26a3184907bc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(&#x27;errore&#x27;);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n  done();\n}&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;193b13c0-c7fb-4e69-889f-940987b019db&quot;,
      &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields(&#x27;errore&#x27;);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2156a6ac-1c2b-4366-ba8e-418bcff81951&quot;,
      &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(&#x27;errore&#x27;);\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d8c15434-9efe-4724-a587-716172c2bfa7&quot;,
      &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 200);\n  done();\n}&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7342ee25-ef4a-44f6-9843-7b66f537919d&quot;,
      &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(&#x27;errore&#x27;);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ae0ceb3d-f4da-4b11-ba0d-aa27a37595c1&quot;,
      &quot;parentUUID&quot;: &quot;b82d5dc7-3536-4ab6-9f33-73fdef730387&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;766cab3f-44ee-47b9-a7ec-306059516b65&quot;,
      &quot;parentUUID&quot;: &quot;b82d5dc7-3536-4ab6-9f33-73fdef730387&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\n\nexpect(context.succeed.callCount).to.equal(1);\t\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cdcf8f35-5178-4b82-9894-0b963eca8740&quot;,
      &quot;parentUUID&quot;: &quot;b82d5dc7-3536-4ab6-9f33-73fdef730387&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare complete_cb&quot;,
      &quot;fullTitle&quot;: &quot;complete Deve chiamare complete_cb&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \&quot;il callback di complete non è stato chiamato esattamente una volta.\&quot;).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;164b4e50-d696-451e-860c-72375fd7a329&quot;,
      &quot;parentUUID&quot;: &quot;71a63949-b02a-45da-9d82-bb3cdae43e28&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;complete Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b4de0c6d-5cf4-4313-993b-3189d5ec1724&quot;,
      &quot;parentUUID&quot;: &quot;71a63949-b02a-45da-9d82-bb3cdae43e28&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;complete Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f48a24c6-305f-45a2-a75f-1bbd55fc4a41&quot;,
      &quot;parentUUID&quot;: &quot;71a63949-b02a-45da-9d82-bb3cdae43e28&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare error_cb&quot;,
      &quot;fullTitle&quot;: &quot;error Deve chiamare error_cb&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;da3569fc-a24e-441b-a2f4-8829e6eec349&quot;,
      &quot;parentUUID&quot;: &quot;204d1bdd-22c0-4850-94ab-0c82770bd4b4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;error Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onError(success);\nobs.pause();\nobs.error(&#x27;errore&#x27;);\n        expect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;65e1072f-f459-42dc-8f7c-9db51ff6fc20&quot;,
      &quot;parentUUID&quot;: &quot;204d1bdd-22c0-4850-94ab-0c82770bd4b4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;error Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;13860a7e-713e-449d-94c9-71a7e65b7b4f&quot;,
      &quot;parentUUID&quot;: &quot;204d1bdd-22c0-4850-94ab-0c82770bd4b4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal(&#x27;data&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8cb58066-4208-4eac-90c2-ee97394123bb&quot;,
      &quot;parentUUID&quot;: &quot;ba3d019e-1ebb-4126-b37b-87886bf6b99f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;next Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.pause();\nobs.next(&#x27;Function called&#x27;);\nexpect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3a79d872-a40c-4c3c-8e5b-dc6efc2b3252&quot;,
      &quot;parentUUID&quot;: &quot;ba3d019e-1ebb-4126-b37b-87886bf6b99f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next(&#x27;other data&#x27;);\nexpect(success.callCount).to.equal(2);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bf55b7ae-26fa-4b00-9585-a3fdf3edbb10&quot;,
      &quot;parentUUID&quot;: &quot;ba3d019e-1ebb-4126-b37b-87886bf6b99f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;934e4d87-01be-444f-acf3-15460f34536a&quot;,
      &quot;parentUUID&quot;: &quot;bf1363d3-41b8-4990-a222-6f3a85fdfef2&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;503cfc1b-beba-4010-8279-0dcd837d9f20&quot;,
      &quot;parentUUID&quot;: &quot;bf1363d3-41b8-4990-a222-6f3a85fdfef2&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;21dc619c-91e6-40c6-ad11-1442868ac06e&quot;,
      &quot;parentUUID&quot;: &quot;05b253d1-4b06-475d-8369-e3533b9fcadc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;345df0f6-fa34-4840-94b1-b70d9eb5d099&quot;,
      &quot;parentUUID&quot;: &quot;05b253d1-4b06-475d-8369-e3533b9fcadc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d4a87f6a-2a70-4e9c-8324-3218f7b80b41&quot;,
      &quot;parentUUID&quot;: &quot;796a2f4e-c5ba-4b56-8e5f-ad0836ca3af1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;03a52eed-d228-4ce0-ba73-bf66dd2c67eb&quot;,
      &quot;parentUUID&quot;: &quot;796a2f4e-c5ba-4b56-8e5f-ad0836ca3af1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;//da definire&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;85e87854-923e-4963-bc32-c5b333ff66bb&quot;,
      &quot;parentUUID&quot;: &quot;796a2f4e-c5ba-4b56-8e5f-ad0836ca3af1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeRule Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bced9eb7-0935-4d60-9908-f9ccfb02dead&quot;,
      &quot;parentUUID&quot;: &quot;a02b0b04-9bbe-4cd2-bf7b-17ecc041275e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeRule Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e3e011d3-501d-46f6-9b90-1cdb72936702&quot;,
      &quot;parentUUID&quot;: &quot;a02b0b04-9bbe-4cd2-bf7b-17ecc041275e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5c7da28f-01a5-43d5-b23d-da7e128d55a8&quot;,
      &quot;parentUUID&quot;: &quot;3430135a-ac18-4acd-88fb-01bd4659c0b5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;447686e3-caa4-44c9-ad92-ec66ddf71e3d&quot;,
      &quot;parentUUID&quot;: &quot;3430135a-ac18-4acd-88fb-01bd4659c0b5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \&quot;\&quot;};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1674d18a-5a83-4caf-8846-12583e8cd6c0&quot;,
      &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;de153504-a563-4490-a27b-661ae53e130a&quot;,
      &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6b942434-fc86-4f3c-9e37-9538706a122d&quot;,
      &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;24d0af1b-2539-48ca-8e56-1ac8af8f5f8c&quot;,
      &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;361ad7bf-ee31-49ea-bf21-9bc46909f363&quot;,
      &quot;parentUUID&quot;: &quot;78918e59-adcc-4e96-93fd-f9fa31c3ead3&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;70f32ba1-df22-443b-9957-30963e0ca8b2&quot;,
      &quot;parentUUID&quot;: &quot;78918e59-adcc-4e96-93fd-f9fa31c3ead3&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);\n};&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;80eed219-b4c0-4c48-9cab-b2d5962fcae1&quot;,
      &quot;parentUUID&quot;: &quot;78918e59-adcc-4e96-93fd-f9fa31c3ead3&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;dd96d9e9-73ad-4b34-8c50-913c43728867&quot;,
      &quot;parentUUID&quot;: &quot;87f5b940-cacc-47f6-a220-04c266d28f86&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8c54c567-b5e3-4e35-b84c-e47a0f9f381b&quot;,
      &quot;parentUUID&quot;: &quot;87f5b940-cacc-47f6-a220-04c266d28f86&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;749eb433-b190-4ec6-9811-771631eb928d&quot;,
      &quot;parentUUID&quot;: &quot;87f5b940-cacc-47f6-a220-04c266d28f86&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;24a91b29-1fb3-456d-89a1-b84f022bbe85&quot;,
      &quot;parentUUID&quot;: &quot;6c012c69-dca6-4f4e-a7bf-3bb04e611dbb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;02c0b11a-ac3d-4d15-9285-a93c10989d27&quot;,
      &quot;parentUUID&quot;: &quot;6c012c69-dca6-4f4e-a7bf-3bb04e611dbb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;de0c99e0-dc0b-4bb3-b240-aa39ffb3253f&quot;,
      &quot;parentUUID&quot;: &quot;35f3fa36-00bf-4d8b-bd5f-d1a6a924ef8d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a341108f-a681-4925-be66-f3b2e866edd0&quot;,
      &quot;parentUUID&quot;: &quot;35f3fa36-00bf-4d8b-bd5f-d1a6a924ef8d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;707839fe-6576-4a1f-bb39-718966de647a&quot;,
      &quot;parentUUID&quot;: &quot;f359a61f-53e0-4849-9350-f676a79cdc49&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \&quot;\&quot; , body: \&quot;\&quot;};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;61296071-82c7-481b-bb79-aa83e584e793&quot;,
      &quot;parentUUID&quot;: &quot;f359a61f-53e0-4849-9350-f676a79cdc49&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5b610349-3571-45f4-8a04-a13584e3c7b9&quot;,
      &quot;parentUUID&quot;: &quot;f359a61f-53e0-4849-9350-f676a79cdc49&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
      &quot;fullTitle&quot;: &quot;speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3c0189b2-57ed-4624-b102-f0f3368eca31&quot;,
      &quot;parentUUID&quot;: &quot;c2a6a27f-970f-4b54-aac1-55dab2da64e9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5bac7e4d-6ace-419b-b143-e9926c97fd91&quot;,
      &quot;parentUUID&quot;: &quot;91b18b66-4766-489b-8b7f-13f9944c23f4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;42f93b22-bdc4-4875-b595-5023c1452e15&quot;,
      &quot;parentUUID&quot;: &quot;91b18b66-4766-489b-8b7f-13f9944c23f4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getTask Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTask(&#x27;mock_type&#x27;).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3cfd4d56-7c37-4a09-aad0-501abbaa9130&quot;,
      &quot;parentUUID&quot;: &quot;099c502d-b5e9-45d7-8547-25e35212d3d8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getTask Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = tasks.getTask(&#x27;mock_type&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cec36c77-a3a1-478d-8ef1-e9188d14c3cf&quot;,
      &quot;parentUUID&quot;: &quot;099c502d-b5e9-45d7-8547-25e35212d3d8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \&quot;mock_type3\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b7ea70d0-04f4-4cf0-928b-61b8ce7b6a55&quot;,
      &quot;parentUUID&quot;: &quot;1b6a918c-e231-43ba-8b1e-c2745b127421&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8f938647-2fef-4dbb-a072-6318ef9cad47&quot;,
      &quot;parentUUID&quot;: &quot;1b6a918c-e231-43ba-8b1e-c2745b127421&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1243fdb4-4787-4a29-b7ad-282b21e87191&quot;,
      &quot;parentUUID&quot;: &quot;ddd2deae-dc67-4fa1-acbb-783f728a0c68&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;659e1a19-d564-46bf-b881-4dc2187ad8fc&quot;,
      &quot;parentUUID&quot;: &quot;ddd2deae-dc67-4fa1-acbb-783f728a0c68&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8504f966-68d3-4836-81ad-ad5cada735c1&quot;,
      &quot;parentUUID&quot;: &quot;5fa06823-14a6-401d-b42f-033e00297dcb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;28aa9f5a-915d-4b3a-acaa-dfaec7c73215&quot;,
      &quot;parentUUID&quot;: &quot;5fa06823-14a6-401d-b42f-033e00297dcb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\&quot;Requested resource not found\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2433a75a-55dc-4c45-8002-333e240b3fed&quot;,
      &quot;parentUUID&quot;: &quot;6fac0e24-fc7b-4864-a248-232b6ca6035b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;71d8a601-23b5-4b1c-aab0-15532fba3a8c&quot;,
      &quot;parentUUID&quot;: &quot;6fac0e24-fc7b-4864-a248-232b6ca6035b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8e647fbb-14a2-4528-a7ea-0cce4231b29a&quot;,
      &quot;parentUUID&quot;: &quot;bcf95ab7-ada2-4f61-ab33-f4b854eb1061&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = users.getUser(&#x27;mou&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\n\t\t\t\t\texpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;71b1ff63-6baf-48f8-a201-3fd68b3fcb3a&quot;,
      &quot;parentUUID&quot;: &quot;bcf95ab7-ada2-4f61-ab33-f4b854eb1061&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}], LastEvaluatedKey: &#x27;marco&#x27;});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a3e8042e-1b92-41b5-97a5-34db559918b1&quot;,
      &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5a305065-883c-4efc-957a-001b810df4a2&quot;,
      &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a249c586-c79d-4f2b-abf2-acd05ccd7b26&quot;,
      &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;,\n\tslack_channel: &#x27;channel&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name and slack_channel = :slack_channel&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:slack_channel&#x27;, &#x27;channel&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f776324b-dd8c-4398-b072-c422452452ba&quot;,
      &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeUser Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \&quot;error removing user\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;70ecaf17-d8cc-4dcc-8e66-fbc752b593e0&quot;,
      &quot;parentUUID&quot;: &quot;ea0ad7ca-3878-41be-88fc-70e538015e5b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;removeUser Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;24cd4871-5284-4146-9984-f989a46d6967&quot;,
      &quot;parentUUID&quot;: &quot;ea0ad7ca-3878-41be-88fc-70e538015e5b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \&quot;error updating user\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;12dec5a4-3114-4254-8c1b-4de61a05c51c&quot;,
      &quot;parentUUID&quot;: &quot;516606e8-a45a-4765-a379-77ad44f54277&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cf1757ff-525d-4351-9cc1-af9d61d15f5d&quot;,
      &quot;parentUUID&quot;: &quot;516606e8-a45a-4765-a379-77ad44f54277&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;584e0bde-9cbe-474b-9b6f-f910cb839772&quot;,
      &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4c7de136-9b70-4865-a84b-e86ac58eb34c&quot;,
      &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \&quot;\&quot; };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;dcf6e942-f678-4f00-8a8e-8bf44321913c&quot;,
      &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ffc49c2b-e8f8-4489-86d6-d22d9e60a775&quot;,
      &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;527798db-4117-4d43-9e24-bb78024275f7&quot;,
      &quot;parentUUID&quot;: &quot;542ca549-4e45-4cb6-852b-c7889f87c2af&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2af69d0c-4bea-4975-87ce-4e145481423d&quot;,
      &quot;parentUUID&quot;: &quot;542ca549-4e45-4cb6-852b-c7889f87c2af&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { pathParameters: { username: &#x27;pippo&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9e0ac3ba-43b5-48b4-a156-aacacd78c0a9&quot;,
      &quot;parentUUID&quot;: &quot;542ca549-4e45-4cb6-852b-c7889f87c2af&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9ba417d8-2bba-4ca1-a11c-f523c4794c8d&quot;,
      &quot;parentUUID&quot;: &quot;a4782cf0-880d-486a-91e3-c1251b9691d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c4fa0022-1aba-435b-bbe9-92af173cecf2&quot;,
      &quot;parentUUID&quot;: &quot;a4782cf0-880d-486a-91e3-c1251b9691d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\n          let ev = { pathParameters: { username: &#x27;pippo&#x27;} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;13fb6b81-085c-4919-a6aa-c34c43a07112&quot;,
      &quot;parentUUID&quot;: &quot;a4782cf0-880d-486a-91e3-c1251b9691d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;70819cd4-26ac-494c-9a6a-364c9f708a56&quot;,
      &quot;parentUUID&quot;: &quot;d98c2df1-5efa-4cf8-8328-5fafa3b8e9fe&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ users: [{ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;427574cc-a0b2-4674-85ed-98eb964196f4&quot;,
      &quot;parentUUID&quot;: &quot;d98c2df1-5efa-4cf8-8328-5fafa3b8e9fe&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;332976fa-5130-40b7-8f05-0453f492dafe&quot;,
      &quot;parentUUID&quot;: &quot;52ba070d-3a13-444f-985d-5b832579633e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;61c99b34-10db-4968-8d2e-7717a326d5e6&quot;,
      &quot;parentUUID&quot;: &quot;52ba070d-3a13-444f-985d-5b832579633e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = { pathParameters: \&quot;\&quot;, body: \&quot;\&quot; };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4f17a565-39dc-45d1-9026-de65d6850c53&quot;,
      &quot;parentUUID&quot;: &quot;52ba070d-3a13-444f-985d-5b832579633e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;445aa1eb-908a-4bc9-a1e1-fa54c2a5caa9&quot;,
      &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fdde9ab2-e797-4b53-8eb3-532a66ae2a8b&quot;,
      &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;msg&#x27;: &#x27;error getting guest&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5adb5032-e2b4-48f4-9355-909020f3b1da&quot;,
      &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ &#x27;msg&#x27;: &#x27;error adding conversation&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;22ecbdd2-e85b-4695-bd0c-2a8d97a51537&quot;,
      &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;type&#x27;: &#x27;example&#x27; });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;459505e4-3403-4fcb-8c5d-34125494bd74&quot;,
      &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
      &quot;fullTitle&quot;: &quot;query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith(&#x27;test&#x27;));\n\tlet result = context.succeed.getCall(0).args[0];\n            expect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n            done();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;226cf9e1-13b9-4856-a032-040122b5641b&quot;,
      &quot;parentUUID&quot;: &quot;1452e88c-5d82-48e6-a29a-37bcfef2191c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
      &quot;fullTitle&quot;: &quot;query Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.reject(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n            done();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9e8e83cb-5035-4258-8a63-7e375bf0da82&quot;,
      &quot;parentUUID&quot;: &quot;1452e88c-5d82-48e6-a29a-37bcfef2191c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;29caa929-a0f0-4dde-b8c0-65472fc4cc40&quot;,
      &quot;parentUUID&quot;: &quot;9daec29c-268a-4c98-88ed-d54afc57c5b9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9ec12e84-282b-4290-8c1d-08f49a54fd3a&quot;,
      &quot;parentUUID&quot;: &quot;9f7c5468-bd18-461e-aec0-24783382a75b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.addEnrollment.returns(Rx.Observable.throw(errore));\napi._addUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;55d2c52c-f810-4ac8-ac11-a6cb50c8c8e2&quot;,
      &quot;parentUUID&quot;: &quot;db0e07f5-b977-44d4-bdfd-cfa75e777175&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;66bcaf1d-f8e5-4520-a7dc-8ab14b474f47&quot;,
      &quot;parentUUID&quot;: &quot;b6a175e2-678e-438c-88ba-ea67fc2550de&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c4da9def-8688-417c-9f3a-38db852bbf48&quot;,
      &quot;parentUUID&quot;: &quot;8623eed6-bd3a-408a-bdab-618a75deccec&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3bcc2dbc-0f81-45c2-bd2b-06227ec1a581&quot;,
      &quot;parentUUID&quot;: &quot;157be1f0-5ab2-4cb4-90d1-f99ffe481390&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e03f0367-9493-4836-9fcc-fe7f2684c069&quot;,
      &quot;parentUUID&quot;: &quot;29bcb080-578d-44b7-9aa0-7ad7c49addfd&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
      &quot;fullTitle&quot;: &quot;_loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.doLogin.returns(Rx.Observable.throw(errore));\napi._loginUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2cb6af96-dd0c-43f5-b2b7-4bc98907d069&quot;,
      &quot;parentUUID&quot;: &quot;6d144e37-05cd-4b1d-bd6a-af9caf5d6da2&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e9be47bb-b3a8-40d2-a705-9f34c224d4db&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0d2db1ce-12e6-423b-972b-919d74a62c27&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c17cffc9-cbb0-4262-a727-5e3883ebd21d&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0258c1f8-cc77-47eb-adb8-de39de1ed05e&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7a71e6a7-3ef0-490e-96cb-82d6a0784c21&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ceb5e112-a980-4e35-9588-2de71d9e751d&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUserList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUserList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUserList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUserList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d0d6e44e-17fe-4e16-99d4-030961a873a7&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;eee55e6f-64f1-4cf9-b5c3-2a93ce2c937c&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;02528382-11e8-436f-a85a-883661b030ff&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d5a7ad63-3857-44ef-8e15-fcc681004fe2&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;50564916-2705-43b7-b023-723f28e84fca&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f5152a41-73c4-427a-86df-1264e6428b89&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f6601963-6104-4bc6-acd0-d60c4db4978f&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          };\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3920593b-60d8-4173-90c0-00fa78228d6d&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fe586a9b-9cfb-47e5-8060-efe54dcc13b2&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;179debc5-0ca0-411a-b89f-e6a063daea36&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c7d70b15-1a25-4000-a623-4adc4e0c8864&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;577517dd-c6b0-48e0-a430-b36a99b215f5&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;26702530-3986-48a5-8b1f-4337b93ff030&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3e21f911-412e-4774-81f8-6a3f6ac81405&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0c621c18-c68d-4171-ad1b-cc81b59732b6&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;62e5fe6d-ec9f-4f79-ad57-4563b2fcec3c&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2001,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c0ac97e5-01a4-459e-bf68-0ffb06b44d76&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;45163cfe-77e8-404f-a3f6-9e5d25852876&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7940c317-be8f-4d95-adc6-4ecf313a3d69&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n\texpect(response).have.property(&#x27;statusCode&#x27;, 200);\n\tdone();\n};\napi.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7d22f55f-8de9-411f-a188-5a3e159a15d3&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6164b5aa-cbe7-4b99-8de0-527c13c04dfb&quot;,
      &quot;parentUUID&quot;: &quot;7414a44c-cd25-4628-a939-b8c14ec206ef&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1366acd4-54ab-4fb3-b06b-7f7af4530b8b&quot;,
      &quot;parentUUID&quot;: &quot;b204672a-88dc-4d7d-8a82-525ff9f20f21&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.resetEnrollments.returns(Rx.Observable.throw(errore));\napi._resetUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0f3e30dd-da36-4ce0-b853-a7c78f26117f&quot;,
      &quot;parentUUID&quot;: &quot;f7bbc907-3c7f-4875-bd3c-7368d7c20372&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c008806e-3dae-4783-88c5-5108c410473c&quot;,
      &quot;parentUUID&quot;: &quot;3f7a4964-796c-49fc-949b-6b5497f0e3e4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;af55b24f-0b28-4a2b-a729-614aabe5eab4&quot;,
      &quot;parentUUID&quot;: &quot;e0027bec-1f86-4e5a-b778-599fadef77be&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;21d74ef5-bcff-4ec0-97b8-066355ba0025&quot;,
      &quot;parentUUID&quot;: &quot;22d0f8fc-99fc-4896-95d9-15117854e377&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9b0cd785-4086-44e0-8471-507707ae5934&quot;,
      &quot;parentUUID&quot;: &quot;cd564caa-de06-4f4d-a345-925a55e76f54&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;46004f32-315f-4401-a645-01e1e64b87be&quot;,
      &quot;parentUUID&quot;: &quot;b44f757b-06f8-4809-bad4-5a91709f600c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 8,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject({ \&quot;result\&quot; : \&quot;Reject\&quot; }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;115d1b30-517b-426a-a80c-b631e1a9cf59&quot;,
      &quot;parentUUID&quot;: &quot;ec7f4af6-7c21-4174-9b25-39b2ee2a2907&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4acf7496-49a4-4f64-abe5-a01a4bdf3966&quot;,
      &quot;parentUUID&quot;: &quot;87ae3466-151b-4856-831e-b19f3b57e4b6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n  {\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;02556f8d-d023-4d71-bb9c-3b5e96aeb5c0&quot;,
      &quot;parentUUID&quot;: &quot;021dcfd3-efa1-4d09-a4f5-99e1e8770480&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;resetEnrollments Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.resetEnrollments().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a3e78da8-834c-433e-b156-03a4b4aa5a05&quot;,
      &quot;parentUUID&quot;: &quot;dab3d1f9-ee78-4886-85c5-61147dc1fcb1&quot;,
      &quot;skipped&quot;: false
    }
  ],
  &quot;allPending&quot;: [],
  &quot;allPasses&quot;: [
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;323df3b3-ed51-4e2a-9304-88849a3d0e5b&quot;,
      &quot;parentUUID&quot;: &quot;9594918e-0827-4c03-b74d-20002a26911a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;06edb568-7970-48b4-a45c-976077ef2d71&quot;,
      &quot;parentUUID&quot;: &quot;9594918e-0827-4c03-b74d-20002a26911a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getAgent Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7f19c384-de7b-4c99-abbf-36b6c8e8234d&quot;,
      &quot;parentUUID&quot;: &quot;3a926ecc-ddc9-4e67-aedb-76dda206b610&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getAgent Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = agents.getAgent(&#x27;mock_name&#x27;);\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a9f94659-f673-41e2-8a02-a82ddcf1ed14&quot;,
      &quot;parentUUID&quot;: &quot;3a926ecc-ddc9-4e67-aedb-76dda206b610&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;2&#x27;});\ndynamo_client.scan.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4d1d717f-fcbe-478e-a381-5b53601ada0b&quot;,
      &quot;parentUUID&quot;: &quot;96e4d162-f61e-4af5-8cd6-f83f663798d0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getAgentList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e08ca80c-2ca7-47d1-b513-6971eabf39b7&quot;,
      &quot;parentUUID&quot;: &quot;96e4d162-f61e-4af5-8cd6-f83f663798d0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeAgent Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\&quot;error removing rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d298e2be-44aa-4561-aca8-d83922a6ef69&quot;,
      &quot;parentUUID&quot;: &quot;ced7a107-e669-44c0-9209-fecc09ded95d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeAgent Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\&quot;success\&quot;});\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;92dabb8f-ebe5-4e8d-852c-a00784491d2e&quot;,
      &quot;parentUUID&quot;: &quot;ced7a107-e669-44c0-9209-fecc09ded95d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateAgent Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 5,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ef631d93-7562-4059-94e4-4388897b154d&quot;,
      &quot;parentUUID&quot;: &quot;e0d8e836-0862-4359-9b37-851ca825eb03&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateAgent Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c7b7d4c3-fefb-47df-95ef-58007d409a92&quot;,
      &quot;parentUUID&quot;: &quot;e0d8e836-0862-4359-9b37-851ca825eb03&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
      &quot;fullTitle&quot;: &quot;query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;29b5ccf9-c97a-42bb-8779-81157c19139a&quot;,
      &quot;parentUUID&quot;: &quot;802aa6cf-a946-4742-aa12-eb6b596c6a8c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
      &quot;fullTitle&quot;: &quot;query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3e358c25-16ae-48bd-a1a0-b66dc7bd35ee&quot;,
      &quot;parentUUID&quot;: &quot;802aa6cf-a946-4742-aa12-eb6b596c6a8c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \&quot;Requested resource not found\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5668bdfd-c977-4457-8117-551210a0aeac&quot;,
      &quot;parentUUID&quot;: &quot;6559be4c-fb2f-467f-a445-405ec898518e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7a38e270-a340-4edf-9fa6-9f62384fce9c&quot;,
      &quot;parentUUID&quot;: &quot;6559be4c-fb2f-467f-a445-405ec898518e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \&quot;error adding message\&quot; });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;368ca2cb-2c11-46ce-914b-22278d5221c2&quot;,
      &quot;parentUUID&quot;: &quot;fda16baa-e7db-45f3-b5d5-1e0b0e6e3cc6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bc373be5-705e-46cc-8c7a-b0409ac0dac0&quot;,
      &quot;parentUUID&quot;: &quot;fda16baa-e7db-45f3-b5d5-1e0b0e6e3cc6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \&quot;error downloading conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4f3caf75-bc54-4edc-9b6f-8ff2f19cd364&quot;,
      &quot;parentUUID&quot;: &quot;d7852712-1502-476b-a089-e33ffd23803a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getConversation Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;157cb40b-76b0-4ffa-914e-2a4561400385&quot;,
      &quot;parentUUID&quot;: &quot;d7852712-1502-476b-a089-e33ffd23803a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;deaca613-014c-4192-b897-34fe8a71ecbe&quot;,
      &quot;parentUUID&quot;: &quot;62d98a05-f03c-45e4-8e33-77916f9a4cdf&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getConversationList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5b128857-9589-48f7-9090-1d3446fa8623&quot;,
      &quot;parentUUID&quot;: &quot;62d98a05-f03c-45e4-8e33-77916f9a4cdf&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6edf9515-761a-4cbd-bfd6-48de37ad0e83&quot;,
      &quot;parentUUID&quot;: &quot;c55533c5-9c61-45c9-a569-b29fef9e08e4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c352c821-931d-42fa-b5d3-2b541cf09beb&quot;,
      &quot;parentUUID&quot;: &quot;c55533c5-9c61-45c9-a569-b29fef9e08e4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 7,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;body.result.action = &#x27;user.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;admin&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;809d7d6d-f37c-4b0e-bae0-e2254b96a1ea&quot;,
      &quot;parentUUID&quot;: &quot;739deb20-8b18-4cdb-8a8d-9ddb1f047c3b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;body.result.action = &#x27;guest.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;, company : \&quot;Google\&quot;}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;welcome&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5a70baa2-af0b-4740-809d-fcdac967b827&quot;,
      &quot;parentUUID&quot;: &quot;739deb20-8b18-4cdb-8a8d-9ddb1f047c3b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;expect(obs.next.bind(obs)).to.throw();&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cc60460d-6efe-4cc6-a304-41eab39865e1&quot;,
      &quot;parentUUID&quot;: &quot;b312ec6d-2e5f-4bd2-a195-33ee58376e0b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;753dbb52-26d3-4f90-b1f6-70561c4a8a3b&quot;,
      &quot;parentUUID&quot;: &quot;0278ab44-e86f-4644-8549-af97c2e6a21e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addGuest Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addGuest(&#x27;mauro&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8c5fba9d-c2c2-463b-92dc-3ec00fcbb05a&quot;,
      &quot;parentUUID&quot;: &quot;0278ab44-e86f-4644-8549-af97c2e6a21e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \&quot;error getting data\&quot; });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b262d94a-d279-4046-9e36-43a0a6ecb5a8&quot;,
      &quot;parentUUID&quot;: &quot;c1c6188c-beb0-4712-a42f-e5a6e951d9d0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getGuest Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \&quot;Mauro\&quot;);\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\&quot;Zero12\&quot;);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;60c965d0-1766-48ef-bb55-6f004ab99351&quot;,
      &quot;parentUUID&quot;: &quot;c1c6188c-beb0-4712-a42f-e5a6e951d9d0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }], LastEvaluatedKey: &#x27;Luca&#x27;});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8776d3d8-1043-42f1-8b31-5b814cd33129&quot;,
      &quot;parentUUID&quot;: &quot;0eccf4f9-5b92-4dec-acfb-11ea3cbfef31&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getGuestList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1fef49e6-822a-42d7-b42b-8826debe5cf0&quot;,
      &quot;parentUUID&quot;: &quot;0eccf4f9-5b92-4dec-acfb-11ea3cbfef31&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing guest\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8d25fdf0-1be4-4750-ac84-15b3e8ba4888&quot;,
      &quot;parentUUID&quot;: &quot;9f7bec2a-b42d-425b-bb2f-a1fb2021a9fc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeGuest Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e86c864f-323d-451d-9ad0-047bd5ce7dda&quot;,
      &quot;parentUUID&quot;: &quot;9f7bec2a-b42d-425b-bb2f-a1fb2021a9fc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating guest\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3371d654-5c3b-42d2-a4ab-537d8da7f4c3&quot;,
      &quot;parentUUID&quot;: &quot;075a1914-526b-4c1e-b946-ac9bc2bfbcb1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6670ef9b-b7da-4ea5-bd1c-3ef6f8f68588&quot;,
      &quot;parentUUID&quot;: &quot;075a1914-526b-4c1e-b946-ac9bc2bfbcb1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;544e1ed9-7c43-41ee-963c-c821171d7fc7&quot;,
      &quot;parentUUID&quot;: &quot;aaa121bd-0faf-4ccd-857d-acabe82fb00d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;580adbdf-8ace-47a3-ab2d-40cff2ba6a99&quot;,
      &quot;parentUUID&quot;: &quot;aaa121bd-0faf-4ccd-857d-acabe82fb00d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;addMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.addMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;67b8b705-9b39-436d-876d-fc1258636321&quot;,
      &quot;parentUUID&quot;: &quot;9620d65a-bd4b-4e12-ba9f-cf08728b82cf&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
      &quot;fullTitle&quot;: &quot;getMember Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t&#x27;ok&#x27;: true,\n\t&#x27;user&#x27;:\n\t{\n\t\t&#x27;id&#x27;: &#x27;U023BECGF&#x27;,\n\t\t&#x27;name&#x27;: &#x27;bobby&#x27;,\n\t\t&#x27;deleted&#x27;: false,\n\t\t&#x27;color&#x27;: &#x27;9f69e7&#x27;,\n\t\t&#x27;profile&#x27;:\n\t\t{\n\t\t\t&#x27;avatar_hash&#x27;: &#x27;ge3b51ca72de&#x27;,\n\t\t\t&#x27;current_status&#x27;: &#x27;:mountain_railway: riding a train&#x27;,\n\t\t\t&#x27;first_name&#x27;: &#x27;Bobby&#x27;,\n\t\t\t&#x27;last_name&#x27;: &#x27;Tables&#x27;,\n\t\t\t&#x27;real_name&#x27;: &#x27;Bobby Tables&#x27;,\n\t\t\t&#x27;email&#x27;: &#x27;bobby@slack.com&#x27;,\n\t\t\t&#x27;skype&#x27;: &#x27;my-skype-name&#x27;,\n\t\t\t&#x27;phone&#x27;: &#x27;+1 (123) 456 7890&#x27;\n\t\t},\n\t\t&#x27;is_admin&#x27;: true,\n\t\t&#x27;is_owner&#x27;: true,\n\t\t&#x27;updated&#x27;: 1490054400,\n\t\t&#x27;has_2fa&#x27;: true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;375c8d11-bc06-4ac8-8244-21c9fbfc83c3&quot;,
      &quot;parentUUID&quot;: &quot;13b7d5d4-e1cc-4c51-8bc1-c7c42a6cf4ef&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getMember Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1fad7301-530a-4f1b-aee9-2f7a7858bd77&quot;,
      &quot;parentUUID&quot;: &quot;13b7d5d4-e1cc-4c51-8bc1-c7c42a6cf4ef&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
      &quot;fullTitle&quot;: &quot;getMemberList L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\&quot;ok\&quot;: true,\n\t\&quot;members\&quot;:\n\t[\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECGF\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;mauro\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Mauro Bocciofilo\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t},\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECLL\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;bobby\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;,\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6a4197ec-c29f-4653-982b-2731b5650a78&quot;,
      &quot;parentUUID&quot;: &quot;632e1d25-798f-496d-904a-16c4abd01939&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getMemberList Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f535844e-2430-47fc-b33d-d47b15b1b096&quot;,
      &quot;parentUUID&quot;: &quot;632e1d25-798f-496d-904a-16c4abd01939&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;removeMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.removeMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b3e3371d-9288-4bdd-8dd7-4592988c5cbb&quot;,
      &quot;parentUUID&quot;: &quot;262f348a-b96e-47bf-b040-a54baf6a0849&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;updateMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.updateMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;63451431-bb02-4a30-8895-0fd1a19a8473&quot;,
      &quot;parentUUID&quot;: &quot;172fd663-3c3c-4e85-9e46-26a3184907bc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(&#x27;errore&#x27;);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n  done();\n}&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;193b13c0-c7fb-4e69-889f-940987b019db&quot;,
      &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields(&#x27;errore&#x27;);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2156a6ac-1c2b-4366-ba8e-418bcff81951&quot;,
      &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(&#x27;errore&#x27;);\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d8c15434-9efe-4724-a587-716172c2bfa7&quot;,
      &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 200);\n  done();\n}&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7342ee25-ef4a-44f6-9843-7b66f537919d&quot;,
      &quot;parentUUID&quot;: &quot;ac9f4af7-b27b-46c8-aa1e-9ebe154b8f57&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(&#x27;errore&#x27;);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ae0ceb3d-f4da-4b11-ba0d-aa27a37595c1&quot;,
      &quot;parentUUID&quot;: &quot;b82d5dc7-3536-4ab6-9f33-73fdef730387&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;766cab3f-44ee-47b9-a7ec-306059516b65&quot;,
      &quot;parentUUID&quot;: &quot;b82d5dc7-3536-4ab6-9f33-73fdef730387&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\n\nexpect(context.succeed.callCount).to.equal(1);\t\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cdcf8f35-5178-4b82-9894-0b963eca8740&quot;,
      &quot;parentUUID&quot;: &quot;b82d5dc7-3536-4ab6-9f33-73fdef730387&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare complete_cb&quot;,
      &quot;fullTitle&quot;: &quot;complete Deve chiamare complete_cb&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \&quot;il callback di complete non è stato chiamato esattamente una volta.\&quot;).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;164b4e50-d696-451e-860c-72375fd7a329&quot;,
      &quot;parentUUID&quot;: &quot;71a63949-b02a-45da-9d82-bb3cdae43e28&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;complete Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b4de0c6d-5cf4-4313-993b-3189d5ec1724&quot;,
      &quot;parentUUID&quot;: &quot;71a63949-b02a-45da-9d82-bb3cdae43e28&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;complete Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f48a24c6-305f-45a2-a75f-1bbd55fc4a41&quot;,
      &quot;parentUUID&quot;: &quot;71a63949-b02a-45da-9d82-bb3cdae43e28&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare error_cb&quot;,
      &quot;fullTitle&quot;: &quot;error Deve chiamare error_cb&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;da3569fc-a24e-441b-a2f4-8829e6eec349&quot;,
      &quot;parentUUID&quot;: &quot;204d1bdd-22c0-4850-94ab-0c82770bd4b4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;error Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onError(success);\nobs.pause();\nobs.error(&#x27;errore&#x27;);\n        expect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;65e1072f-f459-42dc-8f7c-9db51ff6fc20&quot;,
      &quot;parentUUID&quot;: &quot;204d1bdd-22c0-4850-94ab-0c82770bd4b4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;error Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;13860a7e-713e-449d-94c9-71a7e65b7b4f&quot;,
      &quot;parentUUID&quot;: &quot;204d1bdd-22c0-4850-94ab-0c82770bd4b4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal(&#x27;data&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8cb58066-4208-4eac-90c2-ee97394123bb&quot;,
      &quot;parentUUID&quot;: &quot;ba3d019e-1ebb-4126-b37b-87886bf6b99f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;next Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.pause();\nobs.next(&#x27;Function called&#x27;);\nexpect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3a79d872-a40c-4c3c-8e5b-dc6efc2b3252&quot;,
      &quot;parentUUID&quot;: &quot;ba3d019e-1ebb-4126-b37b-87886bf6b99f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next(&#x27;other data&#x27;);\nexpect(success.callCount).to.equal(2);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bf55b7ae-26fa-4b00-9585-a3fdf3edbb10&quot;,
      &quot;parentUUID&quot;: &quot;ba3d019e-1ebb-4126-b37b-87886bf6b99f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;934e4d87-01be-444f-acf3-15460f34536a&quot;,
      &quot;parentUUID&quot;: &quot;bf1363d3-41b8-4990-a222-6f3a85fdfef2&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;503cfc1b-beba-4010-8279-0dcd837d9f20&quot;,
      &quot;parentUUID&quot;: &quot;bf1363d3-41b8-4990-a222-6f3a85fdfef2&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;21dc619c-91e6-40c6-ad11-1442868ac06e&quot;,
      &quot;parentUUID&quot;: &quot;05b253d1-4b06-475d-8369-e3533b9fcadc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;345df0f6-fa34-4840-94b1-b70d9eb5d099&quot;,
      &quot;parentUUID&quot;: &quot;05b253d1-4b06-475d-8369-e3533b9fcadc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d4a87f6a-2a70-4e9c-8324-3218f7b80b41&quot;,
      &quot;parentUUID&quot;: &quot;796a2f4e-c5ba-4b56-8e5f-ad0836ca3af1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;03a52eed-d228-4ce0-ba73-bf66dd2c67eb&quot;,
      &quot;parentUUID&quot;: &quot;796a2f4e-c5ba-4b56-8e5f-ad0836ca3af1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;//da definire&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;85e87854-923e-4963-bc32-c5b333ff66bb&quot;,
      &quot;parentUUID&quot;: &quot;796a2f4e-c5ba-4b56-8e5f-ad0836ca3af1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeRule Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bced9eb7-0935-4d60-9908-f9ccfb02dead&quot;,
      &quot;parentUUID&quot;: &quot;a02b0b04-9bbe-4cd2-bf7b-17ecc041275e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeRule Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e3e011d3-501d-46f6-9b90-1cdb72936702&quot;,
      &quot;parentUUID&quot;: &quot;a02b0b04-9bbe-4cd2-bf7b-17ecc041275e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5c7da28f-01a5-43d5-b23d-da7e128d55a8&quot;,
      &quot;parentUUID&quot;: &quot;3430135a-ac18-4acd-88fb-01bd4659c0b5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;447686e3-caa4-44c9-ad92-ec66ddf71e3d&quot;,
      &quot;parentUUID&quot;: &quot;3430135a-ac18-4acd-88fb-01bd4659c0b5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \&quot;\&quot;};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1674d18a-5a83-4caf-8846-12583e8cd6c0&quot;,
      &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;de153504-a563-4490-a27b-661ae53e130a&quot;,
      &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6b942434-fc86-4f3c-9e37-9538706a122d&quot;,
      &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;24d0af1b-2539-48ca-8e56-1ac8af8f5f8c&quot;,
      &quot;parentUUID&quot;: &quot;d83d8458-d69e-4524-8e3e-2c0c94bec188&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;361ad7bf-ee31-49ea-bf21-9bc46909f363&quot;,
      &quot;parentUUID&quot;: &quot;78918e59-adcc-4e96-93fd-f9fa31c3ead3&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;70f32ba1-df22-443b-9957-30963e0ca8b2&quot;,
      &quot;parentUUID&quot;: &quot;78918e59-adcc-4e96-93fd-f9fa31c3ead3&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);\n};&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;80eed219-b4c0-4c48-9cab-b2d5962fcae1&quot;,
      &quot;parentUUID&quot;: &quot;78918e59-adcc-4e96-93fd-f9fa31c3ead3&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;dd96d9e9-73ad-4b34-8c50-913c43728867&quot;,
      &quot;parentUUID&quot;: &quot;87f5b940-cacc-47f6-a220-04c266d28f86&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8c54c567-b5e3-4e35-b84c-e47a0f9f381b&quot;,
      &quot;parentUUID&quot;: &quot;87f5b940-cacc-47f6-a220-04c266d28f86&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;749eb433-b190-4ec6-9811-771631eb928d&quot;,
      &quot;parentUUID&quot;: &quot;87f5b940-cacc-47f6-a220-04c266d28f86&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;24a91b29-1fb3-456d-89a1-b84f022bbe85&quot;,
      &quot;parentUUID&quot;: &quot;6c012c69-dca6-4f4e-a7bf-3bb04e611dbb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;02c0b11a-ac3d-4d15-9285-a93c10989d27&quot;,
      &quot;parentUUID&quot;: &quot;6c012c69-dca6-4f4e-a7bf-3bb04e611dbb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;de0c99e0-dc0b-4bb3-b240-aa39ffb3253f&quot;,
      &quot;parentUUID&quot;: &quot;35f3fa36-00bf-4d8b-bd5f-d1a6a924ef8d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a341108f-a681-4925-be66-f3b2e866edd0&quot;,
      &quot;parentUUID&quot;: &quot;35f3fa36-00bf-4d8b-bd5f-d1a6a924ef8d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;707839fe-6576-4a1f-bb39-718966de647a&quot;,
      &quot;parentUUID&quot;: &quot;f359a61f-53e0-4849-9350-f676a79cdc49&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \&quot;\&quot; , body: \&quot;\&quot;};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;61296071-82c7-481b-bb79-aa83e584e793&quot;,
      &quot;parentUUID&quot;: &quot;f359a61f-53e0-4849-9350-f676a79cdc49&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5b610349-3571-45f4-8a04-a13584e3c7b9&quot;,
      &quot;parentUUID&quot;: &quot;f359a61f-53e0-4849-9350-f676a79cdc49&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
      &quot;fullTitle&quot;: &quot;speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3c0189b2-57ed-4624-b102-f0f3368eca31&quot;,
      &quot;parentUUID&quot;: &quot;c2a6a27f-970f-4b54-aac1-55dab2da64e9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5bac7e4d-6ace-419b-b143-e9926c97fd91&quot;,
      &quot;parentUUID&quot;: &quot;91b18b66-4766-489b-8b7f-13f9944c23f4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;42f93b22-bdc4-4875-b595-5023c1452e15&quot;,
      &quot;parentUUID&quot;: &quot;91b18b66-4766-489b-8b7f-13f9944c23f4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getTask Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTask(&#x27;mock_type&#x27;).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3cfd4d56-7c37-4a09-aad0-501abbaa9130&quot;,
      &quot;parentUUID&quot;: &quot;099c502d-b5e9-45d7-8547-25e35212d3d8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getTask Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = tasks.getTask(&#x27;mock_type&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cec36c77-a3a1-478d-8ef1-e9188d14c3cf&quot;,
      &quot;parentUUID&quot;: &quot;099c502d-b5e9-45d7-8547-25e35212d3d8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \&quot;mock_type3\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b7ea70d0-04f4-4cf0-928b-61b8ce7b6a55&quot;,
      &quot;parentUUID&quot;: &quot;1b6a918c-e231-43ba-8b1e-c2745b127421&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8f938647-2fef-4dbb-a072-6318ef9cad47&quot;,
      &quot;parentUUID&quot;: &quot;1b6a918c-e231-43ba-8b1e-c2745b127421&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1243fdb4-4787-4a29-b7ad-282b21e87191&quot;,
      &quot;parentUUID&quot;: &quot;ddd2deae-dc67-4fa1-acbb-783f728a0c68&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;659e1a19-d564-46bf-b881-4dc2187ad8fc&quot;,
      &quot;parentUUID&quot;: &quot;ddd2deae-dc67-4fa1-acbb-783f728a0c68&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8504f966-68d3-4836-81ad-ad5cada735c1&quot;,
      &quot;parentUUID&quot;: &quot;5fa06823-14a6-401d-b42f-033e00297dcb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;28aa9f5a-915d-4b3a-acaa-dfaec7c73215&quot;,
      &quot;parentUUID&quot;: &quot;5fa06823-14a6-401d-b42f-033e00297dcb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\&quot;Requested resource not found\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2433a75a-55dc-4c45-8002-333e240b3fed&quot;,
      &quot;parentUUID&quot;: &quot;6fac0e24-fc7b-4864-a248-232b6ca6035b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;71d8a601-23b5-4b1c-aab0-15532fba3a8c&quot;,
      &quot;parentUUID&quot;: &quot;6fac0e24-fc7b-4864-a248-232b6ca6035b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8e647fbb-14a2-4528-a7ea-0cce4231b29a&quot;,
      &quot;parentUUID&quot;: &quot;bcf95ab7-ada2-4f61-ab33-f4b854eb1061&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = users.getUser(&#x27;mou&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\n\t\t\t\t\texpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;71b1ff63-6baf-48f8-a201-3fd68b3fcb3a&quot;,
      &quot;parentUUID&quot;: &quot;bcf95ab7-ada2-4f61-ab33-f4b854eb1061&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}], LastEvaluatedKey: &#x27;marco&#x27;});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a3e8042e-1b92-41b5-97a5-34db559918b1&quot;,
      &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5a305065-883c-4efc-957a-001b810df4a2&quot;,
      &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a249c586-c79d-4f2b-abf2-acd05ccd7b26&quot;,
      &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;,\n\tslack_channel: &#x27;channel&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name and slack_channel = :slack_channel&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:slack_channel&#x27;, &#x27;channel&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f776324b-dd8c-4398-b072-c422452452ba&quot;,
      &quot;parentUUID&quot;: &quot;acd9a49c-170b-486f-97f4-460d8dfc1fb1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeUser Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \&quot;error removing user\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;70ecaf17-d8cc-4dcc-8e66-fbc752b593e0&quot;,
      &quot;parentUUID&quot;: &quot;ea0ad7ca-3878-41be-88fc-70e538015e5b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;removeUser Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;24cd4871-5284-4146-9984-f989a46d6967&quot;,
      &quot;parentUUID&quot;: &quot;ea0ad7ca-3878-41be-88fc-70e538015e5b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \&quot;error updating user\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;12dec5a4-3114-4254-8c1b-4de61a05c51c&quot;,
      &quot;parentUUID&quot;: &quot;516606e8-a45a-4765-a379-77ad44f54277&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cf1757ff-525d-4351-9cc1-af9d61d15f5d&quot;,
      &quot;parentUUID&quot;: &quot;516606e8-a45a-4765-a379-77ad44f54277&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;584e0bde-9cbe-474b-9b6f-f910cb839772&quot;,
      &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4c7de136-9b70-4865-a84b-e86ac58eb34c&quot;,
      &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \&quot;\&quot; };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;dcf6e942-f678-4f00-8a8e-8bf44321913c&quot;,
      &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ffc49c2b-e8f8-4489-86d6-d22d9e60a775&quot;,
      &quot;parentUUID&quot;: &quot;e6c637c9-577c-45f7-af5a-20ae75bfc050&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;527798db-4117-4d43-9e24-bb78024275f7&quot;,
      &quot;parentUUID&quot;: &quot;542ca549-4e45-4cb6-852b-c7889f87c2af&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2af69d0c-4bea-4975-87ce-4e145481423d&quot;,
      &quot;parentUUID&quot;: &quot;542ca549-4e45-4cb6-852b-c7889f87c2af&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { pathParameters: { username: &#x27;pippo&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9e0ac3ba-43b5-48b4-a156-aacacd78c0a9&quot;,
      &quot;parentUUID&quot;: &quot;542ca549-4e45-4cb6-852b-c7889f87c2af&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9ba417d8-2bba-4ca1-a11c-f523c4794c8d&quot;,
      &quot;parentUUID&quot;: &quot;a4782cf0-880d-486a-91e3-c1251b9691d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c4fa0022-1aba-435b-bbe9-92af173cecf2&quot;,
      &quot;parentUUID&quot;: &quot;a4782cf0-880d-486a-91e3-c1251b9691d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\n          let ev = { pathParameters: { username: &#x27;pippo&#x27;} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;13fb6b81-085c-4919-a6aa-c34c43a07112&quot;,
      &quot;parentUUID&quot;: &quot;a4782cf0-880d-486a-91e3-c1251b9691d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;70819cd4-26ac-494c-9a6a-364c9f708a56&quot;,
      &quot;parentUUID&quot;: &quot;d98c2df1-5efa-4cf8-8328-5fafa3b8e9fe&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ users: [{ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;427574cc-a0b2-4674-85ed-98eb964196f4&quot;,
      &quot;parentUUID&quot;: &quot;d98c2df1-5efa-4cf8-8328-5fafa3b8e9fe&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;332976fa-5130-40b7-8f05-0453f492dafe&quot;,
      &quot;parentUUID&quot;: &quot;52ba070d-3a13-444f-985d-5b832579633e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;61c99b34-10db-4968-8d2e-7717a326d5e6&quot;,
      &quot;parentUUID&quot;: &quot;52ba070d-3a13-444f-985d-5b832579633e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = { pathParameters: \&quot;\&quot;, body: \&quot;\&quot; };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4f17a565-39dc-45d1-9026-de65d6850c53&quot;,
      &quot;parentUUID&quot;: &quot;52ba070d-3a13-444f-985d-5b832579633e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;445aa1eb-908a-4bc9-a1e1-fa54c2a5caa9&quot;,
      &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fdde9ab2-e797-4b53-8eb3-532a66ae2a8b&quot;,
      &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;msg&#x27;: &#x27;error getting guest&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5adb5032-e2b4-48f4-9355-909020f3b1da&quot;,
      &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ &#x27;msg&#x27;: &#x27;error adding conversation&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;22ecbdd2-e85b-4695-bd0c-2a8d97a51537&quot;,
      &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;type&#x27;: &#x27;example&#x27; });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;459505e4-3403-4fcb-8c5d-34125494bd74&quot;,
      &quot;parentUUID&quot;: &quot;0effac46-72e4-4729-8c20-ea1626ad93f7&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
      &quot;fullTitle&quot;: &quot;query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith(&#x27;test&#x27;));\n\tlet result = context.succeed.getCall(0).args[0];\n            expect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n            done();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;226cf9e1-13b9-4856-a032-040122b5641b&quot;,
      &quot;parentUUID&quot;: &quot;1452e88c-5d82-48e6-a29a-37bcfef2191c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
      &quot;fullTitle&quot;: &quot;query Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.reject(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n            done();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9e8e83cb-5035-4258-8a63-7e375bf0da82&quot;,
      &quot;parentUUID&quot;: &quot;1452e88c-5d82-48e6-a29a-37bcfef2191c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;29caa929-a0f0-4dde-b8c0-65472fc4cc40&quot;,
      &quot;parentUUID&quot;: &quot;9daec29c-268a-4c98-88ed-d54afc57c5b9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9ec12e84-282b-4290-8c1d-08f49a54fd3a&quot;,
      &quot;parentUUID&quot;: &quot;9f7c5468-bd18-461e-aec0-24783382a75b&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.addEnrollment.returns(Rx.Observable.throw(errore));\napi._addUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;55d2c52c-f810-4ac8-ac11-a6cb50c8c8e2&quot;,
      &quot;parentUUID&quot;: &quot;db0e07f5-b977-44d4-bdfd-cfa75e777175&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;66bcaf1d-f8e5-4520-a7dc-8ab14b474f47&quot;,
      &quot;parentUUID&quot;: &quot;b6a175e2-678e-438c-88ba-ea67fc2550de&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c4da9def-8688-417c-9f3a-38db852bbf48&quot;,
      &quot;parentUUID&quot;: &quot;8623eed6-bd3a-408a-bdab-618a75deccec&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3bcc2dbc-0f81-45c2-bd2b-06227ec1a581&quot;,
      &quot;parentUUID&quot;: &quot;157be1f0-5ab2-4cb4-90d1-f99ffe481390&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e03f0367-9493-4836-9fcc-fe7f2684c069&quot;,
      &quot;parentUUID&quot;: &quot;29bcb080-578d-44b7-9aa0-7ad7c49addfd&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
      &quot;fullTitle&quot;: &quot;_loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.doLogin.returns(Rx.Observable.throw(errore));\napi._loginUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2cb6af96-dd0c-43f5-b2b7-4bc98907d069&quot;,
      &quot;parentUUID&quot;: &quot;6d144e37-05cd-4b1d-bd6a-af9caf5d6da2&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e9be47bb-b3a8-40d2-a705-9f34c224d4db&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0d2db1ce-12e6-423b-972b-919d74a62c27&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c17cffc9-cbb0-4262-a727-5e3883ebd21d&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0258c1f8-cc77-47eb-adb8-de39de1ed05e&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7a71e6a7-3ef0-490e-96cb-82d6a0784c21&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ceb5e112-a980-4e35-9588-2de71d9e751d&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUserList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUserList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUserList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUserList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d0d6e44e-17fe-4e16-99d4-030961a873a7&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;02528382-11e8-436f-a85a-883661b030ff&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d5a7ad63-3857-44ef-8e15-fcc681004fe2&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f5152a41-73c4-427a-86df-1264e6428b89&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f6601963-6104-4bc6-acd0-d60c4db4978f&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          };\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3920593b-60d8-4173-90c0-00fa78228d6d&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fe586a9b-9cfb-47e5-8060-efe54dcc13b2&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;179debc5-0ca0-411a-b89f-e6a063daea36&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c7d70b15-1a25-4000-a623-4adc4e0c8864&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;577517dd-c6b0-48e0-a430-b36a99b215f5&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;26702530-3986-48a5-8b1f-4337b93ff030&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3e21f911-412e-4774-81f8-6a3f6ac81405&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0c621c18-c68d-4171-ad1b-cc81b59732b6&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;62e5fe6d-ec9f-4f79-ad57-4563b2fcec3c&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;45163cfe-77e8-404f-a3f6-9e5d25852876&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7940c317-be8f-4d95-adc6-4ecf313a3d69&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n\texpect(response).have.property(&#x27;statusCode&#x27;, 200);\n\tdone();\n};\napi.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7d22f55f-8de9-411f-a188-5a3e159a15d3&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6164b5aa-cbe7-4b99-8de0-527c13c04dfb&quot;,
      &quot;parentUUID&quot;: &quot;7414a44c-cd25-4628-a939-b8c14ec206ef&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1366acd4-54ab-4fb3-b06b-7f7af4530b8b&quot;,
      &quot;parentUUID&quot;: &quot;b204672a-88dc-4d7d-8a82-525ff9f20f21&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.resetEnrollments.returns(Rx.Observable.throw(errore));\napi._resetUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0f3e30dd-da36-4ce0-b853-a7c78f26117f&quot;,
      &quot;parentUUID&quot;: &quot;f7bbc907-3c7f-4875-bd3c-7368d7c20372&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c008806e-3dae-4783-88c5-5108c410473c&quot;,
      &quot;parentUUID&quot;: &quot;3f7a4964-796c-49fc-949b-6b5497f0e3e4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;af55b24f-0b28-4a2b-a729-614aabe5eab4&quot;,
      &quot;parentUUID&quot;: &quot;e0027bec-1f86-4e5a-b778-599fadef77be&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;21d74ef5-bcff-4ec0-97b8-066355ba0025&quot;,
      &quot;parentUUID&quot;: &quot;22d0f8fc-99fc-4896-95d9-15117854e377&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9b0cd785-4086-44e0-8471-507707ae5934&quot;,
      &quot;parentUUID&quot;: &quot;cd564caa-de06-4f4d-a345-925a55e76f54&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;46004f32-315f-4401-a645-01e1e64b87be&quot;,
      &quot;parentUUID&quot;: &quot;b44f757b-06f8-4809-bad4-5a91709f600c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 8,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject({ \&quot;result\&quot; : \&quot;Reject\&quot; }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;115d1b30-517b-426a-a80c-b631e1a9cf59&quot;,
      &quot;parentUUID&quot;: &quot;ec7f4af6-7c21-4174-9b25-39b2ee2a2907&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4acf7496-49a4-4f64-abe5-a01a4bdf3966&quot;,
      &quot;parentUUID&quot;: &quot;87ae3466-151b-4856-831e-b19f3b57e4b6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n  {\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;02556f8d-d023-4d71-bb9c-3b5e96aeb5c0&quot;,
      &quot;parentUUID&quot;: &quot;021dcfd3-efa1-4d09-a4f5-99e1e8770480&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;resetEnrollments Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.resetEnrollments().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a3e78da8-834c-433e-b156-03a4b4aa5a05&quot;,
      &quot;parentUUID&quot;: &quot;dab3d1f9-ee78-4886-85c5-61147dc1fcb1&quot;,
      &quot;skipped&quot;: false
    }
  ],
  &quot;allFailures&quot;: [
    {
      &quot;title&quot;: &quot;La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;TypeError: service.webhook is not a function\n  at Context.&lt;anonymous&gt; (src\\test\\test_AdministrationWebhookService.js:72:17)\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2d5a2027-bd8a-4eea-b514-7611333dc194&quot;,
      &quot;parentUUID&quot;: &quot;16aae3bd-d389-4ce8-be37-12bb842af39e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;TypeError: service.webhook is not a function\n  at Context.&lt;anonymous&gt; (src\\test\\test_AdministrationWebhookService.js:78:17)\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;47923f23-8044-4ac7-84a5-5aa854f730e5&quot;,
      &quot;parentUUID&quot;: &quot;16aae3bd-d389-4ce8-be37-12bb842af39e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;eee55e6f-64f1-4cf9-b5c3-2a93ce2c937c&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;50564916-2705-43b7-b023-723f28e84fca&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2001,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c0ac97e5-01a4-459e-bf68-0ffb06b44d76&quot;,
      &quot;parentUUID&quot;: &quot;960fde6e-3680-401d-9d9a-f60f2aa9d196&quot;,
      &quot;skipped&quot;: false
    }
  ],
  &quot;copyrightYear&quot;: 2017
}" data-config="{&quot;reportDir&quot;:&quot;mochawesome-report&quot;,&quot;reportTitle&quot;:&quot;AtAVi&quot;,&quot;reportPageTitle&quot;:&quot;Mochawesome Report&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;charts&quot;:true,&quot;enableCharts&quot;:true,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;dev&quot;:false,&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;saveJson&quot;:true,&quot;jsonFile&quot;:&quot;H:\\src\\git\\AtAVi\\mochawesome-report\\mochawesome.json&quot;,&quot;htmlFile&quot;:&quot;H:\\src\\git\\AtAVi\\mochawesome-report\\mochawesome.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>