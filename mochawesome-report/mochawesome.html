<!doctype html>
<html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Mochawesome Report</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{
  &quot;stats&quot;: {
    &quot;suites&quot;: 136,
    &quot;tests&quot;: 182,
    &quot;passes&quot;: 166,
    &quot;pending&quot;: 0,
    &quot;failures&quot;: 16,
    &quot;start&quot;: &quot;2017-05-06T22:59:14.273Z&quot;,
    &quot;end&quot;: &quot;2017-05-06T22:59:51.659Z&quot;,
    &quot;duration&quot;: 37386,
    &quot;testsRegistered&quot;: 182,
    &quot;passPercent&quot;: 91.2,
    &quot;pendingPercent&quot;: 0,
    &quot;other&quot;: 0,
    &quot;hasOther&quot;: false,
    &quot;skipped&quot;: 0,
    &quot;hasSkipped&quot;: false,
    &quot;passPercentClass&quot;: &quot;success&quot;,
    &quot;pendingPercentClass&quot;: &quot;danger&quot;
  },
  &quot;suites&quot;: {
    &quot;title&quot;: &quot;&quot;,
    &quot;suites&quot;: [
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;AdministrationWebhookService&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;webhook&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
                    &quot;fullTitle&quot;: &quot;AdministrationWebhookService webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;8d1f4836-dc03-4e4a-a95e-8cee60ee25df&quot;,
                    &quot;parentUUID&quot;: &quot;d288bf21-99dc-4256-8659-edbbbd644074&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
                    &quot;fullTitle&quot;: &quot;AdministrationWebhookService webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;cb6595a7-63ce-4782-b715-61e4d220a581&quot;,
                    &quot;parentUUID&quot;: &quot;d288bf21-99dc-4256-8659-edbbbd644074&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_AdministrationWebhookService.js&quot;,
                &quot;uuid&quot;: &quot;d288bf21-99dc-4256-8659-edbbbd644074&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AdministrationWebhookService.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
                    &quot;fullTitle&quot;: &quot;AdministrationWebhookService webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;8d1f4836-dc03-4e4a-a95e-8cee60ee25df&quot;,
                    &quot;parentUUID&quot;: &quot;d288bf21-99dc-4256-8659-edbbbd644074&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
                    &quot;fullTitle&quot;: &quot;AdministrationWebhookService webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;cb6595a7-63ce-4782-b715-61e4d220a581&quot;,
                    &quot;parentUUID&quot;: &quot;d288bf21-99dc-4256-8659-edbbbd644074&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 2,
                &quot;totalPasses&quot;: 2,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 4,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_AdministrationWebhookService.js&quot;,
            &quot;uuid&quot;: &quot;c8658929-0ca6-4ffe-979f-dbf5a606112c&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AdministrationWebhookService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_AdministrationWebhookService.js&quot;,
        &quot;uuid&quot;: &quot;43cbbf12-ac79-4af2-b0d3-eb7a02a1e781&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AdministrationWebhookService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Agents&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;AgentsDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addAgent&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b2ac5a0d-ca5d-4472-a26c-75b0db5ba26c&quot;,
                        &quot;parentUUID&quot;: &quot;271810cc-1f1f-4c41-8973-8463a1955421&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d854a743-9d6b-47ea-925e-da8b3f68a075&quot;,
                        &quot;parentUUID&quot;: &quot;271810cc-1f1f-4c41-8973-8463a1955421&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;271810cc-1f1f-4c41-8973-8463a1955421&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b2ac5a0d-ca5d-4472-a26c-75b0db5ba26c&quot;,
                        &quot;parentUUID&quot;: &quot;271810cc-1f1f-4c41-8973-8463a1955421&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d854a743-9d6b-47ea-925e-da8b3f68a075&quot;,
                        &quot;parentUUID&quot;: &quot;271810cc-1f1f-4c41-8973-8463a1955421&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 4,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getAgent&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgent Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8e69b9d4-2d10-4a54-8f1d-eb1128fa733a&quot;,
                        &quot;parentUUID&quot;: &quot;d501a162-deaa-4a3d-87cc-05a7871daa02&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgent Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = agents.getAgent(&#x27;mock_name&#x27;);\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;25b8a6a1-f229-4daa-896b-36897deb9329&quot;,
                        &quot;parentUUID&quot;: &quot;d501a162-deaa-4a3d-87cc-05a7871daa02&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;d501a162-deaa-4a3d-87cc-05a7871daa02&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgent Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8e69b9d4-2d10-4a54-8f1d-eb1128fa733a&quot;,
                        &quot;parentUUID&quot;: &quot;d501a162-deaa-4a3d-87cc-05a7871daa02&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgent Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = agents.getAgent(&#x27;mock_name&#x27;);\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;25b8a6a1-f229-4daa-896b-36897deb9329&quot;,
                        &quot;parentUUID&quot;: &quot;d501a162-deaa-4a3d-87cc-05a7871daa02&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getAgentList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;2&#x27;});\ndynamo_client.scan.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d151a69c-b5f1-4f40-bef6-ecf8ff627c9c&quot;,
                        &quot;parentUUID&quot;: &quot;85405992-e8cd-44a4-a7d1-8ed755a7b79e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgentList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;eeef799f-d07e-4504-870b-89f1c4550a59&quot;,
                        &quot;parentUUID&quot;: &quot;85405992-e8cd-44a4-a7d1-8ed755a7b79e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;85405992-e8cd-44a4-a7d1-8ed755a7b79e&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;2&#x27;});\ndynamo_client.scan.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d151a69c-b5f1-4f40-bef6-ecf8ff627c9c&quot;,
                        &quot;parentUUID&quot;: &quot;85405992-e8cd-44a4-a7d1-8ed755a7b79e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB getAgentList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;eeef799f-d07e-4504-870b-89f1c4550a59&quot;,
                        &quot;parentUUID&quot;: &quot;85405992-e8cd-44a4-a7d1-8ed755a7b79e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 5,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeAgent&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB removeAgent Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\&quot;error removing rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ea52fb1f-3f4f-4dba-aa75-c6e5d398e644&quot;,
                        &quot;parentUUID&quot;: &quot;f898a002-50f7-45a7-8577-dd720980b622&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB removeAgent Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\&quot;success\&quot;});\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5fcf6b0d-9fa3-431c-98e9-5730d5ad5a4b&quot;,
                        &quot;parentUUID&quot;: &quot;f898a002-50f7-45a7-8577-dd720980b622&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;f898a002-50f7-45a7-8577-dd720980b622&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB removeAgent Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\&quot;error removing rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ea52fb1f-3f4f-4dba-aa75-c6e5d398e644&quot;,
                        &quot;parentUUID&quot;: &quot;f898a002-50f7-45a7-8577-dd720980b622&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB removeAgent Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\&quot;success\&quot;});\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5fcf6b0d-9fa3-431c-98e9-5730d5ad5a4b&quot;,
                        &quot;parentUUID&quot;: &quot;f898a002-50f7-45a7-8577-dd720980b622&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateAgent&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB updateAgent Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d3b1d60c-682e-4e92-ad36-9bc74c7fcf88&quot;,
                        &quot;parentUUID&quot;: &quot;5660c634-c2d6-4b65-9cf1-9fd4e3ff287a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB updateAgent Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3fe30903-df2c-427d-992c-21ab970a6283&quot;,
                        &quot;parentUUID&quot;: &quot;5660c634-c2d6-4b65-9cf1-9fd4e3ff287a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;5660c634-c2d6-4b65-9cf1-9fd4e3ff287a&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB updateAgent Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d3b1d60c-682e-4e92-ad36-9bc74c7fcf88&quot;,
                        &quot;parentUUID&quot;: &quot;5660c634-c2d6-4b65-9cf1-9fd4e3ff287a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;AgentsDAODynamoDB updateAgent Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3fe30903-df2c-427d-992c-21ab970a6283&quot;,
                        &quot;parentUUID&quot;: &quot;5660c634-c2d6-4b65-9cf1-9fd4e3ff287a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 6,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;3046ae4b-4769-4e72-85d4-ad2b7fc647b0&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;2131fa43-bdb2-4a0d-93c7-d8108788f658&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;d4f30df4-3df2-4d13-9466-940c3636d528&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;VirtualAssistant&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;ApiAiVAAdapter&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;query&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
                        &quot;fullTitle&quot;: &quot;ApiAiVAAdapter query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;38ea45b1-986f-4ac7-a6dd-cb723376086a&quot;,
                        &quot;parentUUID&quot;: &quot;cd4ec5b9-8d71-4bc5-b5ce-522790eba84a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
                        &quot;fullTitle&quot;: &quot;ApiAiVAAdapter query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9436f267-b973-44d9-8fdb-033d4d248f37&quot;,
                        &quot;parentUUID&quot;: &quot;cd4ec5b9-8d71-4bc5-b5ce-522790eba84a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ApiAiVAAdapter.js&quot;,
                    &quot;uuid&quot;: &quot;cd4ec5b9-8d71-4bc5-b5ce-522790eba84a&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
                        &quot;fullTitle&quot;: &quot;ApiAiVAAdapter query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;38ea45b1-986f-4ac7-a6dd-cb723376086a&quot;,
                        &quot;parentUUID&quot;: &quot;cd4ec5b9-8d71-4bc5-b5ce-522790eba84a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
                        &quot;fullTitle&quot;: &quot;ApiAiVAAdapter query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9436f267-b973-44d9-8fdb-033d4d248f37&quot;,
                        &quot;parentUUID&quot;: &quot;cd4ec5b9-8d71-4bc5-b5ce-522790eba84a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 5,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ApiAiVAAdapter.js&quot;,
                &quot;uuid&quot;: &quot;5e40cf00-b8ac-473f-982f-67c17fa10f71&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ApiAiVAAdapter.js&quot;,
            &quot;uuid&quot;: &quot;f9d19870-3dab-4f85-aa53-bd6d888f5eed&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ApiAiVAAdapter.js&quot;,
        &quot;uuid&quot;: &quot;2840b216-9b1d-47f2-9154-3efc072bce1d&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Conversations&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;ConversationsDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addConversation&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \&quot;Requested resource not found\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e0331540-b400-4e9b-90e6-c9e59c94d6b7&quot;,
                        &quot;parentUUID&quot;: &quot;a2264cdb-ff82-4bbc-8055-dbe3c1b363d5&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;764d9115-ec97-4040-881c-441129b7c934&quot;,
                        &quot;parentUUID&quot;: &quot;a2264cdb-ff82-4bbc-8055-dbe3c1b363d5&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;a2264cdb-ff82-4bbc-8055-dbe3c1b363d5&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \&quot;Requested resource not found\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e0331540-b400-4e9b-90e6-c9e59c94d6b7&quot;,
                        &quot;parentUUID&quot;: &quot;a2264cdb-ff82-4bbc-8055-dbe3c1b363d5&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;764d9115-ec97-4040-881c-441129b7c934&quot;,
                        &quot;parentUUID&quot;: &quot;a2264cdb-ff82-4bbc-8055-dbe3c1b363d5&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;addMessage&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \&quot;error adding message\&quot; });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e22464f1-289c-40ce-a381-6bd7a8cd4067&quot;,
                        &quot;parentUUID&quot;: &quot;96376b9f-90cd-417d-b93f-e03966923ae8&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4a8d5266-fe07-4ed5-94b3-a97ea0f6f8c4&quot;,
                        &quot;parentUUID&quot;: &quot;96376b9f-90cd-417d-b93f-e03966923ae8&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;96376b9f-90cd-417d-b93f-e03966923ae8&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \&quot;error adding message\&quot; });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e22464f1-289c-40ce-a381-6bd7a8cd4067&quot;,
                        &quot;parentUUID&quot;: &quot;96376b9f-90cd-417d-b93f-e03966923ae8&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4a8d5266-fe07-4ed5-94b3-a97ea0f6f8c4&quot;,
                        &quot;parentUUID&quot;: &quot;96376b9f-90cd-417d-b93f-e03966923ae8&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getConversation&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \&quot;error downloading conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7e9938b1-c86a-43d4-9694-c2119a23f457&quot;,
                        &quot;parentUUID&quot;: &quot;c5b491fd-0ff0-47a8-b08e-8d44805b5e91&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversation Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;920b6361-6aca-4bea-b50b-ca27082e4f0b&quot;,
                        &quot;parentUUID&quot;: &quot;c5b491fd-0ff0-47a8-b08e-8d44805b5e91&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;c5b491fd-0ff0-47a8-b08e-8d44805b5e91&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \&quot;error downloading conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7e9938b1-c86a-43d4-9694-c2119a23f457&quot;,
                        &quot;parentUUID&quot;: &quot;c5b491fd-0ff0-47a8-b08e-8d44805b5e91&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversation Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;920b6361-6aca-4bea-b50b-ca27082e4f0b&quot;,
                        &quot;parentUUID&quot;: &quot;c5b491fd-0ff0-47a8-b08e-8d44805b5e91&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getConversationList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5fb2f987-5649-4ce6-a9fe-bc55b45a1b03&quot;,
                        &quot;parentUUID&quot;: &quot;16a7d0ec-eff6-4c1e-b0a2-96b5023f28b7&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversationList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;11d6689d-a037-4747-a229-954415b8f9bb&quot;,
                        &quot;parentUUID&quot;: &quot;16a7d0ec-eff6-4c1e-b0a2-96b5023f28b7&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;16a7d0ec-eff6-4c1e-b0a2-96b5023f28b7&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5fb2f987-5649-4ce6-a9fe-bc55b45a1b03&quot;,
                        &quot;parentUUID&quot;: &quot;16a7d0ec-eff6-4c1e-b0a2-96b5023f28b7&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB getConversationList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;11d6689d-a037-4747-a229-954415b8f9bb&quot;,
                        &quot;parentUUID&quot;: &quot;16a7d0ec-eff6-4c1e-b0a2-96b5023f28b7&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeConversation&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c4cc0b0b-6b8f-41ea-9a53-91e16588f888&quot;,
                        &quot;parentUUID&quot;: &quot;593b6f34-b5fb-4e1f-8117-88ce31efb1d6&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5798ff59-f615-40a4-9379-e3367c09bca1&quot;,
                        &quot;parentUUID&quot;: &quot;593b6f34-b5fb-4e1f-8117-88ce31efb1d6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;593b6f34-b5fb-4e1f-8117-88ce31efb1d6&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c4cc0b0b-6b8f-41ea-9a53-91e16588f888&quot;,
                        &quot;parentUUID&quot;: &quot;593b6f34-b5fb-4e1f-8117-88ce31efb1d6&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5798ff59-f615-40a4-9379-e3367c09bca1&quot;,
                        &quot;parentUUID&quot;: &quot;593b6f34-b5fb-4e1f-8117-88ce31efb1d6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;6a7e4e6c-da1e-4225-97ca-08f31684798b&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;7dea5370-4322-4827-9d28-27c99eca1877&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;8c063502-d510-422e-90dc-a06bc6dc0a12&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;ConversationWebhookService&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;webhook&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
                    &quot;fullTitle&quot;: &quot;ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 6,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;body.result.action = &#x27;user.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;admin&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;b7c17fae-a330-4285-888b-84e73a2eb799&quot;,
                    &quot;parentUUID&quot;: &quot;8cf54c2f-0e48-44d6-b5d7-c1237ee754da&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
                    &quot;fullTitle&quot;: &quot;ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;body.result.action = &#x27;guest.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;, company : \&quot;Google\&quot;}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;welcome&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;1c5bed1b-549e-4c01-9ed2-e8e8a5b59c47&quot;,
                    &quot;parentUUID&quot;: &quot;8cf54c2f-0e48-44d6-b5d7-c1237ee754da&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ConversationWebhookService.js&quot;,
                &quot;uuid&quot;: &quot;8cf54c2f-0e48-44d6-b5d7-c1237ee754da&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationWebhookService.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
                    &quot;fullTitle&quot;: &quot;ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 6,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;body.result.action = &#x27;user.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;admin&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;b7c17fae-a330-4285-888b-84e73a2eb799&quot;,
                    &quot;parentUUID&quot;: &quot;8cf54c2f-0e48-44d6-b5d7-c1237ee754da&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
                    &quot;fullTitle&quot;: &quot;ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;body.result.action = &#x27;guest.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;, company : \&quot;Google\&quot;}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;welcome&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;1c5bed1b-549e-4c01-9ed2-e8e8a5b59c47&quot;,
                    &quot;parentUUID&quot;: &quot;8cf54c2f-0e48-44d6-b5d7-c1237ee754da&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 2,
                &quot;totalPasses&quot;: 2,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 8,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ConversationWebhookService.js&quot;,
            &quot;uuid&quot;: &quot;60d145f5-c49a-4745-b908-f45571f9e2c1&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationWebhookService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ConversationWebhookService.js&quot;,
        &quot;uuid&quot;: &quot;6f413025-f35f-453a-9124-0e7ff921f02f&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ConversationWebhookService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Libs&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;ErrorObserver&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;next&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ErrorObserver next Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;expect(obs.next.bind(obs)).to.throw();&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;7bf001b9-14e5-43f5-91b2-55a3a172db23&quot;,
                    &quot;parentUUID&quot;: &quot;2832d5dc-6eab-4ce3-ab05-429192baf2b5&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ErrorObserver.js&quot;,
                &quot;uuid&quot;: &quot;2832d5dc-6eab-4ce3-ab05-429192baf2b5&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ErrorObserver.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ErrorObserver next Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;expect(obs.next.bind(obs)).to.throw();&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;7bf001b9-14e5-43f5-91b2-55a3a172db23&quot;,
                    &quot;parentUUID&quot;: &quot;2832d5dc-6eab-4ce3-ab05-429192baf2b5&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 1,
                &quot;totalPasses&quot;: 1,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 1,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ErrorObserver.js&quot;,
            &quot;uuid&quot;: &quot;0f036a92-1870-4e2d-8432-711ef5804e76&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ErrorObserver.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ErrorObserver.js&quot;,
        &quot;uuid&quot;: &quot;c7d55b83-8d45-42c4-b1a2-69bef7520196&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ErrorObserver.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Guests&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;GuestsDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addGuest&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ba7a3292-d981-45db-87b3-320d5225e372&quot;,
                        &quot;parentUUID&quot;: &quot;fbf94060-5c23-4d02-a23f-2b8159a9a9c9&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addGuest Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addGuest(&#x27;mauro&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a7ac054b-9f0c-40ba-a159-e0d73b819b33&quot;,
                        &quot;parentUUID&quot;: &quot;fbf94060-5c23-4d02-a23f-2b8159a9a9c9&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;fbf94060-5c23-4d02-a23f-2b8159a9a9c9&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ba7a3292-d981-45db-87b3-320d5225e372&quot;,
                        &quot;parentUUID&quot;: &quot;fbf94060-5c23-4d02-a23f-2b8159a9a9c9&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addGuest Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addGuest(&#x27;mauro&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a7ac054b-9f0c-40ba-a159-e0d73b819b33&quot;,
                        &quot;parentUUID&quot;: &quot;fbf94060-5c23-4d02-a23f-2b8159a9a9c9&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getGuest&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \&quot;error getting data\&quot; });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;34286308-449b-4cfb-b847-d6935bd368a6&quot;,
                        &quot;parentUUID&quot;: &quot;6c067e6c-6c8b-454f-a7e3-d950fb0a759a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuest Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \&quot;Mauro\&quot;);\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\&quot;Zero12\&quot;);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;58eb8708-39e9-4097-8efb-cef8fa2d136e&quot;,
                        &quot;parentUUID&quot;: &quot;6c067e6c-6c8b-454f-a7e3-d950fb0a759a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;6c067e6c-6c8b-454f-a7e3-d950fb0a759a&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \&quot;error getting data\&quot; });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;34286308-449b-4cfb-b847-d6935bd368a6&quot;,
                        &quot;parentUUID&quot;: &quot;6c067e6c-6c8b-454f-a7e3-d950fb0a759a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuest Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \&quot;Mauro\&quot;);\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\&quot;Zero12\&quot;);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;58eb8708-39e9-4097-8efb-cef8fa2d136e&quot;,
                        &quot;parentUUID&quot;: &quot;6c067e6c-6c8b-454f-a7e3-d950fb0a759a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getGuestList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }], LastEvaluatedKey: &#x27;Luca&#x27;});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f69e29f9-43b0-4d4e-b643-f3fe2faaf418&quot;,
                        &quot;parentUUID&quot;: &quot;68008c55-3c83-4bf0-80b0-c04d088146ff&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuestList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c7e77fab-0d3d-42f8-b91c-0d9f45023f25&quot;,
                        &quot;parentUUID&quot;: &quot;68008c55-3c83-4bf0-80b0-c04d088146ff&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;68008c55-3c83-4bf0-80b0-c04d088146ff&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }], LastEvaluatedKey: &#x27;Luca&#x27;});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f69e29f9-43b0-4d4e-b643-f3fe2faaf418&quot;,
                        &quot;parentUUID&quot;: &quot;68008c55-3c83-4bf0-80b0-c04d088146ff&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB getGuestList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c7e77fab-0d3d-42f8-b91c-0d9f45023f25&quot;,
                        &quot;parentUUID&quot;: &quot;68008c55-3c83-4bf0-80b0-c04d088146ff&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeGuest&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing guest\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7e44c3a2-b685-47b6-af99-02c9aed30f61&quot;,
                        &quot;parentUUID&quot;: &quot;ab77ccba-5ac2-4a6e-b117-160991999bdc&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB removeGuest Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;33b2f989-36a5-4a8d-a2b5-80e8e2f345f2&quot;,
                        &quot;parentUUID&quot;: &quot;ab77ccba-5ac2-4a6e-b117-160991999bdc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;ab77ccba-5ac2-4a6e-b117-160991999bdc&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing guest\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7e44c3a2-b685-47b6-af99-02c9aed30f61&quot;,
                        &quot;parentUUID&quot;: &quot;ab77ccba-5ac2-4a6e-b117-160991999bdc&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB removeGuest Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;33b2f989-36a5-4a8d-a2b5-80e8e2f345f2&quot;,
                        &quot;parentUUID&quot;: &quot;ab77ccba-5ac2-4a6e-b117-160991999bdc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateGuest&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating guest\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;aec03e00-faea-4fb5-89e9-bd7a6a0b74c7&quot;,
                        &quot;parentUUID&quot;: &quot;d9f00da6-095f-4d67-8e26-267e2cc18562&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9e60621b-df5c-46d3-91d4-48edb170f56e&quot;,
                        &quot;parentUUID&quot;: &quot;d9f00da6-095f-4d67-8e26-267e2cc18562&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;d9f00da6-095f-4d67-8e26-267e2cc18562&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating guest\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;aec03e00-faea-4fb5-89e9-bd7a6a0b74c7&quot;,
                        &quot;parentUUID&quot;: &quot;d9f00da6-095f-4d67-8e26-267e2cc18562&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9e60621b-df5c-46d3-91d4-48edb170f56e&quot;,
                        &quot;parentUUID&quot;: &quot;d9f00da6-095f-4d67-8e26-267e2cc18562&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;addConversation&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addConversation Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d3816f27-c751-4b9e-bd5d-7513dd19edcc&quot;,
                        &quot;parentUUID&quot;: &quot;a5895612-deec-406e-86ae-7bbfd2179a2e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addConversation Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8d1b7052-8b4c-4c49-b68b-a2c3ce17174a&quot;,
                        &quot;parentUUID&quot;: &quot;a5895612-deec-406e-86ae-7bbfd2179a2e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;a5895612-deec-406e-86ae-7bbfd2179a2e&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addConversation Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d3816f27-c751-4b9e-bd5d-7513dd19edcc&quot;,
                        &quot;parentUUID&quot;: &quot;a5895612-deec-406e-86ae-7bbfd2179a2e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;GuestsDAODynamoDB addConversation Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8d1b7052-8b4c-4c49-b68b-a2c3ce17174a&quot;,
                        &quot;parentUUID&quot;: &quot;a5895612-deec-406e-86ae-7bbfd2179a2e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;253a0b01-cb4a-41cc-8502-d2824e4ec510&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;eb2c6d3d-6d27-4991-9d60-d1294040b92d&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;8e0a14f9-818d-44ff-a2e2-6988055c6334&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Members&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;MembersDAOSlack&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addMember&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack addMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.addMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9124e0dc-9a80-4804-ade8-1715f0aa7f91&quot;,
                        &quot;parentUUID&quot;: &quot;b288877f-c889-45c7-9c3b-df02e109c51c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;b288877f-c889-45c7-9c3b-df02e109c51c&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack addMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.addMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9124e0dc-9a80-4804-ade8-1715f0aa7f91&quot;,
                        &quot;parentUUID&quot;: &quot;b288877f-c889-45c7-9c3b-df02e109c51c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getMember&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMember Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t&#x27;ok&#x27;: true,\n\t&#x27;user&#x27;:\n\t{\n\t\t&#x27;id&#x27;: &#x27;U023BECGF&#x27;,\n\t\t&#x27;name&#x27;: &#x27;bobby&#x27;,\n\t\t&#x27;deleted&#x27;: false,\n\t\t&#x27;color&#x27;: &#x27;9f69e7&#x27;,\n\t\t&#x27;profile&#x27;:\n\t\t{\n\t\t\t&#x27;avatar_hash&#x27;: &#x27;ge3b51ca72de&#x27;,\n\t\t\t&#x27;current_status&#x27;: &#x27;:mountain_railway: riding a train&#x27;,\n\t\t\t&#x27;first_name&#x27;: &#x27;Bobby&#x27;,\n\t\t\t&#x27;last_name&#x27;: &#x27;Tables&#x27;,\n\t\t\t&#x27;real_name&#x27;: &#x27;Bobby Tables&#x27;,\n\t\t\t&#x27;email&#x27;: &#x27;bobby@slack.com&#x27;,\n\t\t\t&#x27;skype&#x27;: &#x27;my-skype-name&#x27;,\n\t\t\t&#x27;phone&#x27;: &#x27;+1 (123) 456 7890&#x27;\n\t\t},\n\t\t&#x27;is_admin&#x27;: true,\n\t\t&#x27;is_owner&#x27;: true,\n\t\t&#x27;updated&#x27;: 1490054400,\n\t\t&#x27;has_2fa&#x27;: true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e638043b-92ea-4de7-bece-8a1b5392234a&quot;,
                        &quot;parentUUID&quot;: &quot;850684c7-c07a-439c-af8d-2009e90abe3f&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMember Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;44eb039c-9826-4af6-a33f-9acba7143eca&quot;,
                        &quot;parentUUID&quot;: &quot;850684c7-c07a-439c-af8d-2009e90abe3f&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;850684c7-c07a-439c-af8d-2009e90abe3f&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMember Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t&#x27;ok&#x27;: true,\n\t&#x27;user&#x27;:\n\t{\n\t\t&#x27;id&#x27;: &#x27;U023BECGF&#x27;,\n\t\t&#x27;name&#x27;: &#x27;bobby&#x27;,\n\t\t&#x27;deleted&#x27;: false,\n\t\t&#x27;color&#x27;: &#x27;9f69e7&#x27;,\n\t\t&#x27;profile&#x27;:\n\t\t{\n\t\t\t&#x27;avatar_hash&#x27;: &#x27;ge3b51ca72de&#x27;,\n\t\t\t&#x27;current_status&#x27;: &#x27;:mountain_railway: riding a train&#x27;,\n\t\t\t&#x27;first_name&#x27;: &#x27;Bobby&#x27;,\n\t\t\t&#x27;last_name&#x27;: &#x27;Tables&#x27;,\n\t\t\t&#x27;real_name&#x27;: &#x27;Bobby Tables&#x27;,\n\t\t\t&#x27;email&#x27;: &#x27;bobby@slack.com&#x27;,\n\t\t\t&#x27;skype&#x27;: &#x27;my-skype-name&#x27;,\n\t\t\t&#x27;phone&#x27;: &#x27;+1 (123) 456 7890&#x27;\n\t\t},\n\t\t&#x27;is_admin&#x27;: true,\n\t\t&#x27;is_owner&#x27;: true,\n\t\t&#x27;updated&#x27;: 1490054400,\n\t\t&#x27;has_2fa&#x27;: true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e638043b-92ea-4de7-bece-8a1b5392234a&quot;,
                        &quot;parentUUID&quot;: &quot;850684c7-c07a-439c-af8d-2009e90abe3f&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMember Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;44eb039c-9826-4af6-a33f-9acba7143eca&quot;,
                        &quot;parentUUID&quot;: &quot;850684c7-c07a-439c-af8d-2009e90abe3f&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getMemberList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMemberList L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\&quot;ok\&quot;: true,\n\t\&quot;members\&quot;:\n\t[\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECGF\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;mauro\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Mauro Bocciofilo\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t},\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECLL\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;bobby\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;,\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0d356164-ba47-4a63-ba02-141042f2198b&quot;,
                        &quot;parentUUID&quot;: &quot;41aa1ca7-8ac2-423f-84c2-bd66a990cbce&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMemberList Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2f4e768c-db0f-4671-8c61-e549cf1d4a9f&quot;,
                        &quot;parentUUID&quot;: &quot;41aa1ca7-8ac2-423f-84c2-bd66a990cbce&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;41aa1ca7-8ac2-423f-84c2-bd66a990cbce&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMemberList L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\&quot;ok\&quot;: true,\n\t\&quot;members\&quot;:\n\t[\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECGF\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;mauro\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Mauro Bocciofilo\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t},\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECLL\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;bobby\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;,\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0d356164-ba47-4a63-ba02-141042f2198b&quot;,
                        &quot;parentUUID&quot;: &quot;41aa1ca7-8ac2-423f-84c2-bd66a990cbce&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack getMemberList Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2f4e768c-db0f-4671-8c61-e549cf1d4a9f&quot;,
                        &quot;parentUUID&quot;: &quot;41aa1ca7-8ac2-423f-84c2-bd66a990cbce&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeMember&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack removeMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.removeMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b977af02-994d-4ef2-869b-c8ba632b66bc&quot;,
                        &quot;parentUUID&quot;: &quot;eb4eca28-7408-4537-b9ed-9fa99c4124d0&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;eb4eca28-7408-4537-b9ed-9fa99c4124d0&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack removeMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.removeMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b977af02-994d-4ef2-869b-c8ba632b66bc&quot;,
                        &quot;parentUUID&quot;: &quot;eb4eca28-7408-4537-b9ed-9fa99c4124d0&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateMember&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack updateMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.updateMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;83627090-20af-45ef-a6f6-6ee4068f60f0&quot;,
                        &quot;parentUUID&quot;: &quot;06e6b702-ebfd-49a7-827d-040496396199&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;uuid&quot;: &quot;06e6b702-ebfd-49a7-827d-040496396199&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;MembersDAOSlack updateMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;members.updateMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;83627090-20af-45ef-a6f6-6ee4068f60f0&quot;,
                        &quot;parentUUID&quot;: &quot;06e6b702-ebfd-49a7-827d-040496396199&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
                &quot;uuid&quot;: &quot;a4e48bb9-0de1-4846-8e09-ccaf130cb855&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
            &quot;uuid&quot;: &quot;62ac6039-7a3f-439f-b0ab-935508de2622&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_MembersDAOSlack.js&quot;,
        &quot;uuid&quot;: &quot;1d63680e-d16a-4c1c-94b5-d67942b6d376&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Notifications&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;NotificationService&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;getChannelList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(&#x27;errore&#x27;);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n  done();\n}&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fe08a1c2-6614-4a6f-b0ce-e0c3740a1572&quot;,
                        &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields(&#x27;errore&#x27;);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;950753c4-de38-4569-b415-4de68b12ba70&quot;,
                        &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 10,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(&#x27;errore&#x27;);\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3745ba25-aac2-487b-9b7e-b7a1936169c2&quot;,
                        &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 200);\n  done();\n}&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;79c9a493-9ecd-4664-8296-095fd3448985&quot;,
                        &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
                    &quot;uuid&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(&#x27;errore&#x27;);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n  done();\n}&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fe08a1c2-6614-4a6f-b0ce-e0c3740a1572&quot;,
                        &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields(&#x27;errore&#x27;);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;950753c4-de38-4569-b415-4de68b12ba70&quot;,
                        &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 10,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(&#x27;errore&#x27;);\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3745ba25-aac2-487b-9b7e-b7a1936169c2&quot;,
                        &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 200);\n  done();\n}&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;79c9a493-9ecd-4664-8296-095fd3448985&quot;,
                        &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 4,
                    &quot;totalPasses&quot;: 4,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 16,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;sendMsg&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(&#x27;errore&#x27;);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c97cd393-9c5e-4a7d-b87c-df4b9ed2ec40&quot;,
                        &quot;parentUUID&quot;: &quot;82121586-7ebf-4b8f-81ad-482f20e1f150&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b48e593e-60f4-4d74-bdc3-5116e68ed400&quot;,
                        &quot;parentUUID&quot;: &quot;82121586-7ebf-4b8f-81ad-482f20e1f150&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\n\nexpect(context.succeed.callCount).to.equal(1);\t\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;dcf38ebe-517a-44db-a8eb-e406e807bc87&quot;,
                        &quot;parentUUID&quot;: &quot;82121586-7ebf-4b8f-81ad-482f20e1f150&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
                    &quot;uuid&quot;: &quot;82121586-7ebf-4b8f-81ad-482f20e1f150&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(&#x27;errore&#x27;);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c97cd393-9c5e-4a7d-b87c-df4b9ed2ec40&quot;,
                        &quot;parentUUID&quot;: &quot;82121586-7ebf-4b8f-81ad-482f20e1f150&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b48e593e-60f4-4d74-bdc3-5116e68ed400&quot;,
                        &quot;parentUUID&quot;: &quot;82121586-7ebf-4b8f-81ad-482f20e1f150&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;NotificationService sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\n\nexpect(context.succeed.callCount).to.equal(1);\t\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;dcf38ebe-517a-44db-a8eb-e406e807bc87&quot;,
                        &quot;parentUUID&quot;: &quot;82121586-7ebf-4b8f-81ad-482f20e1f150&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
                &quot;uuid&quot;: &quot;d3921629-41e9-4c62-bd9e-fd9421197187&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
            &quot;uuid&quot;: &quot;397ca687-6b56-4348-9c3e-8c5014885727&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_NotificationService.js&quot;,
        &quot;uuid&quot;: &quot;4ef7ff53-71eb-4409-81fc-dd4fa432f2bd&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Libs&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;ObserverAdapter&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;complete&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare complete_cb&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Deve chiamare complete_cb&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \&quot;il callback di complete non è stato chiamato esattamente una volta.\&quot;).to.equal(1);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;266356f0-2c09-457e-9898-88d0353aec28&quot;,
                    &quot;parentUUID&quot;: &quot;1f4096b9-07ac-4666-ad60-fe12faafafb9&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;541466b2-1e94-40f3-b81e-41c33f564c8e&quot;,
                    &quot;parentUUID&quot;: &quot;1f4096b9-07ac-4666-ad60-fe12faafafb9&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;87a4d294-1116-4de3-9e67-fe953327534f&quot;,
                    &quot;parentUUID&quot;: &quot;1f4096b9-07ac-4666-ad60-fe12faafafb9&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;uuid&quot;: &quot;1f4096b9-07ac-4666-ad60-fe12faafafb9&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare complete_cb&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Deve chiamare complete_cb&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \&quot;il callback di complete non è stato chiamato esattamente una volta.\&quot;).to.equal(1);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;266356f0-2c09-457e-9898-88d0353aec28&quot;,
                    &quot;parentUUID&quot;: &quot;1f4096b9-07ac-4666-ad60-fe12faafafb9&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;541466b2-1e94-40f3-b81e-41c33f564c8e&quot;,
                    &quot;parentUUID&quot;: &quot;1f4096b9-07ac-4666-ad60-fe12faafafb9&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter complete Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;87a4d294-1116-4de3-9e67-fe953327534f&quot;,
                    &quot;parentUUID&quot;: &quot;1f4096b9-07ac-4666-ad60-fe12faafafb9&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 3,
                &quot;totalPasses&quot;: 3,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 1,
                &quot;rootEmpty&quot;: false
              },
              {
                &quot;title&quot;: &quot;error&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare error_cb&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Deve chiamare error_cb&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;b867b36e-175a-4938-84a4-66e65009b5df&quot;,
                    &quot;parentUUID&quot;: &quot;c18b6f7b-5fe0-4324-8600-39dc0fffd4a8&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onError(success);\nobs.pause();\nobs.error(&#x27;errore&#x27;);\n        expect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;a0bb7ace-983c-4e07-b96a-5ed6f32b2fe4&quot;,
                    &quot;parentUUID&quot;: &quot;c18b6f7b-5fe0-4324-8600-39dc0fffd4a8&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;486b05b9-6abe-470c-bf32-14527d9b8e92&quot;,
                    &quot;parentUUID&quot;: &quot;c18b6f7b-5fe0-4324-8600-39dc0fffd4a8&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;uuid&quot;: &quot;c18b6f7b-5fe0-4324-8600-39dc0fffd4a8&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare error_cb&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Deve chiamare error_cb&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;b867b36e-175a-4938-84a4-66e65009b5df&quot;,
                    &quot;parentUUID&quot;: &quot;c18b6f7b-5fe0-4324-8600-39dc0fffd4a8&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onError(success);\nobs.pause();\nobs.error(&#x27;errore&#x27;);\n        expect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;a0bb7ace-983c-4e07-b96a-5ed6f32b2fe4&quot;,
                    &quot;parentUUID&quot;: &quot;c18b6f7b-5fe0-4324-8600-39dc0fffd4a8&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter error Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;486b05b9-6abe-470c-bf32-14527d9b8e92&quot;,
                    &quot;parentUUID&quot;: &quot;c18b6f7b-5fe0-4324-8600-39dc0fffd4a8&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 3,
                &quot;totalPasses&quot;: 3,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 1,
                &quot;rootEmpty&quot;: false
              },
              {
                &quot;title&quot;: &quot;next&quot;,
                &quot;suites&quot;: [],
                &quot;tests&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal(&#x27;data&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;bd61bd1b-348a-4518-989d-4dcbddb6b98a&quot;,
                    &quot;parentUUID&quot;: &quot;64a152d5-e756-42c1-b3a8-1340d96b4c84&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.pause();\nobs.next(&#x27;Function called&#x27;);\nexpect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;99675446-3ae4-43d7-abd1-63593239fff9&quot;,
                    &quot;parentUUID&quot;: &quot;64a152d5-e756-42c1-b3a8-1340d96b4c84&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next(&#x27;other data&#x27;);\nexpect(success.callCount).to.equal(2);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;ad0c76c9-3bfd-455a-8f43-e795f029d3a8&quot;,
                    &quot;parentUUID&quot;: &quot;64a152d5-e756-42c1-b3a8-1340d96b4c84&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;uuid&quot;: &quot;64a152d5-e756-42c1-b3a8-1340d96b4c84&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
                &quot;passes&quot;: [
                  {
                    &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal(&#x27;data&#x27;);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;bd61bd1b-348a-4518-989d-4dcbddb6b98a&quot;,
                    &quot;parentUUID&quot;: &quot;64a152d5-e756-42c1-b3a8-1340d96b4c84&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.pause();\nobs.next(&#x27;Function called&#x27;);\nexpect(success.callCount).to.equal(0);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;99675446-3ae4-43d7-abd1-63593239fff9&quot;,
                    &quot;parentUUID&quot;: &quot;64a152d5-e756-42c1-b3a8-1340d96b4c84&quot;,
                    &quot;skipped&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
                    &quot;fullTitle&quot;: &quot;ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
                    &quot;timedOut&quot;: false,
                    &quot;duration&quot;: 0,
                    &quot;state&quot;: &quot;passed&quot;,
                    &quot;speed&quot;: &quot;fast&quot;,
                    &quot;pass&quot;: true,
                    &quot;fail&quot;: false,
                    &quot;pending&quot;: false,
                    &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next(&#x27;other data&#x27;);\nexpect(success.callCount).to.equal(2);&quot;,
                    &quot;err&quot;: {},
                    &quot;isRoot&quot;: false,
                    &quot;uuid&quot;: &quot;ad0c76c9-3bfd-455a-8f43-e795f029d3a8&quot;,
                    &quot;parentUUID&quot;: &quot;64a152d5-e756-42c1-b3a8-1340d96b4c84&quot;,
                    &quot;skipped&quot;: false
                  }
                ],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: true,
                &quot;hasSuites&quot;: false,
                &quot;totalTests&quot;: 3,
                &quot;totalPasses&quot;: 3,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: true,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
            &quot;uuid&quot;: &quot;000c3e7a-ae13-45cb-ad1a-b646b933fd91&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_ObserverAdapter.js&quot;,
        &quot;uuid&quot;: &quot;70d08c46-3acb-4915-afcd-9c67d6c887f0&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Rules&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;RulesDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB addRule Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;14c1f94c-b93c-443d-8b89-52918d25737a&quot;,
                        &quot;parentUUID&quot;: &quot;99cd732f-b8d0-4311-8433-f5148d954952&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB addRule Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;060d651a-0fa5-4a3d-9e88-e39161145e57&quot;,
                        &quot;parentUUID&quot;: &quot;99cd732f-b8d0-4311-8433-f5148d954952&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;99cd732f-b8d0-4311-8433-f5148d954952&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB addRule Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;14c1f94c-b93c-443d-8b89-52918d25737a&quot;,
                        &quot;parentUUID&quot;: &quot;99cd732f-b8d0-4311-8433-f5148d954952&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB addRule Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;060d651a-0fa5-4a3d-9e88-e39161145e57&quot;,
                        &quot;parentUUID&quot;: &quot;99cd732f-b8d0-4311-8433-f5148d954952&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRule Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e9804184-ccfe-4d89-80a9-52cf4c80cf70&quot;,
                        &quot;parentUUID&quot;: &quot;c5b11645-a8b4-4fe7-8cce-9c7558b860ee&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRule Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;845c63bf-6b9a-4b9c-9678-0573261f627f&quot;,
                        &quot;parentUUID&quot;: &quot;c5b11645-a8b4-4fe7-8cce-9c7558b860ee&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;c5b11645-a8b4-4fe7-8cce-9c7558b860ee&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRule Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e9804184-ccfe-4d89-80a9-52cf4c80cf70&quot;,
                        &quot;parentUUID&quot;: &quot;c5b11645-a8b4-4fe7-8cce-9c7558b860ee&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRule Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;845c63bf-6b9a-4b9c-9678-0573261f627f&quot;,
                        &quot;parentUUID&quot;: &quot;c5b11645-a8b4-4fe7-8cce-9c7558b860ee&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getRuleList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8b7cfee7-7f7e-46b8-93e1-43dfbc0dc69c&quot;,
                        &quot;parentUUID&quot;: &quot;52769ebd-e9fe-443a-ae9a-a12e138dcd6a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e0b6284f-36ea-4d9a-a716-d0d4ec002a6a&quot;,
                        &quot;parentUUID&quot;: &quot;52769ebd-e9fe-443a-ae9a-a12e138dcd6a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;//da definire&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6e31b9e0-7848-440f-8ac0-753099b54589&quot;,
                        &quot;parentUUID&quot;: &quot;52769ebd-e9fe-443a-ae9a-a12e138dcd6a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;52769ebd-e9fe-443a-ae9a-a12e138dcd6a&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8b7cfee7-7f7e-46b8-93e1-43dfbc0dc69c&quot;,
                        &quot;parentUUID&quot;: &quot;52769ebd-e9fe-443a-ae9a-a12e138dcd6a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e0b6284f-36ea-4d9a-a716-d0d4ec002a6a&quot;,
                        &quot;parentUUID&quot;: &quot;52769ebd-e9fe-443a-ae9a-a12e138dcd6a&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;//da definire&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6e31b9e0-7848-440f-8ac0-753099b54589&quot;,
                        &quot;parentUUID&quot;: &quot;52769ebd-e9fe-443a-ae9a-a12e138dcd6a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB removeRule Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3ab5c6ea-f59a-47f1-851a-bb7709431644&quot;,
                        &quot;parentUUID&quot;: &quot;3f62f872-6f6d-4557-854c-d840decf9478&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB removeRule Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f2e98598-18b4-4563-8a02-f08ca8ba30f2&quot;,
                        &quot;parentUUID&quot;: &quot;3f62f872-6f6d-4557-854c-d840decf9478&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;3f62f872-6f6d-4557-854c-d840decf9478&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB removeRule Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3ab5c6ea-f59a-47f1-851a-bb7709431644&quot;,
                        &quot;parentUUID&quot;: &quot;3f62f872-6f6d-4557-854c-d840decf9478&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB removeRule Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f2e98598-18b4-4563-8a02-f08ca8ba30f2&quot;,
                        &quot;parentUUID&quot;: &quot;3f62f872-6f6d-4557-854c-d840decf9478&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;473392b8-4ed4-4ebd-b3c7-384d9fc3d1f4&quot;,
                        &quot;parentUUID&quot;: &quot;f9d6a484-0f03-4ec5-8a24-20d2d342e481&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;68bc772f-e4a3-4d8f-9e6e-e4536bf2c9f8&quot;,
                        &quot;parentUUID&quot;: &quot;f9d6a484-0f03-4ec5-8a24-20d2d342e481&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;f9d6a484-0f03-4ec5-8a24-20d2d342e481&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;473392b8-4ed4-4ebd-b3c7-384d9fc3d1f4&quot;,
                        &quot;parentUUID&quot;: &quot;f9d6a484-0f03-4ec5-8a24-20d2d342e481&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesDAODynamoDB updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;68bc772f-e4a3-4d8f-9e6e-e4536bf2c9f8&quot;,
                        &quot;parentUUID&quot;: &quot;f9d6a484-0f03-4ec5-8a24-20d2d342e481&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;c03917da-3fdb-4bba-9bfc-c4cbd9919609&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;a5487b60-0b4c-467e-a4b4-e54f25e0bdba&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_RulesDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;28208888-e1dc-440f-a1f2-0b56ea6140db&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Rules&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;RulesService&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \&quot;\&quot;};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;70ee10f2-237b-4d02-8fc2-c8181e88206e&quot;,
                        &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;578152e8-74c7-4b7e-b00a-5abedb90652c&quot;,
                        &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d1bae73f-4f20-46e6-8d91-cd19b6c8bc1a&quot;,
                        &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0860e059-fb75-40e5-ac35-9e8d5a37626e&quot;,
                        &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \&quot;\&quot;};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;70ee10f2-237b-4d02-8fc2-c8181e88206e&quot;,
                        &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;578152e8-74c7-4b7e-b00a-5abedb90652c&quot;,
                        &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d1bae73f-4f20-46e6-8d91-cd19b6c8bc1a&quot;,
                        &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService addRule Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0860e059-fb75-40e5-ac35-9e8d5a37626e&quot;,
                        &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 4,
                    &quot;totalPasses&quot;: 4,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 4,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;deleteRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9d7aea3e-cfe8-4fba-9401-0f2143380e25&quot;,
                        &quot;parentUUID&quot;: &quot;b0cd57ab-1871-41ef-ad1d-0d8489d24631&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b07d46c0-8d9a-45df-931d-aaf2f933841a&quot;,
                        &quot;parentUUID&quot;: &quot;b0cd57ab-1871-41ef-ad1d-0d8489d24631&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);\n};&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0746403d-d22c-4101-9987-96babe62b01c&quot;,
                        &quot;parentUUID&quot;: &quot;b0cd57ab-1871-41ef-ad1d-0d8489d24631&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;b0cd57ab-1871-41ef-ad1d-0d8489d24631&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9d7aea3e-cfe8-4fba-9401-0f2143380e25&quot;,
                        &quot;parentUUID&quot;: &quot;b0cd57ab-1871-41ef-ad1d-0d8489d24631&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b07d46c0-8d9a-45df-931d-aaf2f933841a&quot;,
                        &quot;parentUUID&quot;: &quot;b0cd57ab-1871-41ef-ad1d-0d8489d24631&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);\n};&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0746403d-d22c-4101-9987-96babe62b01c&quot;,
                        &quot;parentUUID&quot;: &quot;b0cd57ab-1871-41ef-ad1d-0d8489d24631&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f0ac06a3-9f31-4507-97c1-42a59601b383&quot;,
                        &quot;parentUUID&quot;: &quot;c620c4b8-5395-40c5-b511-7007d5fd0082&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;544b0758-2f74-4af7-9e2a-e2131b4338d1&quot;,
                        &quot;parentUUID&quot;: &quot;c620c4b8-5395-40c5-b511-7007d5fd0082&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;db6e92ea-55cd-49cf-9548-c979bf895a54&quot;,
                        &quot;parentUUID&quot;: &quot;c620c4b8-5395-40c5-b511-7007d5fd0082&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;c620c4b8-5395-40c5-b511-7007d5fd0082&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f0ac06a3-9f31-4507-97c1-42a59601b383&quot;,
                        &quot;parentUUID&quot;: &quot;c620c4b8-5395-40c5-b511-7007d5fd0082&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;544b0758-2f74-4af7-9e2a-e2131b4338d1&quot;,
                        &quot;parentUUID&quot;: &quot;c620c4b8-5395-40c5-b511-7007d5fd0082&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;db6e92ea-55cd-49cf-9548-c979bf895a54&quot;,
                        &quot;parentUUID&quot;: &quot;c620c4b8-5395-40c5-b511-7007d5fd0082&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getRuleList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f39aaebc-0b28-4886-9390-9677ae8f2f4a&quot;,
                        &quot;parentUUID&quot;: &quot;65381f65-d23d-45b4-9235-f22e3a7805bc&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3adcdc7f-f49b-4882-915d-ac8057dac137&quot;,
                        &quot;parentUUID&quot;: &quot;65381f65-d23d-45b4-9235-f22e3a7805bc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;65381f65-d23d-45b4-9235-f22e3a7805bc&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f39aaebc-0b28-4886-9390-9677ae8f2f4a&quot;,
                        &quot;parentUUID&quot;: &quot;65381f65-d23d-45b4-9235-f22e3a7805bc&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3adcdc7f-f49b-4882-915d-ac8057dac137&quot;,
                        &quot;parentUUID&quot;: &quot;65381f65-d23d-45b4-9235-f22e3a7805bc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getTaskList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a05a14e2-b44f-409c-bde1-56d0daa1d44f&quot;,
                        &quot;parentUUID&quot;: &quot;13b1946e-df90-4a81-994a-4cb0e9768415&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b0b55a35-1ac8-4cbd-a575-0e257b0dff3d&quot;,
                        &quot;parentUUID&quot;: &quot;13b1946e-df90-4a81-994a-4cb0e9768415&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;13b1946e-df90-4a81-994a-4cb0e9768415&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a05a14e2-b44f-409c-bde1-56d0daa1d44f&quot;,
                        &quot;parentUUID&quot;: &quot;13b1946e-df90-4a81-994a-4cb0e9768415&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b0b55a35-1ac8-4cbd-a575-0e257b0dff3d&quot;,
                        &quot;parentUUID&quot;: &quot;13b1946e-df90-4a81-994a-4cb0e9768415&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8218d9fa-d939-4d9a-adc0-c39f68c8e840&quot;,
                        &quot;parentUUID&quot;: &quot;fa8c5f09-bf69-43ee-8461-e355fd4e2c26&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \&quot;\&quot; , body: \&quot;\&quot;};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8046d304-b28d-486c-b452-ba0a7f1f53a1&quot;,
                        &quot;parentUUID&quot;: &quot;fa8c5f09-bf69-43ee-8461-e355fd4e2c26&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ddccc301-f1ab-422a-bf55-616c435bfc0f&quot;,
                        &quot;parentUUID&quot;: &quot;fa8c5f09-bf69-43ee-8461-e355fd4e2c26&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                    &quot;uuid&quot;: &quot;fa8c5f09-bf69-43ee-8461-e355fd4e2c26&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8218d9fa-d939-4d9a-adc0-c39f68c8e840&quot;,
                        &quot;parentUUID&quot;: &quot;fa8c5f09-bf69-43ee-8461-e355fd4e2c26&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \&quot;\&quot; , body: \&quot;\&quot;};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8046d304-b28d-486c-b452-ba0a7f1f53a1&quot;,
                        &quot;parentUUID&quot;: &quot;fa8c5f09-bf69-43ee-8461-e355fd4e2c26&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;fullTitle&quot;: &quot;RulesService updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ddccc301-f1ab-422a-bf55-616c435bfc0f&quot;,
                        &quot;parentUUID&quot;: &quot;fa8c5f09-bf69-43ee-8461-e355fd4e2c26&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
                &quot;uuid&quot;: &quot;79c3379c-022a-4f13-936f-6a718fc6ecce&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
            &quot;uuid&quot;: &quot;5dfc460d-87dd-49ab-9e0c-8f5eda1e0bfe&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_RulesService.js&quot;,
        &quot;uuid&quot;: &quot;636164bd-e265-4542-af56-c0618adc33a9&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;STT&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;STTWatsonAdapter&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;speechToText&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
                        &quot;fullTitle&quot;: &quot;STTWatsonAdapter speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;eec7a506-bc63-4025-b230-072af4bb118e&quot;,
                        &quot;parentUUID&quot;: &quot;722fee07-a362-4c85-8d65-48385fbd1ba8&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_STTWatsonAdapter.js&quot;,
                    &quot;uuid&quot;: &quot;722fee07-a362-4c85-8d65-48385fbd1ba8&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
                        &quot;fullTitle&quot;: &quot;STTWatsonAdapter speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;eec7a506-bc63-4025-b230-072af4bb118e&quot;,
                        &quot;parentUUID&quot;: &quot;722fee07-a362-4c85-8d65-48385fbd1ba8&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_STTWatsonAdapter.js&quot;,
                &quot;uuid&quot;: &quot;869516ac-0fcd-48c8-9d81-16bb7aa1bf0f&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_STTWatsonAdapter.js&quot;,
            &quot;uuid&quot;: &quot;e0b008ad-4c6e-468c-93fc-53c734b728a3&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_STTWatsonAdapter.js&quot;,
        &quot;uuid&quot;: &quot;36ad5008-f096-4e43-bb84-e74bba2b1ef2&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Tasks&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;TasksDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addTask&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2bc4be46-07a2-4ae9-bac3-0191cbb86bbe&quot;,
                        &quot;parentUUID&quot;: &quot;bdeb3d10-d456-45b9-ab67-86ab4e775fe0&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9f0d3a11-a694-46b8-b03d-664df360da8b&quot;,
                        &quot;parentUUID&quot;: &quot;bdeb3d10-d456-45b9-ab67-86ab4e775fe0&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;bdeb3d10-d456-45b9-ab67-86ab4e775fe0&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;2bc4be46-07a2-4ae9-bac3-0191cbb86bbe&quot;,
                        &quot;parentUUID&quot;: &quot;bdeb3d10-d456-45b9-ab67-86ab4e775fe0&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9f0d3a11-a694-46b8-b03d-664df360da8b&quot;,
                        &quot;parentUUID&quot;: &quot;bdeb3d10-d456-45b9-ab67-86ab4e775fe0&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getTask&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTask Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTask(&#x27;mock_type&#x27;).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8b74b208-52e4-496c-bbc6-cc338bd3ee8b&quot;,
                        &quot;parentUUID&quot;: &quot;4eeffb5f-a5f8-4bd2-8afc-ed29c769c410&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTask Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = tasks.getTask(&#x27;mock_type&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9dad8baf-0b66-41c4-955d-444f670aab07&quot;,
                        &quot;parentUUID&quot;: &quot;4eeffb5f-a5f8-4bd2-8afc-ed29c769c410&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;4eeffb5f-a5f8-4bd2-8afc-ed29c769c410&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTask Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTask(&#x27;mock_type&#x27;).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8b74b208-52e4-496c-bbc6-cc338bd3ee8b&quot;,
                        &quot;parentUUID&quot;: &quot;4eeffb5f-a5f8-4bd2-8afc-ed29c769c410&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTask Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = tasks.getTask(&#x27;mock_type&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9dad8baf-0b66-41c4-955d-444f670aab07&quot;,
                        &quot;parentUUID&quot;: &quot;4eeffb5f-a5f8-4bd2-8afc-ed29c769c410&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getTaskList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \&quot;mock_type3\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d6369442-d023-47d9-acf2-035b5a5f8a97&quot;,
                        &quot;parentUUID&quot;: &quot;7497c08f-8957-4b86-bed8-53971d644988&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTaskList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3a6b58a5-faa5-4226-ab7f-8f1d917de358&quot;,
                        &quot;parentUUID&quot;: &quot;7497c08f-8957-4b86-bed8-53971d644988&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;7497c08f-8957-4b86-bed8-53971d644988&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \&quot;mock_type3\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d6369442-d023-47d9-acf2-035b5a5f8a97&quot;,
                        &quot;parentUUID&quot;: &quot;7497c08f-8957-4b86-bed8-53971d644988&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB getTaskList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;3a6b58a5-faa5-4226-ab7f-8f1d917de358&quot;,
                        &quot;parentUUID&quot;: &quot;7497c08f-8957-4b86-bed8-53971d644988&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeTask&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0619ff56-7e97-40c0-86f2-9622a0e819e8&quot;,
                        &quot;parentUUID&quot;: &quot;7081eace-4a18-4213-b1e5-56f03e766329&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0594ac80-9b39-4832-b0cc-723fd97989d3&quot;,
                        &quot;parentUUID&quot;: &quot;7081eace-4a18-4213-b1e5-56f03e766329&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;7081eace-4a18-4213-b1e5-56f03e766329&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0619ff56-7e97-40c0-86f2-9622a0e819e8&quot;,
                        &quot;parentUUID&quot;: &quot;7081eace-4a18-4213-b1e5-56f03e766329&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0594ac80-9b39-4832-b0cc-723fd97989d3&quot;,
                        &quot;parentUUID&quot;: &quot;7081eace-4a18-4213-b1e5-56f03e766329&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateTask&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5df90199-2eb3-4da5-90f2-2d3c456a4bf9&quot;,
                        &quot;parentUUID&quot;: &quot;bc2ad69b-b590-4b79-ad37-418cc3bb43ca&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;90db800a-403e-4683-a606-cd6e1b574d2a&quot;,
                        &quot;parentUUID&quot;: &quot;bc2ad69b-b590-4b79-ad37-418cc3bb43ca&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;bc2ad69b-b590-4b79-ad37-418cc3bb43ca&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5df90199-2eb3-4da5-90f2-2d3c456a4bf9&quot;,
                        &quot;parentUUID&quot;: &quot;bc2ad69b-b590-4b79-ad37-418cc3bb43ca&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;90db800a-403e-4683-a606-cd6e1b574d2a&quot;,
                        &quot;parentUUID&quot;: &quot;bc2ad69b-b590-4b79-ad37-418cc3bb43ca&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;4589c12a-733a-4735-8353-edf811e1d04a&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;685f0da3-9d80-4d19-8f75-edc4ffb38f41&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_TasksDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;6651810d-d6dd-483a-bf60-bbda742ce67b&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Users&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;UsersDAODynamoDB&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB addUser Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\&quot;Requested resource not found\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;113eb5ba-ef75-4b55-8cfb-9452ea262de3&quot;,
                        &quot;parentUUID&quot;: &quot;f2a56d12-aba8-4270-b126-3bdcf435cc38&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB addUser Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;bbe398fc-ed90-40c2-aeb9-c2a052983167&quot;,
                        &quot;parentUUID&quot;: &quot;f2a56d12-aba8-4270-b126-3bdcf435cc38&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;f2a56d12-aba8-4270-b126-3bdcf435cc38&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB addUser Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\&quot;Requested resource not found\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;113eb5ba-ef75-4b55-8cfb-9452ea262de3&quot;,
                        &quot;parentUUID&quot;: &quot;f2a56d12-aba8-4270-b126-3bdcf435cc38&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB addUser Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;bbe398fc-ed90-40c2-aeb9-c2a052983167&quot;,
                        &quot;parentUUID&quot;: &quot;f2a56d12-aba8-4270-b126-3bdcf435cc38&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUser Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fde4a879-5c96-447b-b3d9-dd551c7c1e27&quot;,
                        &quot;parentUUID&quot;: &quot;7b5bd02f-b262-4e1a-b1c0-9a171f2f422c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUser Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = users.getUser(&#x27;mou&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\n\t\t\t\t\texpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;251d9e86-935a-4c25-99c9-fbfff0c4807e&quot;,
                        &quot;parentUUID&quot;: &quot;7b5bd02f-b262-4e1a-b1c0-9a171f2f422c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;7b5bd02f-b262-4e1a-b1c0-9a171f2f422c&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUser Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;fde4a879-5c96-447b-b3d9-dd551c7c1e27&quot;,
                        &quot;parentUUID&quot;: &quot;7b5bd02f-b262-4e1a-b1c0-9a171f2f422c&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUser Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let observable = users.getUser(&#x27;mou&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\n\t\t\t\t\texpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;251d9e86-935a-4c25-99c9-fbfff0c4807e&quot;,
                        &quot;parentUUID&quot;: &quot;7b5bd02f-b262-4e1a-b1c0-9a171f2f422c&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUserList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}], LastEvaluatedKey: &#x27;marco&#x27;});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;74969315-cf07-4f95-a638-72cfa1bd5923&quot;,
                        &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;530daf9f-500b-4611-bb19-52d516480625&quot;,
                        &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4a20adbe-a87e-4be4-9a98-3c92dd94c74e&quot;,
                        &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;,\n\tslack_channel: &#x27;channel&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name and slack_channel = :slack_channel&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:slack_channel&#x27;, &#x27;channel&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6a19b03c-f9aa-4541-a9b0-1e68a83b48d9&quot;,
                        &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}], LastEvaluatedKey: &#x27;marco&#x27;});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;74969315-cf07-4f95-a638-72cfa1bd5923&quot;,
                        &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;530daf9f-500b-4611-bb19-52d516480625&quot;,
                        &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4a20adbe-a87e-4be4-9a98-3c92dd94c74e&quot;,
                        &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;,\n\tslack_channel: &#x27;channel&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name and slack_channel = :slack_channel&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:slack_channel&#x27;, &#x27;channel&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6a19b03c-f9aa-4541-a9b0-1e68a83b48d9&quot;,
                        &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 4,
                    &quot;totalPasses&quot;: 4,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 4,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;removeUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB removeUser Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \&quot;error removing user\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;302333dd-0b16-4fff-8d2d-7cafef9dea54&quot;,
                        &quot;parentUUID&quot;: &quot;3758adcf-d96c-4cc0-98e6-324c57e2c0de&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB removeUser Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;bc1f1ffa-3a42-431b-be3d-d78afdcfbee4&quot;,
                        &quot;parentUUID&quot;: &quot;3758adcf-d96c-4cc0-98e6-324c57e2c0de&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;3758adcf-d96c-4cc0-98e6-324c57e2c0de&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB removeUser Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \&quot;error removing user\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;302333dd-0b16-4fff-8d2d-7cafef9dea54&quot;,
                        &quot;parentUUID&quot;: &quot;3758adcf-d96c-4cc0-98e6-324c57e2c0de&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB removeUser Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;bc1f1ffa-3a42-431b-be3d-d78afdcfbee4&quot;,
                        &quot;parentUUID&quot;: &quot;3758adcf-d96c-4cc0-98e6-324c57e2c0de&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB updateUser Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \&quot;error updating user\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a3b08d0f-670a-4580-ad85-52bc4dbe35be&quot;,
                        &quot;parentUUID&quot;: &quot;0ddde174-da9d-475b-a4a1-0d679a90e42e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB updateUser Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c42b78b0-dcc3-4107-8080-1817b374ab9c&quot;,
                        &quot;parentUUID&quot;: &quot;0ddde174-da9d-475b-a4a1-0d679a90e42e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;uuid&quot;: &quot;0ddde174-da9d-475b-a4a1-0d679a90e42e&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB updateUser Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \&quot;error updating user\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a3b08d0f-670a-4580-ad85-52bc4dbe35be&quot;,
                        &quot;parentUUID&quot;: &quot;0ddde174-da9d-475b-a4a1-0d679a90e42e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;fullTitle&quot;: &quot;UsersDAODynamoDB updateUser Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c42b78b0-dcc3-4107-8080-1817b374ab9c&quot;,
                        &quot;parentUUID&quot;: &quot;0ddde174-da9d-475b-a4a1-0d679a90e42e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                &quot;uuid&quot;: &quot;9ed4dcfe-d824-44ce-991c-b8a1c837153d&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
            &quot;uuid&quot;: &quot;a6dfcda5-0dd1-4589-b16c-6ecf7e17aa5d&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_UsersDAODynamoDB.js&quot;,
        &quot;uuid&quot;: &quot;98f30fd2-57e8-4756-a8a1-9867013a10e2&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Users&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;UsersService&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6f07b354-0b1d-4c39-8b95-af82a5eb7e75&quot;,
                        &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 8,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;32dbbe15-a247-446d-ba09-4c39dc293baa&quot;,
                        &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \&quot;\&quot; };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c0152ad0-5909-4fed-8f84-95cb1951436a&quot;,
                        &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;70286ef3-7e9a-447e-9e17-68bc3142ed62&quot;,
                        &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6f07b354-0b1d-4c39-8b95-af82a5eb7e75&quot;,
                        &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 8,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;32dbbe15-a247-446d-ba09-4c39dc293baa&quot;,
                        &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \&quot;\&quot; };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c0152ad0-5909-4fed-8f84-95cb1951436a&quot;,
                        &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService addUser Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;70286ef3-7e9a-447e-9e17-68bc3142ed62&quot;,
                        &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 4,
                    &quot;totalPasses&quot;: 4,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 10,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;deleteUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;252eccac-4b9a-42f8-9af9-e6d699e93930&quot;,
                        &quot;parentUUID&quot;: &quot;e285b6c0-ed97-4242-9633-b5b8c181d83e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6da076c0-3d30-4fac-94e4-4a146973c093&quot;,
                        &quot;parentUUID&quot;: &quot;e285b6c0-ed97-4242-9633-b5b8c181d83e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { pathParameters: { username: &#x27;pippo&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6b6fbf80-92bf-4031-a26a-639bd573e663&quot;,
                        &quot;parentUUID&quot;: &quot;e285b6c0-ed97-4242-9633-b5b8c181d83e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;e285b6c0-ed97-4242-9633-b5b8c181d83e&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;252eccac-4b9a-42f8-9af9-e6d699e93930&quot;,
                        &quot;parentUUID&quot;: &quot;e285b6c0-ed97-4242-9633-b5b8c181d83e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6da076c0-3d30-4fac-94e4-4a146973c093&quot;,
                        &quot;parentUUID&quot;: &quot;e285b6c0-ed97-4242-9633-b5b8c181d83e&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { pathParameters: { username: &#x27;pippo&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6b6fbf80-92bf-4031-a26a-639bd573e663&quot;,
                        &quot;parentUUID&quot;: &quot;e285b6c0-ed97-4242-9633-b5b8c181d83e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;050e5250-1e63-4852-b306-8e24b640eee6&quot;,
                        &quot;parentUUID&quot;: &quot;c10d8e7a-9e00-49b8-8523-3ac0d6b9d943&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cab6a2d1-6fe2-48c7-a2d2-b5219594a56b&quot;,
                        &quot;parentUUID&quot;: &quot;c10d8e7a-9e00-49b8-8523-3ac0d6b9d943&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\n          let ev = { pathParameters: { username: &#x27;pippo&#x27;} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a45e9b7a-3177-4b9c-bacf-537c61bd8f6f&quot;,
                        &quot;parentUUID&quot;: &quot;c10d8e7a-9e00-49b8-8523-3ac0d6b9d943&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;c10d8e7a-9e00-49b8-8523-3ac0d6b9d943&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;050e5250-1e63-4852-b306-8e24b640eee6&quot;,
                        &quot;parentUUID&quot;: &quot;c10d8e7a-9e00-49b8-8523-3ac0d6b9d943&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cab6a2d1-6fe2-48c7-a2d2-b5219594a56b&quot;,
                        &quot;parentUUID&quot;: &quot;c10d8e7a-9e00-49b8-8523-3ac0d6b9d943&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\n          let ev = { pathParameters: { username: &#x27;pippo&#x27;} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a45e9b7a-3177-4b9c-bacf-537c61bd8f6f&quot;,
                        &quot;parentUUID&quot;: &quot;c10d8e7a-9e00-49b8-8523-3ac0d6b9d943&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUserList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b17e8659-c0cb-43a3-9afc-344abf554073&quot;,
                        &quot;parentUUID&quot;: &quot;c840bd3e-98a5-4665-a53f-441881be5c6d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ users: [{ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;abe4d296-4e35-4248-9bad-9568d454116b&quot;,
                        &quot;parentUUID&quot;: &quot;c840bd3e-98a5-4665-a53f-441881be5c6d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;c840bd3e-98a5-4665-a53f-441881be5c6d&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b17e8659-c0cb-43a3-9afc-344abf554073&quot;,
                        &quot;parentUUID&quot;: &quot;c840bd3e-98a5-4665-a53f-441881be5c6d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ users: [{ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;abe4d296-4e35-4248-9bad-9568d454116b&quot;,
                        &quot;parentUUID&quot;: &quot;c840bd3e-98a5-4665-a53f-441881be5c6d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;updateUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5f53512a-dcf3-447c-a35e-49a6762de02e&quot;,
                        &quot;parentUUID&quot;: &quot;948ecded-16a5-4b59-9853-f247b32964c1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;103ca95a-6251-4ce9-bf4e-bf8be825689f&quot;,
                        &quot;parentUUID&quot;: &quot;948ecded-16a5-4b59-9853-f247b32964c1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = { pathParameters: \&quot;\&quot;, body: \&quot;\&quot; };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a10364a7-6993-4073-95de-5896508de88a&quot;,
                        &quot;parentUUID&quot;: &quot;948ecded-16a5-4b59-9853-f247b32964c1&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                    &quot;uuid&quot;: &quot;948ecded-16a5-4b59-9853-f247b32964c1&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5f53512a-dcf3-447c-a35e-49a6762de02e&quot;,
                        &quot;parentUUID&quot;: &quot;948ecded-16a5-4b59-9853-f247b32964c1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;103ca95a-6251-4ce9-bf4e-bf8be825689f&quot;,
                        &quot;parentUUID&quot;: &quot;948ecded-16a5-4b59-9853-f247b32964c1&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;fullTitle&quot;: &quot;UsersService updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let ev = { pathParameters: \&quot;\&quot;, body: \&quot;\&quot; };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a10364a7-6993-4073-95de-5896508de88a&quot;,
                        &quot;parentUUID&quot;: &quot;948ecded-16a5-4b59-9853-f247b32964c1&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 3,
                    &quot;totalPasses&quot;: 3,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
                &quot;uuid&quot;: &quot;23c64429-d6d1-4b14-a9fa-9f4bafe9c270&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
            &quot;uuid&quot;: &quot;b0d732c4-49bf-4d2d-85f0-9dfbe5b96bea&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_UsersService.js&quot;,
        &quot;uuid&quot;: &quot;dc145be3-d4aa-4cd7-ae62-d0ebd7487379&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Events&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;VAMessageListener&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;onMessage&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;216d7ba3-9505-4b6d-9810-ad8d0b5aae3c&quot;,
                        &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;561ffda1-1532-41be-a2d6-8728834ace14&quot;,
                        &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;msg&#x27;: &#x27;error getting guest&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d1ad3af6-0db1-411a-b972-82acd2989867&quot;,
                        &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ &#x27;msg&#x27;: &#x27;error adding conversation&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7340828e-233f-4665-961a-7fa663bd1b6f&quot;,
                        &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;type&#x27;: &#x27;example&#x27; });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6532740e-492d-4894-b1cc-b23b5ec5d50a&quot;,
                        &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VAMessageListener.js&quot;,
                    &quot;uuid&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;216d7ba3-9505-4b6d-9810-ad8d0b5aae3c&quot;,
                        &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;561ffda1-1532-41be-a2d6-8728834ace14&quot;,
                        &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;msg&#x27;: &#x27;error getting guest&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d1ad3af6-0db1-411a-b972-82acd2989867&quot;,
                        &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 0,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ &#x27;msg&#x27;: &#x27;error adding conversation&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7340828e-233f-4665-961a-7fa663bd1b6f&quot;,
                        &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
                        &quot;fullTitle&quot;: &quot;VAMessageListener onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;type&#x27;: &#x27;example&#x27; });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;6532740e-492d-4894-b1cc-b23b5ec5d50a&quot;,
                        &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 5,
                    &quot;totalPasses&quot;: 5,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 5,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_VAMessageListener.js&quot;,
                &quot;uuid&quot;: &quot;9b6e5d01-5ee5-4bc3-ba72-8a95d1109eda&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_VAMessageListener.js&quot;,
            &quot;uuid&quot;: &quot;7e86fa22-26d3-44cf-8752-6f806b7b9731&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_VAMessageListener.js&quot;,
        &quot;uuid&quot;: &quot;95af547d-0ae2-44c3-85d2-0394652e46de&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;VirtualAssistant&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;VAService&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;query&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;VAService query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith(&#x27;test&#x27;));\n\tlet result = context.succeed.getCall(0).args[0];\n            expect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n            done();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;74310b24-396f-472c-9045-f21ef6c302f8&quot;,
                        &quot;parentUUID&quot;: &quot;9a9982d0-dc2b-41ea-a17d-b365069a6cd6&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
                        &quot;fullTitle&quot;: &quot;VAService query Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.reject(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n            done();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;bc6eacdb-d762-41c1-b76d-240b80da6346&quot;,
                        &quot;parentUUID&quot;: &quot;9a9982d0-dc2b-41ea-a17d-b365069a6cd6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VAService.js&quot;,
                    &quot;uuid&quot;: &quot;9a9982d0-dc2b-41ea-a17d-b365069a6cd6&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
                        &quot;fullTitle&quot;: &quot;VAService query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith(&#x27;test&#x27;));\n\tlet result = context.succeed.getCall(0).args[0];\n            expect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n            done();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;74310b24-396f-472c-9045-f21ef6c302f8&quot;,
                        &quot;parentUUID&quot;: &quot;9a9982d0-dc2b-41ea-a17d-b365069a6cd6&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
                        &quot;fullTitle&quot;: &quot;VAService query Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.reject(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n            done();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;bc6eacdb-d762-41c1-b76d-240b80da6346&quot;,
                        &quot;parentUUID&quot;: &quot;9a9982d0-dc2b-41ea-a17d-b365069a6cd6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 2,
                    &quot;totalPasses&quot;: 2,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 7,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_VAService.js&quot;,
                &quot;uuid&quot;: &quot;93f56f4f-db65-4d73-b36f-8859662d18f8&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_VAService.js&quot;,
            &quot;uuid&quot;: &quot;78802211-2518-4277-948a-34e482e3091f&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_VAService.js&quot;,
        &quot;uuid&quot;: &quot;018be6a5-c7e2-4b46-a6c2-ee92c31bf4f8&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;APIGateway&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;VocalAPI&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;_addRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;08b416ef-6b47-4a45-b4c1-8af30b23e52d&quot;,
                        &quot;parentUUID&quot;: &quot;96f2ecb5-a479-4e28-b76d-f8832d782a93&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;96f2ecb5-a479-4e28-b76d-f8832d782a93&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;08b416ef-6b47-4a45-b4c1-8af30b23e52d&quot;,
                        &quot;parentUUID&quot;: &quot;96f2ecb5-a479-4e28-b76d-f8832d782a93&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_addUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;951465a6-0832-4329-8e8d-a08ba4aacdca&quot;,
                        &quot;parentUUID&quot;: &quot;5108413b-e03f-4ba0-870b-cb2f776a81d2&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;5108413b-e03f-4ba0-870b-cb2f776a81d2&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;951465a6-0832-4329-8e8d-a08ba4aacdca&quot;,
                        &quot;parentUUID&quot;: &quot;5108413b-e03f-4ba0-870b-cb2f776a81d2&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_addUserEnrollment&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.addEnrollment.returns(Rx.Observable.throw(errore));\napi._addUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;585df43e-fe1c-4635-8bf3-2e1d05630718&quot;,
                        &quot;parentUUID&quot;: &quot;5462f899-0bf8-46a1-95c0-d348272f334f&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;5462f899-0bf8-46a1-95c0-d348272f334f&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.addEnrollment.returns(Rx.Observable.throw(errore));\napi._addUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;585df43e-fe1c-4635-8bf3-2e1d05630718&quot;,
                        &quot;parentUUID&quot;: &quot;5462f899-0bf8-46a1-95c0-d348272f334f&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_getRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8e4966b6-fde1-4679-819e-7f68890a238b&quot;,
                        &quot;parentUUID&quot;: &quot;4bbb01bf-3cd5-4be1-b39e-639095dc6d9e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;4bbb01bf-3cd5-4be1-b39e-639095dc6d9e&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8e4966b6-fde1-4679-819e-7f68890a238b&quot;,
                        &quot;parentUUID&quot;: &quot;4bbb01bf-3cd5-4be1-b39e-639095dc6d9e&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_getRuleList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e4eea84b-f84c-4f13-93c7-476de3e450f8&quot;,
                        &quot;parentUUID&quot;: &quot;cbebbb49-802b-439b-81a9-ec44a9a4a6fc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;cbebbb49-802b-439b-81a9-ec44a9a4a6fc&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e4eea84b-f84c-4f13-93c7-476de3e450f8&quot;,
                        &quot;parentUUID&quot;: &quot;cbebbb49-802b-439b-81a9-ec44a9a4a6fc&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 1,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_getUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c1bf914b-21be-41bb-81f2-9bcad72a3721&quot;,
                        &quot;parentUUID&quot;: &quot;06dbdeb3-20e3-4e34-83da-fee48d38f31a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;06dbdeb3-20e3-4e34-83da-fee48d38f31a&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c1bf914b-21be-41bb-81f2-9bcad72a3721&quot;,
                        &quot;parentUUID&quot;: &quot;06dbdeb3-20e3-4e34-83da-fee48d38f31a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_getUserList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;96e42e6e-4c57-44fc-8b87-c26947f83c80&quot;,
                        &quot;parentUUID&quot;: &quot;56c3d595-e98c-4521-aa04-1b00884273c4&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;56c3d595-e98c-4521-aa04-1b00884273c4&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;96e42e6e-4c57-44fc-8b87-c26947f83c80&quot;,
                        &quot;parentUUID&quot;: &quot;56c3d595-e98c-4521-aa04-1b00884273c4&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_loginUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.doLogin.returns(Rx.Observable.throw(errore));\napi._loginUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;93305c00-0b65-42f8-abca-cf39a453cd9d&quot;,
                        &quot;parentUUID&quot;: &quot;323887bb-8fab-4dba-bb46-7110505e3e38&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;323887bb-8fab-4dba-bb46-7110505e3e38&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.doLogin.returns(Rx.Observable.throw(errore));\napi._loginUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;93305c00-0b65-42f8-abca-cf39a453cd9d&quot;,
                        &quot;parentUUID&quot;: &quot;323887bb-8fab-4dba-bb46-7110505e3e38&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;queryLambda&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2001,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b0d1973c-8999-4483-a0ee-6ff2bce0258b&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2001,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8f56444d-4ea6-480e-85ef-cb69c4e06f5a&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2001,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a62bb99e-109c-4536-8b68-6fba13237117&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;61cff039-8c19-48fc-b2fc-be9822a85d87&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;374e4b65-e451-4ee1-9028-36401ced83e8&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1871f858-9fff-4e83-ada6-123034b6cf27&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUserList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUserList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUserList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUserList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1f96f57a-8d36-4f11-b9e4-3deee894c7fa&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4c2ec230-fa9a-4e7b-889d-0f2d35885f13&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2001,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b99d79ad-42e9-4d94-85cf-e4c023140f60&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;abecccbc-1e66-4027-b832-8fc0e2428c23&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1dac11d0-473d-4833-8390-8ff0968e0e34&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;99b05fb2-3e32-418e-80cf-24133ea2fbc1&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c9036fa3-3497-467c-b60c-977926b5b84e&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          };\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0fc744cf-8ab5-424d-9fab-d83371b0cd7e&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d237b2ce-caed-4682-858d-3919ba1daf04&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e31bef5b-f76b-42bd-8271-1c9627530134&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;47a5f0ad-04bf-4d39-8274-50cc94705b77&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;29ee8baa-e98c-4864-b1d5-5e9b0346c92d&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7db6716a-41b4-4159-91e8-53e12836d705&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ba6cb505-baf3-4a21-9230-df1937a7c18b&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7d6dc886-bca5-4706-92e6-7845e2534ec5&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1a77c1aa-fc09-456b-8bc0-d34b437403f2&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1ab0085f-ae95-4015-8748-94a2fb749ebf&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2001,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;68c4fb53-8fe5-4d3b-bf80-46d585b28be7&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9aaf87f4-ff0a-451d-807f-08091d552ed6&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a5c7ce28-87c2-4fbb-b054-3dc49d69815a&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n\texpect(response).have.property(&#x27;statusCode&#x27;, 200);\n\tdone();\n};\napi.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;bfab2fc5-0c9b-4737-baa7-aa56ce75d65d&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          };\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;0fc744cf-8ab5-424d-9fab-d83371b0cd7e&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;d237b2ce-caed-4682-858d-3919ba1daf04&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;e31bef5b-f76b-42bd-8271-1c9627530134&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;47a5f0ad-04bf-4d39-8274-50cc94705b77&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;29ee8baa-e98c-4864-b1d5-5e9b0346c92d&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7db6716a-41b4-4159-91e8-53e12836d705&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;ba6cb505-baf3-4a21-9230-df1937a7c18b&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1a77c1aa-fc09-456b-8bc0-d34b437403f2&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1ab0085f-ae95-4015-8748-94a2fb749ebf&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;9aaf87f4-ff0a-451d-807f-08091d552ed6&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 1,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a5c7ce28-87c2-4fbb-b054-3dc49d69815a&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2001,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b0d1973c-8999-4483-a0ee-6ff2bce0258b&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2001,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8f56444d-4ea6-480e-85ef-cb69c4e06f5a&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2001,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;a62bb99e-109c-4536-8b68-6fba13237117&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;61cff039-8c19-48fc-b2fc-be9822a85d87&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;374e4b65-e451-4ee1-9028-36401ced83e8&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1871f858-9fff-4e83-ada6-123034b6cf27&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUserList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUserList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUserList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUserList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1f96f57a-8d36-4f11-b9e4-3deee894c7fa&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;4c2ec230-fa9a-4e7b-889d-0f2d35885f13&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2001,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b99d79ad-42e9-4d94-85cf-e4c023140f60&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;abecccbc-1e66-4027-b832-8fc0e2428c23&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1dac11d0-473d-4833-8390-8ff0968e0e34&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;99b05fb2-3e32-418e-80cf-24133ea2fbc1&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;c9036fa3-3497-467c-b60c-977926b5b84e&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7d6dc886-bca5-4706-92e6-7845e2534ec5&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2001,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;68c4fb53-8fe5-4d3b-bf80-46d585b28be7&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      },
                      {
                        &quot;title&quot;: &quot;Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI queryLambda Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
                        &quot;timedOut&quot;: true,
                        &quot;duration&quot;: 2000,
                        &quot;state&quot;: &quot;failed&quot;,
                        &quot;pass&quot;: false,
                        &quot;fail&quot;: true,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n\texpect(response).have.property(&#x27;statusCode&#x27;, 200);\n\tdone();\n};\napi.queryLambda(event, context);&quot;,
                        &quot;err&quot;: {
                          &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
                        },
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;bfab2fc5-0c9b-4737-baa7-aa56ce75d65d&quot;,
                        &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 27,
                    &quot;totalPasses&quot;: 11,
                    &quot;totalFailures&quot;: 16,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: true,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 32020,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_removeRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7f7d7be5-e89e-413f-b5bd-6205042269e2&quot;,
                        &quot;parentUUID&quot;: &quot;34d39c6c-e17a-4d9a-9dd9-38719edb4e02&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;34d39c6c-e17a-4d9a-9dd9-38719edb4e02&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7f7d7be5-e89e-413f-b5bd-6205042269e2&quot;,
                        &quot;parentUUID&quot;: &quot;34d39c6c-e17a-4d9a-9dd9-38719edb4e02&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_removeUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;86b37758-cc9a-4cc2-96f4-437326a544b2&quot;,
                        &quot;parentUUID&quot;: &quot;edd16b1b-2848-4163-bdfc-0a235e349b7d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;edd16b1b-2848-4163-bdfc-0a235e349b7d&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;86b37758-cc9a-4cc2-96f4-437326a544b2&quot;,
                        &quot;parentUUID&quot;: &quot;edd16b1b-2848-4163-bdfc-0a235e349b7d&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_resetUserEnrollment&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.resetEnrollments.returns(Rx.Observable.throw(errore));\napi._resetUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cbd9dbdc-ff08-4aad-9650-d55d97b83a2b&quot;,
                        &quot;parentUUID&quot;: &quot;a9a5997b-4223-4585-aebf-01aea7226654&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;a9a5997b-4223-4585-aebf-01aea7226654&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.resetEnrollments.returns(Rx.Observable.throw(errore));\napi._resetUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;cbd9dbdc-ff08-4aad-9650-d55d97b83a2b&quot;,
                        &quot;parentUUID&quot;: &quot;a9a5997b-4223-4585-aebf-01aea7226654&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_updateRule&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;84a272bb-289d-4852-90fc-b307fa4bb737&quot;,
                        &quot;parentUUID&quot;: &quot;229d8160-1071-4801-aa4b-c69e07707ad4&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;229d8160-1071-4801-aa4b-c69e07707ad4&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;84a272bb-289d-4852-90fc-b307fa4bb737&quot;,
                        &quot;parentUUID&quot;: &quot;229d8160-1071-4801-aa4b-c69e07707ad4&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;_updateUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5f79f361-39a1-4fa0-bbfd-ba56794ad4e4&quot;,
                        &quot;parentUUID&quot;: &quot;4d1b9bae-6abd-4d9d-a099-cfe45a9d0c84&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;uuid&quot;: &quot;4d1b9bae-6abd-4d9d-a099-cfe45a9d0c84&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalAPI _updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 4,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;5f79f361-39a1-4fa0-bbfd-ba56794ad4e4&quot;,
                        &quot;parentUUID&quot;: &quot;4d1b9bae-6abd-4d9d-a099-cfe45a9d0c84&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 4,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
                &quot;uuid&quot;: &quot;fedbc0ee-d7b2-4084-bb04-767cac31c73a&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
            &quot;uuid&quot;: &quot;0ecd71ec-7a39-42ba-8f7f-ca3ecc886b63&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_VocalAPI.js&quot;,
        &quot;uuid&quot;: &quot;28d826f5-6a4a-48af-bfa7-0e3a1702f220&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;Back-end&quot;,
        &quot;suites&quot;: [
          {
            &quot;title&quot;: &quot;Users&quot;,
            &quot;suites&quot;: [
              {
                &quot;title&quot;: &quot;VocalLoginMicrosoftModule&quot;,
                &quot;suites&quot;: [
                  {
                    &quot;title&quot;: &quot;addEnrollment&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;098d06dd-e6a5-4174-b054-9f7afc2632b8&quot;,
                        &quot;parentUUID&quot;: &quot;02e97a6d-902d-467d-8cf4-c5cb5670b1f6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;02e97a6d-902d-467d-8cf4-c5cb5670b1f6&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;098d06dd-e6a5-4174-b054-9f7afc2632b8&quot;,
                        &quot;parentUUID&quot;: &quot;02e97a6d-902d-467d-8cf4-c5cb5670b1f6&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;createUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b74572cc-8fc7-4122-a7c4-9caa26698e11&quot;,
                        &quot;parentUUID&quot;: &quot;54363c6b-f4bd-46af-82b6-67e3344d385a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;54363c6b-f4bd-46af-82b6-67e3344d385a&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;b74572cc-8fc7-4122-a7c4-9caa26698e11&quot;,
                        &quot;parentUUID&quot;: &quot;54363c6b-f4bd-46af-82b6-67e3344d385a&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;deleteUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1ddc0c88-fe65-4185-9184-e24ce44efdc5&quot;,
                        &quot;parentUUID&quot;: &quot;2e4c08c9-84fd-4a84-8f76-712ad059b5d5&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;2e4c08c9-84fd-4a84-8f76-712ad059b5d5&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;1ddc0c88-fe65-4185-9184-e24ce44efdc5&quot;,
                        &quot;parentUUID&quot;: &quot;2e4c08c9-84fd-4a84-8f76-712ad059b5d5&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;doLogin&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject({ \&quot;result\&quot; : \&quot;Reject\&quot; }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7847c4d7-5c7e-4a87-a3a9-852afc45be4b&quot;,
                        &quot;parentUUID&quot;: &quot;14388c7a-a9ae-4b7a-973b-19bd0860b778&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;14388c7a-a9ae-4b7a-973b-19bd0860b778&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 2,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject({ \&quot;result\&quot; : \&quot;Reject\&quot; }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;7847c4d7-5c7e-4a87-a3a9-852afc45be4b&quot;,
                        &quot;parentUUID&quot;: &quot;14388c7a-a9ae-4b7a-973b-19bd0860b778&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 2,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getList&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8e67fe00-6bd6-4e0d-91f8-4f51dc071e58&quot;,
                        &quot;parentUUID&quot;: &quot;b62abe05-31fc-4de5-9965-1399e31338cb&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;b62abe05-31fc-4de5-9965-1399e31338cb&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;8e67fe00-6bd6-4e0d-91f8-4f51dc071e58&quot;,
                        &quot;parentUUID&quot;: &quot;b62abe05-31fc-4de5-9965-1399e31338cb&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;getUser&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n  {\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f5e91688-96ff-47cd-97e0-91224b516fbf&quot;,
                        &quot;parentUUID&quot;: &quot;e48e9887-0ed5-4eda-807d-e544783d35db&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;e48e9887-0ed5-4eda-807d-e544783d35db&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n  {\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;f5e91688-96ff-47cd-97e0-91224b516fbf&quot;,
                        &quot;parentUUID&quot;: &quot;e48e9887-0ed5-4eda-807d-e544783d35db&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  },
                  {
                    &quot;title&quot;: &quot;resetEnrollments&quot;,
                    &quot;suites&quot;: [],
                    &quot;tests&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule resetEnrollments Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.resetEnrollments().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;47c9ba79-3d61-40e4-8aeb-31e6549fcfe1&quot;,
                        &quot;parentUUID&quot;: &quot;bcfbb69a-a9f2-47d2-b07e-da7f7a38a158&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;pending&quot;: [],
                    &quot;root&quot;: false,
                    &quot;_timeout&quot;: 2000,
                    &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;uuid&quot;: &quot;bcfbb69a-a9f2-47d2-b07e-da7f7a38a158&quot;,
                    &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                    &quot;passes&quot;: [
                      {
                        &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;fullTitle&quot;: &quot;VocalLoginMicrosoftModule resetEnrollments Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
                        &quot;timedOut&quot;: false,
                        &quot;duration&quot;: 3,
                        &quot;state&quot;: &quot;passed&quot;,
                        &quot;speed&quot;: &quot;fast&quot;,
                        &quot;pass&quot;: true,
                        &quot;fail&quot;: false,
                        &quot;pending&quot;: false,
                        &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.resetEnrollments().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
                        &quot;err&quot;: {},
                        &quot;isRoot&quot;: false,
                        &quot;uuid&quot;: &quot;47c9ba79-3d61-40e4-8aeb-31e6549fcfe1&quot;,
                        &quot;parentUUID&quot;: &quot;bcfbb69a-a9f2-47d2-b07e-da7f7a38a158&quot;,
                        &quot;skipped&quot;: false
                      }
                    ],
                    &quot;failures&quot;: [],
                    &quot;skipped&quot;: [],
                    &quot;hasTests&quot;: true,
                    &quot;hasSuites&quot;: false,
                    &quot;totalTests&quot;: 1,
                    &quot;totalPasses&quot;: 1,
                    &quot;totalFailures&quot;: 0,
                    &quot;totalPending&quot;: 0,
                    &quot;totalSkipped&quot;: 0,
                    &quot;hasPasses&quot;: true,
                    &quot;hasFailures&quot;: false,
                    &quot;hasPending&quot;: false,
                    &quot;hasSkipped&quot;: false,
                    &quot;duration&quot;: 3,
                    &quot;rootEmpty&quot;: false
                  }
                ],
                &quot;tests&quot;: [],
                &quot;pending&quot;: [],
                &quot;root&quot;: false,
                &quot;_timeout&quot;: 2000,
                &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                &quot;uuid&quot;: &quot;09595db7-efa7-4f18-b708-1f8e43d7b3ba&quot;,
                &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
                &quot;passes&quot;: [],
                &quot;failures&quot;: [],
                &quot;skipped&quot;: [],
                &quot;hasTests&quot;: false,
                &quot;hasSuites&quot;: true,
                &quot;totalTests&quot;: 0,
                &quot;totalPasses&quot;: 0,
                &quot;totalFailures&quot;: 0,
                &quot;totalPending&quot;: 0,
                &quot;totalSkipped&quot;: 0,
                &quot;hasPasses&quot;: false,
                &quot;hasFailures&quot;: false,
                &quot;hasPending&quot;: false,
                &quot;hasSkipped&quot;: false,
                &quot;duration&quot;: 0,
                &quot;rootEmpty&quot;: false
              }
            ],
            &quot;tests&quot;: [],
            &quot;pending&quot;: [],
            &quot;root&quot;: false,
            &quot;_timeout&quot;: 2000,
            &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
            &quot;uuid&quot;: &quot;38f5c652-edc3-41d4-ab3d-f6864710ded3&quot;,
            &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
            &quot;passes&quot;: [],
            &quot;failures&quot;: [],
            &quot;skipped&quot;: [],
            &quot;hasTests&quot;: false,
            &quot;hasSuites&quot;: true,
            &quot;totalTests&quot;: 0,
            &quot;totalPasses&quot;: 0,
            &quot;totalFailures&quot;: 0,
            &quot;totalPending&quot;: 0,
            &quot;totalSkipped&quot;: 0,
            &quot;hasPasses&quot;: false,
            &quot;hasFailures&quot;: false,
            &quot;hasPending&quot;: false,
            &quot;hasSkipped&quot;: false,
            &quot;duration&quot;: 0,
            &quot;rootEmpty&quot;: false
          }
        ],
        &quot;tests&quot;: [],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
        &quot;uuid&quot;: &quot;c695f8a0-4cc9-4d8a-bab4-cf1438c3f4bf&quot;,
        &quot;fullFile&quot;: &quot;H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js&quot;,
        &quot;passes&quot;: [],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasTests&quot;: false,
        &quot;hasSuites&quot;: true,
        &quot;totalTests&quot;: 0,
        &quot;totalPasses&quot;: 0,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: false,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 0,
        &quot;rootEmpty&quot;: false
      }
    ],
    &quot;tests&quot;: [],
    &quot;pending&quot;: [],
    &quot;root&quot;: true,
    &quot;_timeout&quot;: 2000,
    &quot;uuid&quot;: &quot;37b6a409-7d33-437a-b8e4-a21fca509968&quot;,
    &quot;fullFile&quot;: &quot;&quot;,
    &quot;file&quot;: &quot;&quot;,
    &quot;passes&quot;: [],
    &quot;failures&quot;: [],
    &quot;skipped&quot;: [],
    &quot;hasTests&quot;: false,
    &quot;hasSuites&quot;: true,
    &quot;totalTests&quot;: 0,
    &quot;totalPasses&quot;: 0,
    &quot;totalFailures&quot;: 0,
    &quot;totalPending&quot;: 0,
    &quot;totalSkipped&quot;: 0,
    &quot;hasPasses&quot;: false,
    &quot;hasFailures&quot;: false,
    &quot;hasPending&quot;: false,
    &quot;hasSkipped&quot;: false,
    &quot;duration&quot;: 0,
    &quot;rootEmpty&quot;: true
  },
  &quot;allTests&quot;: [
    {
      &quot;title&quot;: &quot;La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8d1f4836-dc03-4e4a-a95e-8cee60ee25df&quot;,
      &quot;parentUUID&quot;: &quot;d288bf21-99dc-4256-8659-edbbbd644074&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cb6595a7-63ce-4782-b715-61e4d220a581&quot;,
      &quot;parentUUID&quot;: &quot;d288bf21-99dc-4256-8659-edbbbd644074&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b2ac5a0d-ca5d-4472-a26c-75b0db5ba26c&quot;,
      &quot;parentUUID&quot;: &quot;271810cc-1f1f-4c41-8973-8463a1955421&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d854a743-9d6b-47ea-925e-da8b3f68a075&quot;,
      &quot;parentUUID&quot;: &quot;271810cc-1f1f-4c41-8973-8463a1955421&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getAgent Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8e69b9d4-2d10-4a54-8f1d-eb1128fa733a&quot;,
      &quot;parentUUID&quot;: &quot;d501a162-deaa-4a3d-87cc-05a7871daa02&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getAgent Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = agents.getAgent(&#x27;mock_name&#x27;);\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;25b8a6a1-f229-4daa-896b-36897deb9329&quot;,
      &quot;parentUUID&quot;: &quot;d501a162-deaa-4a3d-87cc-05a7871daa02&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;2&#x27;});\ndynamo_client.scan.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d151a69c-b5f1-4f40-bef6-ecf8ff627c9c&quot;,
      &quot;parentUUID&quot;: &quot;85405992-e8cd-44a4-a7d1-8ed755a7b79e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getAgentList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;eeef799f-d07e-4504-870b-89f1c4550a59&quot;,
      &quot;parentUUID&quot;: &quot;85405992-e8cd-44a4-a7d1-8ed755a7b79e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeAgent Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\&quot;error removing rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ea52fb1f-3f4f-4dba-aa75-c6e5d398e644&quot;,
      &quot;parentUUID&quot;: &quot;f898a002-50f7-45a7-8577-dd720980b622&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeAgent Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\&quot;success\&quot;});\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5fcf6b0d-9fa3-431c-98e9-5730d5ad5a4b&quot;,
      &quot;parentUUID&quot;: &quot;f898a002-50f7-45a7-8577-dd720980b622&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateAgent Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d3b1d60c-682e-4e92-ad36-9bc74c7fcf88&quot;,
      &quot;parentUUID&quot;: &quot;5660c634-c2d6-4b65-9cf1-9fd4e3ff287a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateAgent Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3fe30903-df2c-427d-992c-21ab970a6283&quot;,
      &quot;parentUUID&quot;: &quot;5660c634-c2d6-4b65-9cf1-9fd4e3ff287a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
      &quot;fullTitle&quot;: &quot;query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;38ea45b1-986f-4ac7-a6dd-cb723376086a&quot;,
      &quot;parentUUID&quot;: &quot;cd4ec5b9-8d71-4bc5-b5ce-522790eba84a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
      &quot;fullTitle&quot;: &quot;query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9436f267-b973-44d9-8fdb-033d4d248f37&quot;,
      &quot;parentUUID&quot;: &quot;cd4ec5b9-8d71-4bc5-b5ce-522790eba84a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \&quot;Requested resource not found\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e0331540-b400-4e9b-90e6-c9e59c94d6b7&quot;,
      &quot;parentUUID&quot;: &quot;a2264cdb-ff82-4bbc-8055-dbe3c1b363d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;764d9115-ec97-4040-881c-441129b7c934&quot;,
      &quot;parentUUID&quot;: &quot;a2264cdb-ff82-4bbc-8055-dbe3c1b363d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \&quot;error adding message\&quot; });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e22464f1-289c-40ce-a381-6bd7a8cd4067&quot;,
      &quot;parentUUID&quot;: &quot;96376b9f-90cd-417d-b93f-e03966923ae8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4a8d5266-fe07-4ed5-94b3-a97ea0f6f8c4&quot;,
      &quot;parentUUID&quot;: &quot;96376b9f-90cd-417d-b93f-e03966923ae8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \&quot;error downloading conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7e9938b1-c86a-43d4-9694-c2119a23f457&quot;,
      &quot;parentUUID&quot;: &quot;c5b491fd-0ff0-47a8-b08e-8d44805b5e91&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getConversation Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;920b6361-6aca-4bea-b50b-ca27082e4f0b&quot;,
      &quot;parentUUID&quot;: &quot;c5b491fd-0ff0-47a8-b08e-8d44805b5e91&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5fb2f987-5649-4ce6-a9fe-bc55b45a1b03&quot;,
      &quot;parentUUID&quot;: &quot;16a7d0ec-eff6-4c1e-b0a2-96b5023f28b7&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getConversationList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;11d6689d-a037-4747-a229-954415b8f9bb&quot;,
      &quot;parentUUID&quot;: &quot;16a7d0ec-eff6-4c1e-b0a2-96b5023f28b7&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c4cc0b0b-6b8f-41ea-9a53-91e16588f888&quot;,
      &quot;parentUUID&quot;: &quot;593b6f34-b5fb-4e1f-8117-88ce31efb1d6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5798ff59-f615-40a4-9379-e3367c09bca1&quot;,
      &quot;parentUUID&quot;: &quot;593b6f34-b5fb-4e1f-8117-88ce31efb1d6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 6,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;body.result.action = &#x27;user.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;admin&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b7c17fae-a330-4285-888b-84e73a2eb799&quot;,
      &quot;parentUUID&quot;: &quot;8cf54c2f-0e48-44d6-b5d7-c1237ee754da&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;body.result.action = &#x27;guest.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;, company : \&quot;Google\&quot;}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;welcome&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1c5bed1b-549e-4c01-9ed2-e8e8a5b59c47&quot;,
      &quot;parentUUID&quot;: &quot;8cf54c2f-0e48-44d6-b5d7-c1237ee754da&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;expect(obs.next.bind(obs)).to.throw();&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7bf001b9-14e5-43f5-91b2-55a3a172db23&quot;,
      &quot;parentUUID&quot;: &quot;2832d5dc-6eab-4ce3-ab05-429192baf2b5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ba7a3292-d981-45db-87b3-320d5225e372&quot;,
      &quot;parentUUID&quot;: &quot;fbf94060-5c23-4d02-a23f-2b8159a9a9c9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addGuest Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addGuest(&#x27;mauro&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a7ac054b-9f0c-40ba-a159-e0d73b819b33&quot;,
      &quot;parentUUID&quot;: &quot;fbf94060-5c23-4d02-a23f-2b8159a9a9c9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \&quot;error getting data\&quot; });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;34286308-449b-4cfb-b847-d6935bd368a6&quot;,
      &quot;parentUUID&quot;: &quot;6c067e6c-6c8b-454f-a7e3-d950fb0a759a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getGuest Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \&quot;Mauro\&quot;);\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\&quot;Zero12\&quot;);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;58eb8708-39e9-4097-8efb-cef8fa2d136e&quot;,
      &quot;parentUUID&quot;: &quot;6c067e6c-6c8b-454f-a7e3-d950fb0a759a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }], LastEvaluatedKey: &#x27;Luca&#x27;});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f69e29f9-43b0-4d4e-b643-f3fe2faaf418&quot;,
      &quot;parentUUID&quot;: &quot;68008c55-3c83-4bf0-80b0-c04d088146ff&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getGuestList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c7e77fab-0d3d-42f8-b91c-0d9f45023f25&quot;,
      &quot;parentUUID&quot;: &quot;68008c55-3c83-4bf0-80b0-c04d088146ff&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing guest\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7e44c3a2-b685-47b6-af99-02c9aed30f61&quot;,
      &quot;parentUUID&quot;: &quot;ab77ccba-5ac2-4a6e-b117-160991999bdc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeGuest Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;33b2f989-36a5-4a8d-a2b5-80e8e2f345f2&quot;,
      &quot;parentUUID&quot;: &quot;ab77ccba-5ac2-4a6e-b117-160991999bdc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating guest\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;aec03e00-faea-4fb5-89e9-bd7a6a0b74c7&quot;,
      &quot;parentUUID&quot;: &quot;d9f00da6-095f-4d67-8e26-267e2cc18562&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9e60621b-df5c-46d3-91d4-48edb170f56e&quot;,
      &quot;parentUUID&quot;: &quot;d9f00da6-095f-4d67-8e26-267e2cc18562&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d3816f27-c751-4b9e-bd5d-7513dd19edcc&quot;,
      &quot;parentUUID&quot;: &quot;a5895612-deec-406e-86ae-7bbfd2179a2e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8d1b7052-8b4c-4c49-b68b-a2c3ce17174a&quot;,
      &quot;parentUUID&quot;: &quot;a5895612-deec-406e-86ae-7bbfd2179a2e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;addMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.addMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9124e0dc-9a80-4804-ade8-1715f0aa7f91&quot;,
      &quot;parentUUID&quot;: &quot;b288877f-c889-45c7-9c3b-df02e109c51c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
      &quot;fullTitle&quot;: &quot;getMember Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t&#x27;ok&#x27;: true,\n\t&#x27;user&#x27;:\n\t{\n\t\t&#x27;id&#x27;: &#x27;U023BECGF&#x27;,\n\t\t&#x27;name&#x27;: &#x27;bobby&#x27;,\n\t\t&#x27;deleted&#x27;: false,\n\t\t&#x27;color&#x27;: &#x27;9f69e7&#x27;,\n\t\t&#x27;profile&#x27;:\n\t\t{\n\t\t\t&#x27;avatar_hash&#x27;: &#x27;ge3b51ca72de&#x27;,\n\t\t\t&#x27;current_status&#x27;: &#x27;:mountain_railway: riding a train&#x27;,\n\t\t\t&#x27;first_name&#x27;: &#x27;Bobby&#x27;,\n\t\t\t&#x27;last_name&#x27;: &#x27;Tables&#x27;,\n\t\t\t&#x27;real_name&#x27;: &#x27;Bobby Tables&#x27;,\n\t\t\t&#x27;email&#x27;: &#x27;bobby@slack.com&#x27;,\n\t\t\t&#x27;skype&#x27;: &#x27;my-skype-name&#x27;,\n\t\t\t&#x27;phone&#x27;: &#x27;+1 (123) 456 7890&#x27;\n\t\t},\n\t\t&#x27;is_admin&#x27;: true,\n\t\t&#x27;is_owner&#x27;: true,\n\t\t&#x27;updated&#x27;: 1490054400,\n\t\t&#x27;has_2fa&#x27;: true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e638043b-92ea-4de7-bece-8a1b5392234a&quot;,
      &quot;parentUUID&quot;: &quot;850684c7-c07a-439c-af8d-2009e90abe3f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getMember Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;44eb039c-9826-4af6-a33f-9acba7143eca&quot;,
      &quot;parentUUID&quot;: &quot;850684c7-c07a-439c-af8d-2009e90abe3f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
      &quot;fullTitle&quot;: &quot;getMemberList L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\&quot;ok\&quot;: true,\n\t\&quot;members\&quot;:\n\t[\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECGF\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;mauro\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Mauro Bocciofilo\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t},\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECLL\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;bobby\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;,\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0d356164-ba47-4a63-ba02-141042f2198b&quot;,
      &quot;parentUUID&quot;: &quot;41aa1ca7-8ac2-423f-84c2-bd66a990cbce&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getMemberList Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2f4e768c-db0f-4671-8c61-e549cf1d4a9f&quot;,
      &quot;parentUUID&quot;: &quot;41aa1ca7-8ac2-423f-84c2-bd66a990cbce&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;removeMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.removeMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b977af02-994d-4ef2-869b-c8ba632b66bc&quot;,
      &quot;parentUUID&quot;: &quot;eb4eca28-7408-4537-b9ed-9fa99c4124d0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;updateMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.updateMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;83627090-20af-45ef-a6f6-6ee4068f60f0&quot;,
      &quot;parentUUID&quot;: &quot;06e6b702-ebfd-49a7-827d-040496396199&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(&#x27;errore&#x27;);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n  done();\n}&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fe08a1c2-6614-4a6f-b0ce-e0c3740a1572&quot;,
      &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields(&#x27;errore&#x27;);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;950753c4-de38-4569-b415-4de68b12ba70&quot;,
      &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 10,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(&#x27;errore&#x27;);\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3745ba25-aac2-487b-9b7e-b7a1936169c2&quot;,
      &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 200);\n  done();\n}&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;79c9a493-9ecd-4664-8296-095fd3448985&quot;,
      &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(&#x27;errore&#x27;);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c97cd393-9c5e-4a7d-b87c-df4b9ed2ec40&quot;,
      &quot;parentUUID&quot;: &quot;82121586-7ebf-4b8f-81ad-482f20e1f150&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b48e593e-60f4-4d74-bdc3-5116e68ed400&quot;,
      &quot;parentUUID&quot;: &quot;82121586-7ebf-4b8f-81ad-482f20e1f150&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\n\nexpect(context.succeed.callCount).to.equal(1);\t\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;dcf38ebe-517a-44db-a8eb-e406e807bc87&quot;,
      &quot;parentUUID&quot;: &quot;82121586-7ebf-4b8f-81ad-482f20e1f150&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare complete_cb&quot;,
      &quot;fullTitle&quot;: &quot;complete Deve chiamare complete_cb&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \&quot;il callback di complete non è stato chiamato esattamente una volta.\&quot;).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;266356f0-2c09-457e-9898-88d0353aec28&quot;,
      &quot;parentUUID&quot;: &quot;1f4096b9-07ac-4666-ad60-fe12faafafb9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;complete Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;541466b2-1e94-40f3-b81e-41c33f564c8e&quot;,
      &quot;parentUUID&quot;: &quot;1f4096b9-07ac-4666-ad60-fe12faafafb9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;complete Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;87a4d294-1116-4de3-9e67-fe953327534f&quot;,
      &quot;parentUUID&quot;: &quot;1f4096b9-07ac-4666-ad60-fe12faafafb9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare error_cb&quot;,
      &quot;fullTitle&quot;: &quot;error Deve chiamare error_cb&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b867b36e-175a-4938-84a4-66e65009b5df&quot;,
      &quot;parentUUID&quot;: &quot;c18b6f7b-5fe0-4324-8600-39dc0fffd4a8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;error Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onError(success);\nobs.pause();\nobs.error(&#x27;errore&#x27;);\n        expect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a0bb7ace-983c-4e07-b96a-5ed6f32b2fe4&quot;,
      &quot;parentUUID&quot;: &quot;c18b6f7b-5fe0-4324-8600-39dc0fffd4a8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;error Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;486b05b9-6abe-470c-bf32-14527d9b8e92&quot;,
      &quot;parentUUID&quot;: &quot;c18b6f7b-5fe0-4324-8600-39dc0fffd4a8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal(&#x27;data&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bd61bd1b-348a-4518-989d-4dcbddb6b98a&quot;,
      &quot;parentUUID&quot;: &quot;64a152d5-e756-42c1-b3a8-1340d96b4c84&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;next Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.pause();\nobs.next(&#x27;Function called&#x27;);\nexpect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;99675446-3ae4-43d7-abd1-63593239fff9&quot;,
      &quot;parentUUID&quot;: &quot;64a152d5-e756-42c1-b3a8-1340d96b4c84&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next(&#x27;other data&#x27;);\nexpect(success.callCount).to.equal(2);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ad0c76c9-3bfd-455a-8f43-e795f029d3a8&quot;,
      &quot;parentUUID&quot;: &quot;64a152d5-e756-42c1-b3a8-1340d96b4c84&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;14c1f94c-b93c-443d-8b89-52918d25737a&quot;,
      &quot;parentUUID&quot;: &quot;99cd732f-b8d0-4311-8433-f5148d954952&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;060d651a-0fa5-4a3d-9e88-e39161145e57&quot;,
      &quot;parentUUID&quot;: &quot;99cd732f-b8d0-4311-8433-f5148d954952&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e9804184-ccfe-4d89-80a9-52cf4c80cf70&quot;,
      &quot;parentUUID&quot;: &quot;c5b11645-a8b4-4fe7-8cce-9c7558b860ee&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;845c63bf-6b9a-4b9c-9678-0573261f627f&quot;,
      &quot;parentUUID&quot;: &quot;c5b11645-a8b4-4fe7-8cce-9c7558b860ee&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8b7cfee7-7f7e-46b8-93e1-43dfbc0dc69c&quot;,
      &quot;parentUUID&quot;: &quot;52769ebd-e9fe-443a-ae9a-a12e138dcd6a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e0b6284f-36ea-4d9a-a716-d0d4ec002a6a&quot;,
      &quot;parentUUID&quot;: &quot;52769ebd-e9fe-443a-ae9a-a12e138dcd6a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;//da definire&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6e31b9e0-7848-440f-8ac0-753099b54589&quot;,
      &quot;parentUUID&quot;: &quot;52769ebd-e9fe-443a-ae9a-a12e138dcd6a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeRule Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3ab5c6ea-f59a-47f1-851a-bb7709431644&quot;,
      &quot;parentUUID&quot;: &quot;3f62f872-6f6d-4557-854c-d840decf9478&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeRule Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f2e98598-18b4-4563-8a02-f08ca8ba30f2&quot;,
      &quot;parentUUID&quot;: &quot;3f62f872-6f6d-4557-854c-d840decf9478&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;473392b8-4ed4-4ebd-b3c7-384d9fc3d1f4&quot;,
      &quot;parentUUID&quot;: &quot;f9d6a484-0f03-4ec5-8a24-20d2d342e481&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;68bc772f-e4a3-4d8f-9e6e-e4536bf2c9f8&quot;,
      &quot;parentUUID&quot;: &quot;f9d6a484-0f03-4ec5-8a24-20d2d342e481&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \&quot;\&quot;};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;70ee10f2-237b-4d02-8fc2-c8181e88206e&quot;,
      &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;578152e8-74c7-4b7e-b00a-5abedb90652c&quot;,
      &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d1bae73f-4f20-46e6-8d91-cd19b6c8bc1a&quot;,
      &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0860e059-fb75-40e5-ac35-9e8d5a37626e&quot;,
      &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9d7aea3e-cfe8-4fba-9401-0f2143380e25&quot;,
      &quot;parentUUID&quot;: &quot;b0cd57ab-1871-41ef-ad1d-0d8489d24631&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b07d46c0-8d9a-45df-931d-aaf2f933841a&quot;,
      &quot;parentUUID&quot;: &quot;b0cd57ab-1871-41ef-ad1d-0d8489d24631&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);\n};&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0746403d-d22c-4101-9987-96babe62b01c&quot;,
      &quot;parentUUID&quot;: &quot;b0cd57ab-1871-41ef-ad1d-0d8489d24631&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f0ac06a3-9f31-4507-97c1-42a59601b383&quot;,
      &quot;parentUUID&quot;: &quot;c620c4b8-5395-40c5-b511-7007d5fd0082&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;544b0758-2f74-4af7-9e2a-e2131b4338d1&quot;,
      &quot;parentUUID&quot;: &quot;c620c4b8-5395-40c5-b511-7007d5fd0082&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;db6e92ea-55cd-49cf-9548-c979bf895a54&quot;,
      &quot;parentUUID&quot;: &quot;c620c4b8-5395-40c5-b511-7007d5fd0082&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f39aaebc-0b28-4886-9390-9677ae8f2f4a&quot;,
      &quot;parentUUID&quot;: &quot;65381f65-d23d-45b4-9235-f22e3a7805bc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3adcdc7f-f49b-4882-915d-ac8057dac137&quot;,
      &quot;parentUUID&quot;: &quot;65381f65-d23d-45b4-9235-f22e3a7805bc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a05a14e2-b44f-409c-bde1-56d0daa1d44f&quot;,
      &quot;parentUUID&quot;: &quot;13b1946e-df90-4a81-994a-4cb0e9768415&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b0b55a35-1ac8-4cbd-a575-0e257b0dff3d&quot;,
      &quot;parentUUID&quot;: &quot;13b1946e-df90-4a81-994a-4cb0e9768415&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8218d9fa-d939-4d9a-adc0-c39f68c8e840&quot;,
      &quot;parentUUID&quot;: &quot;fa8c5f09-bf69-43ee-8461-e355fd4e2c26&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \&quot;\&quot; , body: \&quot;\&quot;};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8046d304-b28d-486c-b452-ba0a7f1f53a1&quot;,
      &quot;parentUUID&quot;: &quot;fa8c5f09-bf69-43ee-8461-e355fd4e2c26&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ddccc301-f1ab-422a-bf55-616c435bfc0f&quot;,
      &quot;parentUUID&quot;: &quot;fa8c5f09-bf69-43ee-8461-e355fd4e2c26&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
      &quot;fullTitle&quot;: &quot;speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;eec7a506-bc63-4025-b230-072af4bb118e&quot;,
      &quot;parentUUID&quot;: &quot;722fee07-a362-4c85-8d65-48385fbd1ba8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2bc4be46-07a2-4ae9-bac3-0191cbb86bbe&quot;,
      &quot;parentUUID&quot;: &quot;bdeb3d10-d456-45b9-ab67-86ab4e775fe0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9f0d3a11-a694-46b8-b03d-664df360da8b&quot;,
      &quot;parentUUID&quot;: &quot;bdeb3d10-d456-45b9-ab67-86ab4e775fe0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getTask Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTask(&#x27;mock_type&#x27;).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8b74b208-52e4-496c-bbc6-cc338bd3ee8b&quot;,
      &quot;parentUUID&quot;: &quot;4eeffb5f-a5f8-4bd2-8afc-ed29c769c410&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getTask Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = tasks.getTask(&#x27;mock_type&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9dad8baf-0b66-41c4-955d-444f670aab07&quot;,
      &quot;parentUUID&quot;: &quot;4eeffb5f-a5f8-4bd2-8afc-ed29c769c410&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \&quot;mock_type3\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d6369442-d023-47d9-acf2-035b5a5f8a97&quot;,
      &quot;parentUUID&quot;: &quot;7497c08f-8957-4b86-bed8-53971d644988&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3a6b58a5-faa5-4226-ab7f-8f1d917de358&quot;,
      &quot;parentUUID&quot;: &quot;7497c08f-8957-4b86-bed8-53971d644988&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0619ff56-7e97-40c0-86f2-9622a0e819e8&quot;,
      &quot;parentUUID&quot;: &quot;7081eace-4a18-4213-b1e5-56f03e766329&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0594ac80-9b39-4832-b0cc-723fd97989d3&quot;,
      &quot;parentUUID&quot;: &quot;7081eace-4a18-4213-b1e5-56f03e766329&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5df90199-2eb3-4da5-90f2-2d3c456a4bf9&quot;,
      &quot;parentUUID&quot;: &quot;bc2ad69b-b590-4b79-ad37-418cc3bb43ca&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;90db800a-403e-4683-a606-cd6e1b574d2a&quot;,
      &quot;parentUUID&quot;: &quot;bc2ad69b-b590-4b79-ad37-418cc3bb43ca&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\&quot;Requested resource not found\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;113eb5ba-ef75-4b55-8cfb-9452ea262de3&quot;,
      &quot;parentUUID&quot;: &quot;f2a56d12-aba8-4270-b126-3bdcf435cc38&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bbe398fc-ed90-40c2-aeb9-c2a052983167&quot;,
      &quot;parentUUID&quot;: &quot;f2a56d12-aba8-4270-b126-3bdcf435cc38&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fde4a879-5c96-447b-b3d9-dd551c7c1e27&quot;,
      &quot;parentUUID&quot;: &quot;7b5bd02f-b262-4e1a-b1c0-9a171f2f422c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = users.getUser(&#x27;mou&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\n\t\t\t\t\texpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;251d9e86-935a-4c25-99c9-fbfff0c4807e&quot;,
      &quot;parentUUID&quot;: &quot;7b5bd02f-b262-4e1a-b1c0-9a171f2f422c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}], LastEvaluatedKey: &#x27;marco&#x27;});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;74969315-cf07-4f95-a638-72cfa1bd5923&quot;,
      &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;530daf9f-500b-4611-bb19-52d516480625&quot;,
      &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4a20adbe-a87e-4be4-9a98-3c92dd94c74e&quot;,
      &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;,\n\tslack_channel: &#x27;channel&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name and slack_channel = :slack_channel&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:slack_channel&#x27;, &#x27;channel&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6a19b03c-f9aa-4541-a9b0-1e68a83b48d9&quot;,
      &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeUser Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \&quot;error removing user\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;302333dd-0b16-4fff-8d2d-7cafef9dea54&quot;,
      &quot;parentUUID&quot;: &quot;3758adcf-d96c-4cc0-98e6-324c57e2c0de&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;removeUser Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bc1f1ffa-3a42-431b-be3d-d78afdcfbee4&quot;,
      &quot;parentUUID&quot;: &quot;3758adcf-d96c-4cc0-98e6-324c57e2c0de&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \&quot;error updating user\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a3b08d0f-670a-4580-ad85-52bc4dbe35be&quot;,
      &quot;parentUUID&quot;: &quot;0ddde174-da9d-475b-a4a1-0d679a90e42e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c42b78b0-dcc3-4107-8080-1817b374ab9c&quot;,
      &quot;parentUUID&quot;: &quot;0ddde174-da9d-475b-a4a1-0d679a90e42e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6f07b354-0b1d-4c39-8b95-af82a5eb7e75&quot;,
      &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 8,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;32dbbe15-a247-446d-ba09-4c39dc293baa&quot;,
      &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \&quot;\&quot; };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c0152ad0-5909-4fed-8f84-95cb1951436a&quot;,
      &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;70286ef3-7e9a-447e-9e17-68bc3142ed62&quot;,
      &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;252eccac-4b9a-42f8-9af9-e6d699e93930&quot;,
      &quot;parentUUID&quot;: &quot;e285b6c0-ed97-4242-9633-b5b8c181d83e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6da076c0-3d30-4fac-94e4-4a146973c093&quot;,
      &quot;parentUUID&quot;: &quot;e285b6c0-ed97-4242-9633-b5b8c181d83e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { pathParameters: { username: &#x27;pippo&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6b6fbf80-92bf-4031-a26a-639bd573e663&quot;,
      &quot;parentUUID&quot;: &quot;e285b6c0-ed97-4242-9633-b5b8c181d83e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;050e5250-1e63-4852-b306-8e24b640eee6&quot;,
      &quot;parentUUID&quot;: &quot;c10d8e7a-9e00-49b8-8523-3ac0d6b9d943&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cab6a2d1-6fe2-48c7-a2d2-b5219594a56b&quot;,
      &quot;parentUUID&quot;: &quot;c10d8e7a-9e00-49b8-8523-3ac0d6b9d943&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\n          let ev = { pathParameters: { username: &#x27;pippo&#x27;} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a45e9b7a-3177-4b9c-bacf-537c61bd8f6f&quot;,
      &quot;parentUUID&quot;: &quot;c10d8e7a-9e00-49b8-8523-3ac0d6b9d943&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b17e8659-c0cb-43a3-9afc-344abf554073&quot;,
      &quot;parentUUID&quot;: &quot;c840bd3e-98a5-4665-a53f-441881be5c6d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ users: [{ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;abe4d296-4e35-4248-9bad-9568d454116b&quot;,
      &quot;parentUUID&quot;: &quot;c840bd3e-98a5-4665-a53f-441881be5c6d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5f53512a-dcf3-447c-a35e-49a6762de02e&quot;,
      &quot;parentUUID&quot;: &quot;948ecded-16a5-4b59-9853-f247b32964c1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;103ca95a-6251-4ce9-bf4e-bf8be825689f&quot;,
      &quot;parentUUID&quot;: &quot;948ecded-16a5-4b59-9853-f247b32964c1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = { pathParameters: \&quot;\&quot;, body: \&quot;\&quot; };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a10364a7-6993-4073-95de-5896508de88a&quot;,
      &quot;parentUUID&quot;: &quot;948ecded-16a5-4b59-9853-f247b32964c1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;216d7ba3-9505-4b6d-9810-ad8d0b5aae3c&quot;,
      &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;561ffda1-1532-41be-a2d6-8728834ace14&quot;,
      &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;msg&#x27;: &#x27;error getting guest&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d1ad3af6-0db1-411a-b972-82acd2989867&quot;,
      &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ &#x27;msg&#x27;: &#x27;error adding conversation&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7340828e-233f-4665-961a-7fa663bd1b6f&quot;,
      &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;type&#x27;: &#x27;example&#x27; });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6532740e-492d-4894-b1cc-b23b5ec5d50a&quot;,
      &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
      &quot;fullTitle&quot;: &quot;query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith(&#x27;test&#x27;));\n\tlet result = context.succeed.getCall(0).args[0];\n            expect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n            done();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;74310b24-396f-472c-9045-f21ef6c302f8&quot;,
      &quot;parentUUID&quot;: &quot;9a9982d0-dc2b-41ea-a17d-b365069a6cd6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
      &quot;fullTitle&quot;: &quot;query Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.reject(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n            done();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bc6eacdb-d762-41c1-b76d-240b80da6346&quot;,
      &quot;parentUUID&quot;: &quot;9a9982d0-dc2b-41ea-a17d-b365069a6cd6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;08b416ef-6b47-4a45-b4c1-8af30b23e52d&quot;,
      &quot;parentUUID&quot;: &quot;96f2ecb5-a479-4e28-b76d-f8832d782a93&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;951465a6-0832-4329-8e8d-a08ba4aacdca&quot;,
      &quot;parentUUID&quot;: &quot;5108413b-e03f-4ba0-870b-cb2f776a81d2&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.addEnrollment.returns(Rx.Observable.throw(errore));\napi._addUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;585df43e-fe1c-4635-8bf3-2e1d05630718&quot;,
      &quot;parentUUID&quot;: &quot;5462f899-0bf8-46a1-95c0-d348272f334f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8e4966b6-fde1-4679-819e-7f68890a238b&quot;,
      &quot;parentUUID&quot;: &quot;4bbb01bf-3cd5-4be1-b39e-639095dc6d9e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e4eea84b-f84c-4f13-93c7-476de3e450f8&quot;,
      &quot;parentUUID&quot;: &quot;cbebbb49-802b-439b-81a9-ec44a9a4a6fc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c1bf914b-21be-41bb-81f2-9bcad72a3721&quot;,
      &quot;parentUUID&quot;: &quot;06dbdeb3-20e3-4e34-83da-fee48d38f31a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;96e42e6e-4c57-44fc-8b87-c26947f83c80&quot;,
      &quot;parentUUID&quot;: &quot;56c3d595-e98c-4521-aa04-1b00884273c4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
      &quot;fullTitle&quot;: &quot;_loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.doLogin.returns(Rx.Observable.throw(errore));\napi._loginUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;93305c00-0b65-42f8-abca-cf39a453cd9d&quot;,
      &quot;parentUUID&quot;: &quot;323887bb-8fab-4dba-bb46-7110505e3e38&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2001,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b0d1973c-8999-4483-a0ee-6ff2bce0258b&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2001,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8f56444d-4ea6-480e-85ef-cb69c4e06f5a&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2001,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a62bb99e-109c-4536-8b68-6fba13237117&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;61cff039-8c19-48fc-b2fc-be9822a85d87&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;374e4b65-e451-4ee1-9028-36401ced83e8&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1871f858-9fff-4e83-ada6-123034b6cf27&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUserList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUserList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUserList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUserList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1f96f57a-8d36-4f11-b9e4-3deee894c7fa&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4c2ec230-fa9a-4e7b-889d-0f2d35885f13&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2001,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b99d79ad-42e9-4d94-85cf-e4c023140f60&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;abecccbc-1e66-4027-b832-8fc0e2428c23&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1dac11d0-473d-4833-8390-8ff0968e0e34&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;99b05fb2-3e32-418e-80cf-24133ea2fbc1&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c9036fa3-3497-467c-b60c-977926b5b84e&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          };\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0fc744cf-8ab5-424d-9fab-d83371b0cd7e&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d237b2ce-caed-4682-858d-3919ba1daf04&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e31bef5b-f76b-42bd-8271-1c9627530134&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;47a5f0ad-04bf-4d39-8274-50cc94705b77&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;29ee8baa-e98c-4864-b1d5-5e9b0346c92d&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7db6716a-41b4-4159-91e8-53e12836d705&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ba6cb505-baf3-4a21-9230-df1937a7c18b&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7d6dc886-bca5-4706-92e6-7845e2534ec5&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1a77c1aa-fc09-456b-8bc0-d34b437403f2&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1ab0085f-ae95-4015-8748-94a2fb749ebf&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2001,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;68c4fb53-8fe5-4d3b-bf80-46d585b28be7&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9aaf87f4-ff0a-451d-807f-08091d552ed6&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a5c7ce28-87c2-4fbb-b054-3dc49d69815a&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n\texpect(response).have.property(&#x27;statusCode&#x27;, 200);\n\tdone();\n};\napi.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bfab2fc5-0c9b-4737-baa7-aa56ce75d65d&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7f7d7be5-e89e-413f-b5bd-6205042269e2&quot;,
      &quot;parentUUID&quot;: &quot;34d39c6c-e17a-4d9a-9dd9-38719edb4e02&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;86b37758-cc9a-4cc2-96f4-437326a544b2&quot;,
      &quot;parentUUID&quot;: &quot;edd16b1b-2848-4163-bdfc-0a235e349b7d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.resetEnrollments.returns(Rx.Observable.throw(errore));\napi._resetUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cbd9dbdc-ff08-4aad-9650-d55d97b83a2b&quot;,
      &quot;parentUUID&quot;: &quot;a9a5997b-4223-4585-aebf-01aea7226654&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;84a272bb-289d-4852-90fc-b307fa4bb737&quot;,
      &quot;parentUUID&quot;: &quot;229d8160-1071-4801-aa4b-c69e07707ad4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5f79f361-39a1-4fa0-bbfd-ba56794ad4e4&quot;,
      &quot;parentUUID&quot;: &quot;4d1b9bae-6abd-4d9d-a099-cfe45a9d0c84&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;098d06dd-e6a5-4174-b054-9f7afc2632b8&quot;,
      &quot;parentUUID&quot;: &quot;02e97a6d-902d-467d-8cf4-c5cb5670b1f6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b74572cc-8fc7-4122-a7c4-9caa26698e11&quot;,
      &quot;parentUUID&quot;: &quot;54363c6b-f4bd-46af-82b6-67e3344d385a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1ddc0c88-fe65-4185-9184-e24ce44efdc5&quot;,
      &quot;parentUUID&quot;: &quot;2e4c08c9-84fd-4a84-8f76-712ad059b5d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject({ \&quot;result\&quot; : \&quot;Reject\&quot; }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7847c4d7-5c7e-4a87-a3a9-852afc45be4b&quot;,
      &quot;parentUUID&quot;: &quot;14388c7a-a9ae-4b7a-973b-19bd0860b778&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8e67fe00-6bd6-4e0d-91f8-4f51dc071e58&quot;,
      &quot;parentUUID&quot;: &quot;b62abe05-31fc-4de5-9965-1399e31338cb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n  {\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f5e91688-96ff-47cd-97e0-91224b516fbf&quot;,
      &quot;parentUUID&quot;: &quot;e48e9887-0ed5-4eda-807d-e544783d35db&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;resetEnrollments Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.resetEnrollments().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;47c9ba79-3d61-40e4-8aeb-31e6549fcfe1&quot;,
      &quot;parentUUID&quot;: &quot;bcfbb69a-a9f2-47d2-b07e-da7f7a38a158&quot;,
      &quot;skipped&quot;: false
    }
  ],
  &quot;allPending&quot;: [],
  &quot;allPasses&quot;: [
    {
      &quot;title&quot;: &quot;La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8d1f4836-dc03-4e4a-a95e-8cee60ee25df&quot;,
      &quot;parentUUID&quot;: &quot;d288bf21-99dc-4256-8659-edbbbd644074&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cb6595a7-63ce-4782-b715-61e4d220a581&quot;,
      &quot;parentUUID&quot;: &quot;d288bf21-99dc-4256-8659-edbbbd644074&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b2ac5a0d-ca5d-4472-a26c-75b0db5ba26c&quot;,
      &quot;parentUUID&quot;: &quot;271810cc-1f1f-4c41-8973-8463a1955421&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d854a743-9d6b-47ea-925e-da8b3f68a075&quot;,
      &quot;parentUUID&quot;: &quot;271810cc-1f1f-4c41-8973-8463a1955421&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getAgent Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8e69b9d4-2d10-4a54-8f1d-eb1128fa733a&quot;,
      &quot;parentUUID&quot;: &quot;d501a162-deaa-4a3d-87cc-05a7871daa02&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getAgent Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = agents.getAgent(&#x27;mock_name&#x27;);\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;25b8a6a1-f229-4daa-896b-36897deb9329&quot;,
      &quot;parentUUID&quot;: &quot;d501a162-deaa-4a3d-87cc-05a7871daa02&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;2&#x27;});\ndynamo_client.scan.yield({statusCode:500, msg:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d151a69c-b5f1-4f40-bef6-ecf8ff627c9c&quot;,
      &quot;parentUUID&quot;: &quot;85405992-e8cd-44a4-a7d1-8ed755a7b79e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getAgentList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: &#x27;1&#x27;});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;eeef799f-d07e-4504-870b-89f1c4550a59&quot;,
      &quot;parentUUID&quot;: &quot;85405992-e8cd-44a4-a7d1-8ed755a7b79e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeAgent Nel caso in cui un agente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\&quot;error removing rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ea52fb1f-3f4f-4dba-aa75-c6e5d398e644&quot;,
      &quot;parentUUID&quot;: &quot;f898a002-50f7-45a7-8577-dd720980b622&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeAgent Nel caso in cui un agente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.removeAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\&quot;success\&quot;});\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5fcf6b0d-9fa3-431c-98e9-5730d5ad5a4b&quot;,
      &quot;parentUUID&quot;: &quot;f898a002-50f7-45a7-8577-dd720980b622&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateAgent Nel caso in cui un agente non venga aggiornato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d3b1d60c-682e-4e92-ad36-9bc74c7fcf88&quot;,
      &quot;parentUUID&quot;: &quot;5660c634-c2d6-4b65-9cf1-9fd4e3ff287a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateAgent Nel caso in cui un agente sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.updateAgent(&#x27;mock_name&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3fe30903-df2c-427d-992c-21ab970a6283&quot;,
      &quot;parentUUID&quot;: &quot;5660c634-c2d6-4b65-9cf1-9fd4e3ff287a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
      &quot;fullTitle&quot;: &quot;query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell&#x27;assistente virtuale&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;38ea45b1-986f-4ac7-a6dd-cb723376086a&quot;,
      &quot;parentUUID&quot;: &quot;cd4ec5b9-8d71-4bc5-b5ce-522790eba84a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
      &quot;fullTitle&quot;: &quot;query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9436f267-b973-44d9-8fdb-033d4d248f37&quot;,
      &quot;parentUUID&quot;: &quot;cd4ec5b9-8d71-4bc5-b5ce-522790eba84a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \&quot;Requested resource not found\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e0331540-b400-4e9b-90e6-c9e59c94d6b7&quot;,
      &quot;parentUUID&quot;: &quot;a2264cdb-ff82-4bbc-8055-dbe3c1b363d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27; Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;764d9115-ec97-4040-881c-441129b7c934&quot;,
      &quot;parentUUID&quot;: &quot;a2264cdb-ff82-4bbc-8055-dbe3c1b363d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \&quot;error adding message\&quot; });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e22464f1-289c-40ce-a381-6bd7a8cd4067&quot;,
      &quot;parentUUID&quot;: &quot;96376b9f-90cd-417d-b93f-e03966923ae8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.addMessage({sender:&#x27;mock_sender&#x27;,text: &#x27;mock_text&#x27;, timestamp: &#x27;2000-10-10&#x27;},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4a8d5266-fe07-4ed5-94b3-a97ea0f6f8c4&quot;,
      &quot;parentUUID&quot;: &quot;96376b9f-90cd-417d-b93f-e03966923ae8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \&quot;error downloading conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7e9938b1-c86a-43d4-9694-c2119a23f457&quot;,
      &quot;parentUUID&quot;: &quot;c5b491fd-0ff0-47a8-b08e-8d44805b5e91&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getConversation Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;920b6361-6aca-4bea-b50b-ca27082e4f0b&quot;,
      &quot;parentUUID&quot;: &quot;c5b491fd-0ff0-47a8-b08e-8d44805b5e91&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5fb2f987-5649-4ce6-a9fe-bc55b45a1b03&quot;,
      &quot;parentUUID&quot;: &quot;16a7d0ec-eff6-4c1e-b0a2-96b5023f28b7&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getConversationList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;11d6689d-a037-4747-a229-954415b8f9bb&quot;,
      &quot;parentUUID&quot;: &quot;16a7d0ec-eff6-4c1e-b0a2-96b5023f28b7&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing conversation\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c4cc0b0b-6b8f-41ea-9a53-91e16588f888&quot;,
      &quot;parentUUID&quot;: &quot;593b6f34-b5fb-4e1f-8117-88ce31efb1d6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5798ff59-f615-40a4-9379-e3367c09bca1&quot;,
      &quot;parentUUID&quot;: &quot;593b6f34-b5fb-4e1f-8117-88ce31efb1d6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta deve avere il campo name del context uguale a &#x27;admin&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come possibile amministratore.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 6,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;body.result.action = &#x27;user.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;admin&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b7c17fae-a330-4285-888b-84e73a2eb799&quot;,
      &quot;parentUUID&quot;: &quot;8cf54c2f-0e48-44d6-b5d7-c1237ee754da&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
      &quot;fullTitle&quot;: &quot;webhook La risposta deve avere il campo name del context uguale a &#x27;welcome&#x27; nel caso in cui l&#x27;utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;body.result.action = &#x27;guest.check&#x27;;\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \&quot;Mauro Carlin\&quot;, username : \&quot;mou\&quot;, company : \&quot;Google\&quot;}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property(&#x27;name&#x27;, &#x27;welcome&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1c5bed1b-549e-4c01-9ed2-e8e8a5b59c47&quot;,
      &quot;parentUUID&quot;: &quot;8cf54c2f-0e48-44d6-b5d7-c1237ee754da&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve sollevare un&#x27;eccezione se viene chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;expect(obs.next.bind(obs)).to.throw();&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7bf001b9-14e5-43f5-91b2-55a3a172db23&quot;,
      &quot;parentUUID&quot;: &quot;2832d5dc-6eab-4ce3-ab05-429192baf2b5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ba7a3292-d981-45db-87b3-320d5225e372&quot;,
      &quot;parentUUID&quot;: &quot;fbf94060-5c23-4d02-a23f-2b8159a9a9c9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addGuest Nel caso in cui un ospite sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addGuest(&#x27;mauro&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a7ac054b-9f0c-40ba-a159-e0d73b819b33&quot;,
      &quot;parentUUID&quot;: &quot;fbf94060-5c23-4d02-a23f-2b8159a9a9c9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \&quot;error getting data\&quot; });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;34286308-449b-4cfb-b847-d6935bd368a6&quot;,
      &quot;parentUUID&quot;: &quot;6c067e6c-6c8b-454f-a7e3-d950fb0a759a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getGuest Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuest(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \&quot;Mauro\&quot;);\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\&quot;Zero12\&quot;);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;58eb8708-39e9-4097-8efb-cef8fa2d136e&quot;,
      &quot;parentUUID&quot;: &quot;6c067e6c-6c8b-454f-a7e3-d950fb0a759a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{ name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }], LastEvaluatedKey: &#x27;Luca&#x27;});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f69e29f9-43b0-4d4e-b643-f3fe2faaf418&quot;,
      &quot;parentUUID&quot;: &quot;68008c55-3c83-4bf0-80b0-c04d088146ff&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;getGuestList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Mauro\&quot;, company : \&quot;Zero12\&quot; }], LastEvaluatedKey: &#x27;Piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name : \&quot;Piero\&quot;, company : \&quot;Google\&quot; }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;Mauro&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Zero12&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;Piero&#x27;);\nexpect(callNext.args[0].company).to.equal(&#x27;Google&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c7e77fab-0d3d-42f8-b91c-0d9f45023f25&quot;,
      &quot;parentUUID&quot;: &quot;68008c55-3c83-4bf0-80b0-c04d088146ff&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \&quot;error removing guest\&quot; });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7e44c3a2-b685-47b6-af99-02c9aed30f61&quot;,
      &quot;parentUUID&quot;: &quot;ab77ccba-5ac2-4a6e-b117-160991999bdc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeGuest Nel caso in cui un ospite sia eliminato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.removeGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \&quot;success\&quot; });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;33b2f989-36a5-4a8d-a2b5-80e8e2f345f2&quot;,
      &quot;parentUUID&quot;: &quot;ab77ccba-5ac2-4a6e-b117-160991999bdc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating guest\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;aec03e00-faea-4fb5-89e9-bd7a6a0b74c7&quot;,
      &quot;parentUUID&quot;: &quot;d9f00da6-095f-4d67-8e26-267e2cc18562&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.updateGuest(&#x27;mou&#x27;,&#x27;Zero12&#x27;).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9e60621b-df5c-46d3-91d4-48edb170f56e&quot;,
      &quot;parentUUID&quot;: &quot;d9f00da6-095f-4d67-8e26-267e2cc18562&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui si provi ad aggiungere l&#x27;id di una conversazione già presente, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d3816f27-c751-4b9e-bd5d-7513dd19edcc&quot;,
      &quot;parentUUID&quot;: &quot;a5895612-deec-406e-86ae-7bbfd2179a2e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addConversation Nel caso in cui venga aggiunto correttamente l&#x27;id di una conversazione, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;Observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;guests.addConversation(&#x27;Mauro&#x27;, &#x27;Zero12&#x27;, 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8d1b7052-8b4c-4c49-b68b-a2c3ce17174a&quot;,
      &quot;parentUUID&quot;: &quot;a5895612-deec-406e-86ae-7bbfd2179a2e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;addMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.addMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9124e0dc-9a80-4804-ade8-1715f0aa7f91&quot;,
      &quot;parentUUID&quot;: &quot;b288877f-c889-45c7-9c3b-df02e109c51c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
      &quot;fullTitle&quot;: &quot;getMember Nel caso in cui il metodo ottenga il membro dell&#x27;azienda allora l&#x27;Observable invia tale Member all&#x27;Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t&#x27;ok&#x27;: true,\n\t&#x27;user&#x27;:\n\t{\n\t\t&#x27;id&#x27;: &#x27;U023BECGF&#x27;,\n\t\t&#x27;name&#x27;: &#x27;bobby&#x27;,\n\t\t&#x27;deleted&#x27;: false,\n\t\t&#x27;color&#x27;: &#x27;9f69e7&#x27;,\n\t\t&#x27;profile&#x27;:\n\t\t{\n\t\t\t&#x27;avatar_hash&#x27;: &#x27;ge3b51ca72de&#x27;,\n\t\t\t&#x27;current_status&#x27;: &#x27;:mountain_railway: riding a train&#x27;,\n\t\t\t&#x27;first_name&#x27;: &#x27;Bobby&#x27;,\n\t\t\t&#x27;last_name&#x27;: &#x27;Tables&#x27;,\n\t\t\t&#x27;real_name&#x27;: &#x27;Bobby Tables&#x27;,\n\t\t\t&#x27;email&#x27;: &#x27;bobby@slack.com&#x27;,\n\t\t\t&#x27;skype&#x27;: &#x27;my-skype-name&#x27;,\n\t\t\t&#x27;phone&#x27;: &#x27;+1 (123) 456 7890&#x27;\n\t\t},\n\t\t&#x27;is_admin&#x27;: true,\n\t\t&#x27;is_owner&#x27;: true,\n\t\t&#x27;updated&#x27;: 1490054400,\n\t\t&#x27;has_2fa&#x27;: true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e638043b-92ea-4de7-bece-8a1b5392234a&quot;,
      &quot;parentUUID&quot;: &quot;850684c7-c07a-439c-af8d-2009e90abe3f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getMember Se si verifica un errore nell&#x27;ottenere il membro dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;44eb039c-9826-4af6-a33f-9acba7143eca&quot;,
      &quot;parentUUID&quot;: &quot;850684c7-c07a-439c-af8d-2009e90abe3f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
      &quot;fullTitle&quot;: &quot;getMemberList L&#x27;Observable deve notificare l&#x27;Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\&quot;ok\&quot;: true,\n\t\&quot;members\&quot;:\n\t[\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECGF\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;mauro\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Mauro Bocciofilo\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t},\n\t\t{\n\t\t\t\&quot;id\&quot;: \&quot;U023BECLL\&quot;,\n\t\t\t\&quot;team_id\&quot;: \&quot;T021F9ZE2\&quot;,\n\t\t\t\&quot;name\&quot;: \&quot;bobby\&quot;,\n\t\t\t\&quot;deleted\&quot;: false,\n\t\t\t\&quot;status\&quot;: null,\n\t\t\t\&quot;color\&quot;: \&quot;9f69e7\&quot;,\n\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\&quot;tz\&quot;: \&quot;America\\/Los_Angeles\&quot;,\n\t\t\t\&quot;tz_label\&quot;: \&quot;Pacific Daylight Time\&quot;,\n\t\t\t\&quot;tz_offset\&quot;: -25200,\n\t\t\t\&quot;profile\&quot;:\n\t\t\t{\n\t\t\t\t\&quot;avatar_hash\&quot;: \&quot;ge3b51ca72de\&quot;,\n\t\t\t\t\&quot;current_status\&quot;: \&quot;:mountain_railway: riding a train\&quot;,\n\t\t\t\t\&quot;first_name\&quot;: \&quot;Bobby\&quot;,\n\t\t\t\t\&quot;last_name\&quot;: \&quot;Tables\&quot;,\n\t\t\t\t\&quot;real_name\&quot;: \&quot;Bobby Tables\&quot;,\n\t\t\t\t\&quot;email\&quot;: \&quot;bobby@slack.com\&quot;,\n\t\t\t\t\&quot;skype\&quot;: \&quot;my-skype-name\&quot;,\n\t\t\t\t\&quot;phone\&quot;: \&quot;+1 (123) 456 7890\&quot;,\n\t\t\t},\n\t\t\t\&quot;is_admin\&quot;: true,\n\t\t\t\&quot;is_owner\&quot;: true,\n\t\t\t\&quot;updated\&quot;: 1490054400,\n\t\t\t\&quot;has_2fa\&quot;: false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0d356164-ba47-4a63-ba02-141042f2198b&quot;,
      &quot;parentUUID&quot;: &quot;41aa1ca7-8ac2-423f-84c2-bd66a990cbce&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getMemberList Se si verifica un errore nell&#x27;ottenere la lista dei membri dell&#x27;azienda, l&#x27;Observable deve notificare l&#x27;Observer iscritto richiamando il metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t&#x27;ok&#x27;: false,\n\t&#x27;error&#x27;: &#x27;not_authed&#x27;\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal(&#x27;not_authed&#x27;);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2f4e768c-db0f-4671-8c61-e549cf1d4a9f&quot;,
      &quot;parentUUID&quot;: &quot;41aa1ca7-8ac2-423f-84c2-bd66a990cbce&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;removeMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.removeMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b977af02-994d-4ef2-869b-c8ba632b66bc&quot;,
      &quot;parentUUID&quot;: &quot;eb4eca28-7408-4537-b9ed-9fa99c4124d0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;updateMember Anche se viene passato un Member corretto, l&#x27;ErrorObservable ritornato deve notificare l&#x27;Observer richiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;members.updateMember(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;83627090-20af-45ef-a6f6-6ee4068f60f0&quot;,
      &quot;parentUUID&quot;: &quot;06e6b702-ebfd-49a7-827d-040496396199&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(&#x27;errore&#x27;);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n  done();\n}&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fe08a1c2-6614-4a6f-b0ce-e0c3740a1572&quot;,
      &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields(&#x27;errore&#x27;);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;950753c4-de38-4569-b415-4de68b12ba70&quot;,
      &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 10,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: &#x27;&#x27;};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(&#x27;errore&#x27;);\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property(&#x27;statusCode&#x27;, 500);\n            done();\n          }&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3745ba25-aac2-487b-9b7e-b7a1936169c2&quot;,
      &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
      &quot;fullTitle&quot;: &quot;getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: &#x27;&#x27;, queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property(&#x27;statusCode&#x27;, 200);\n  done();\n}&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;79c9a493-9ecd-4664-8296-095fd3448985&quot;,
      &quot;parentUUID&quot;: &quot;c33aa557-d181-4d2b-ac69-971d8c744cbf&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(&#x27;errore&#x27;);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c97cd393-9c5e-4a7d-b87c-df4b9ed2ec40&quot;,
      &quot;parentUUID&quot;: &quot;82121586-7ebf-4b8f-81ad-482f20e1f150&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b48e593e-60f4-4d74-bdc3-5116e68ed400&quot;,
      &quot;parentUUID&quot;: &quot;82121586-7ebf-4b8f-81ad-482f20e1f150&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\n\nexpect(context.succeed.callCount).to.equal(1);\t\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;dcf38ebe-517a-44db-a8eb-e406e807bc87&quot;,
      &quot;parentUUID&quot;: &quot;82121586-7ebf-4b8f-81ad-482f20e1f150&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare complete_cb&quot;,
      &quot;fullTitle&quot;: &quot;complete Deve chiamare complete_cb&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \&quot;il callback di complete non è stato chiamato esattamente una volta.\&quot;).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;266356f0-2c09-457e-9898-88d0353aec28&quot;,
      &quot;parentUUID&quot;: &quot;1f4096b9-07ac-4666-ad60-fe12faafafb9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;complete Non deve chiamare complete_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;541466b2-1e94-40f3-b81e-41c33f564c8e&quot;,
      &quot;parentUUID&quot;: &quot;1f4096b9-07ac-4666-ad60-fe12faafafb9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;complete Deve chiamare complete_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;87a4d294-1116-4de3-9e67-fe953327534f&quot;,
      &quot;parentUUID&quot;: &quot;1f4096b9-07ac-4666-ad60-fe12faafafb9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare error_cb&quot;,
      &quot;fullTitle&quot;: &quot;error Deve chiamare error_cb&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b867b36e-175a-4938-84a4-66e65009b5df&quot;,
      &quot;parentUUID&quot;: &quot;c18b6f7b-5fe0-4324-8600-39dc0fffd4a8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;error Non deve chiamare error_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onError(success);\nobs.pause();\nobs.error(&#x27;errore&#x27;);\n        expect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a0bb7ace-983c-4e07-b96a-5ed6f32b2fe4&quot;,
      &quot;parentUUID&quot;: &quot;c18b6f7b-5fe0-4324-8600-39dc0fffd4a8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;fullTitle&quot;: &quot;error Deve chiamare error_cb dopo che l&#x27;observer è stato ripreso se, mentre era in pausa, il metodo è stato chiamato.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let err = new Error(&#x27;Errore&#x27;);\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;486b05b9-6abe-470c-bf32-14527d9b8e92&quot;,
      &quot;parentUUID&quot;: &quot;c18b6f7b-5fe0-4324-8600-39dc0fffd4a8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l&#x27;observer non è in pausa.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal(&#x27;data&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bd61bd1b-348a-4518-989d-4dcbddb6b98a&quot;,
      &quot;parentUUID&quot;: &quot;64a152d5-e756-42c1-b3a8-1340d96b4c84&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
      &quot;fullTitle&quot;: &quot;next Non deve chiamare next_cb se l&#x27;observer è in pausa&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.pause();\nobs.next(&#x27;Function called&#x27;);\nexpect(success.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;99675446-3ae4-43d7-abd1-63593239fff9&quot;,
      &quot;parentUUID&quot;: &quot;64a152d5-e756-42c1-b3a8-1340d96b4c84&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
      &quot;fullTitle&quot;: &quot;next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l&#x27;observer ha ripreso.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;obs.onNext(success);\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next(&#x27;data&#x27;);\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next(&#x27;other data&#x27;);\nexpect(success.callCount).to.equal(2);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ad0c76c9-3bfd-455a-8f43-e795f029d3a8&quot;,
      &quot;parentUUID&quot;: &quot;64a152d5-e756-42c1-b3a8-1340d96b4c84&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;14c1f94c-b93c-443d-8b89-52918d25737a&quot;,
      &quot;parentUUID&quot;: &quot;99cd732f-b8d0-4311-8433-f5148d954952&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;060d651a-0fa5-4a3d-9e88-e39161145e57&quot;,
      &quot;parentUUID&quot;: &quot;99cd732f-b8d0-4311-8433-f5148d954952&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e9804184-ccfe-4d89-80a9-52cf4c80cf70&quot;,
      &quot;parentUUID&quot;: &quot;c5b11645-a8b4-4fe7-8cce-9c7558b860ee&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;845c63bf-6b9a-4b9c-9678-0573261f627f&quot;,
      &quot;parentUUID&quot;: &quot;c5b11645-a8b4-4fe7-8cce-9c7558b860ee&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8b7cfee7-7f7e-46b8-93e1-43dfbc0dc69c&quot;,
      &quot;parentUUID&quot;: &quot;52769ebd-e9fe-443a-ae9a-a12e138dcd6a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e0b6284f-36ea-4d9a-a716-d0d4ec002a6a&quot;,
      &quot;parentUUID&quot;: &quot;52769ebd-e9fe-443a-ae9a-a12e138dcd6a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;//da definire&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6e31b9e0-7848-440f-8ac0-753099b54589&quot;,
      &quot;parentUUID&quot;: &quot;52769ebd-e9fe-443a-ae9a-a12e138dcd6a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeRule Nel caso in cui una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3ab5c6ea-f59a-47f1-851a-bb7709431644&quot;,
      &quot;parentUUID&quot;: &quot;3f62f872-6f6d-4557-854c-d840decf9478&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeRule Nel caso in cui una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f2e98598-18b4-4563-8a02-f08ca8ba30f2&quot;,
      &quot;parentUUID&quot;: &quot;3f62f872-6f6d-4557-854c-d840decf9478&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;473392b8-4ed4-4ebd-b3c7-384d9fc3d1f4&quot;,
      &quot;parentUUID&quot;: &quot;f9d6a484-0f03-4ec5-8a24-20d2d342e481&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;68bc772f-e4a3-4d8f-9e6e-e4536bf2c9f8&quot;,
      &quot;parentUUID&quot;: &quot;f9d6a484-0f03-4ec5-8a24-20d2d342e481&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \&quot;\&quot;};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;70ee10f2-237b-4d02-8fc2-c8181e88206e&quot;,
      &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;578152e8-74c7-4b7e-b00a-5abedb90652c&quot;,
      &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d1bae73f-4f20-46e6-8d91-cd19b6c8bc1a&quot;,
      &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;fullTitle&quot;: &quot;addRule Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.addRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0860e059-fb75-40e5-ac35-9e8d5a37626e&quot;,
      &quot;parentUUID&quot;: &quot;881ffd57-ddbc-4116-b310-2651c1fea768&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9d7aea3e-cfe8-4fba-9401-0f2143380e25&quot;,
      &quot;parentUUID&quot;: &quot;b0cd57ab-1871-41ef-ad1d-0d8489d24631&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b07d46c0-8d9a-45df-931d-aaf2f933841a&quot;,
      &quot;parentUUID&quot;: &quot;b0cd57ab-1871-41ef-ad1d-0d8489d24631&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;fullTitle&quot;: &quot;deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);\n};&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0746403d-d22c-4101-9987-96babe62b01c&quot;,
      &quot;parentUUID&quot;: &quot;b0cd57ab-1871-41ef-ad1d-0d8489d24631&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f0ac06a3-9f31-4507-97c1-42a59601b383&quot;,
      &quot;parentUUID&quot;: &quot;c620c4b8-5395-40c5-b511-7007d5fd0082&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;544b0758-2f74-4af7-9e2a-e2131b4338d1&quot;,
      &quot;parentUUID&quot;: &quot;c620c4b8-5395-40c5-b511-7007d5fd0082&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;fullTitle&quot;: &quot;getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRule.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;db6e92ea-55cd-49cf-9548-c979bf895a54&quot;,
      &quot;parentUUID&quot;: &quot;c620c4b8-5395-40c5-b511-7007d5fd0082&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f39aaebc-0b28-4886-9390-9677ae8f2f4a&quot;,
      &quot;parentUUID&quot;: &quot;65381f65-d23d-45b4-9235-f22e3a7805bc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3adcdc7f-f49b-4882-915d-ac8057dac137&quot;,
      &quot;parentUUID&quot;: &quot;65381f65-d23d-45b4-9235-f22e3a7805bc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a05a14e2-b44f-409c-bde1-56d0daa1d44f&quot;,
      &quot;parentUUID&quot;: &quot;13b1946e-df90-4a81-994a-4cb0e9768415&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b0b55a35-1ac8-4cbd-a575-0e257b0dff3d&quot;,
      &quot;parentUUID&quot;: &quot;13b1946e-df90-4a81-994a-4cb0e9768415&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8218d9fa-d939-4d9a-adc0-c39f68c8e840&quot;,
      &quot;parentUUID&quot;: &quot;fa8c5f09-bf69-43ee-8461-e355fd4e2c26&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \&quot;\&quot; , body: \&quot;\&quot;};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8046d304-b28d-486c-b452-ba0a7f1f53a1&quot;,
      &quot;parentUUID&quot;: &quot;fa8c5f09-bf69-43ee-8461-e355fd4e2c26&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;fullTitle&quot;: &quot;updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ddccc301-f1ab-422a-bf55-616c435bfc0f&quot;,
      &quot;parentUUID&quot;: &quot;fa8c5f09-bf69-43ee-8461-e355fd4e2c26&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
      &quot;fullTitle&quot;: &quot;speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;eec7a506-bc63-4025-b230-072af4bb118e&quot;,
      &quot;parentUUID&quot;: &quot;722fee07-a362-4c85-8d65-48385fbd1ba8&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\&quot;Requested resource not found\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;2bc4be46-07a2-4ae9-bac3-0191cbb86bbe&quot;,
      &quot;parentUUID&quot;: &quot;bdeb3d10-d456-45b9-ab67-86ab4e775fe0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9f0d3a11-a694-46b8-b03d-664df360da8b&quot;,
      &quot;parentUUID&quot;: &quot;bdeb3d10-d456-45b9-ab67-86ab4e775fe0&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getTask Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTask(&#x27;mock_type&#x27;).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\&quot;error getting data\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8b74b208-52e4-496c-bbc6-cc338bd3ee8b&quot;,
      &quot;parentUUID&quot;: &quot;4eeffb5f-a5f8-4bd2-8afc-ed29c769c410&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getTask Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = tasks.getTask(&#x27;mock_type&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9dad8baf-0b66-41c4-955d-444f670aab07&quot;,
      &quot;parentUUID&quot;: &quot;4eeffb5f-a5f8-4bd2-8afc-ed29c769c410&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \&quot;mock_type3\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d6369442-d023-47d9-acf2-035b5a5f8a97&quot;,
      &quot;parentUUID&quot;: &quot;7497c08f-8957-4b86-bed8-53971d644988&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getTaskList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\&quot;mock_type2\&quot;});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3a6b58a5-faa5-4226-ab7f-8f1d917de358&quot;,
      &quot;parentUUID&quot;: &quot;7497c08f-8957-4b86-bed8-53971d644988&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\&quot;error removing rule\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0619ff56-7e97-40c0-86f2-9622a0e819e8&quot;,
      &quot;parentUUID&quot;: &quot;7081eace-4a18-4213-b1e5-56f03e766329&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.removeTask(&#x27;mock_type&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\&quot;success\&quot;});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0594ac80-9b39-4832-b0cc-723fd97989d3&quot;,
      &quot;parentUUID&quot;: &quot;7081eace-4a18-4213-b1e5-56f03e766329&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\&quot;error updating rule\&quot;});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5df90199-2eb3-4da5-90f2-2d3c456a4bf9&quot;,
      &quot;parentUUID&quot;: &quot;bc2ad69b-b590-4b79-ad37-418cc3bb43ca&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;tasks.updateTask(&#x27;mock_type&#x27;).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;90db800a-403e-4683-a606-cd6e1b574d2a&quot;,
      &quot;parentUUID&quot;: &quot;bc2ad69b-b590-4b79-ad37-418cc3bb43ca&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui l&#x27;utente non venga aggiunto a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\&quot;Requested resource not found\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;113eb5ba-ef75-4b55-8cfb-9452ea262de3&quot;,
      &quot;parentUUID&quot;: &quot;f2a56d12-aba8-4270-b126-3bdcf435cc38&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui l&#x27;utente sia aggiunto correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.addUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bbe398fc-ed90-40c2-aeb9-c2a052983167&quot;,
      &quot;parentUUID&quot;: &quot;f2a56d12-aba8-4270-b126-3bdcf435cc38&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\&quot;error getting data\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fde4a879-5c96-447b-b3d9-dd551c7c1e27&quot;,
      &quot;parentUUID&quot;: &quot;7b5bd02f-b262-4e1a-b1c0-9a171f2f422c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let observable = users.getUser(&#x27;mou&#x27;);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\n\t\t\t\t\texpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;251d9e86-935a-4c25-99c9-fbfff0c4807e&quot;,
      &quot;parentUUID&quot;: &quot;7b5bd02f-b262-4e1a-b1c0-9a171f2f422c&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui si verifichi un errore nell&#x27;interrogazione del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}], LastEvaluatedKey: &#x27;marco&#x27;});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;74969315-cf07-4f95-a638-72cfa1bd5923&quot;,
      &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui l&#x27;interrogazione del DB vada a buon fine, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;piero&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;piero\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;piero&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;530daf9f-500b-4611-bb19-52d516480625&quot;,
      &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4a20adbe-a87e-4be4-9a98-3c92dd94c74e&quot;,
      &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l&#x27;Observable restituito deve chiamare il metodo next dell&#x27;observer iscritto con i dati filtrati ottenuti dall&#x27;interrogazione, ed in seguito il metodo complete un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let query =\n{\n\tname: &#x27;mauro&#x27;,\n\tslack_channel: &#x27;channel&#x27;\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;mou\&quot;}], LastEvaluatedKey: &#x27;sun&#x27;});\ndynamo_client.scan.yield(null, {Items: [{name: \&quot;mauro\&quot;, username: \&quot;sun\&quot;}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property(&#x27;FilterExpression&#x27;, &#x27;full_name = :full_name and slack_channel = :slack_channel&#x27;);\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:full_name&#x27;, &#x27;mauro&#x27; );\nexpect(callScan.args[0]).to.have.deep.property(&#x27;ExpressionAttributeValues.:slack_channel&#x27;, &#x27;channel&#x27; );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;mou&#x27;);\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal(&#x27;mauro&#x27;);\nexpect(callNext.args[0].username).to.equal(&#x27;sun&#x27;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6a19b03c-f9aa-4541-a9b0-1e68a83b48d9&quot;,
      &quot;parentUUID&quot;: &quot;5c5691bd-a887-4e41-a175-74b3420f3749&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;removeUser Nel caso in cui l&#x27;utente non venga rimosso a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \&quot;error removing user\&quot;});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;302333dd-0b16-4fff-8d2d-7cafef9dea54&quot;,
      &quot;parentUUID&quot;: &quot;3758adcf-d96c-4cc0-98e6-324c57e2c0de&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
      &quot;fullTitle&quot;: &quot;removeUser Nel caso in cui l&#x27;utente sia rimosso correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.removeUser(&#x27;mou&#x27;).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bc1f1ffa-3a42-431b-be3d-d78afdcfbee4&quot;,
      &quot;parentUUID&quot;: &quot;3758adcf-d96c-4cc0-98e6-324c57e2c0de&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui l&#x27;utente non venga modificato a causa di un&#x27;errore del DB, l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;observer iscritto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \&quot;error updating user\&quot;});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a3b08d0f-670a-4580-ad85-52bc4dbe35be&quot;,
      &quot;parentUUID&quot;: &quot;0ddde174-da9d-475b-a4a1-0d679a90e42e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui l&#x27;utente sia modificato correttamente, l&#x27;Observable restituito deve chiamare il metodo complete dell&#x27;observer iscritto un&#x27;unica volta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users.updateUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c42b78b0-dcc3-4107-8080-1817b374ab9c&quot;,
      &quot;parentUUID&quot;: &quot;0ddde174-da9d-475b-a4a1-0d679a90e42e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6f07b354-0b1d-4c39-8b95-af82a5eb7e75&quot;,
      &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 8,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;32dbbe15-a247-446d-ba09-4c39dc293baa&quot;,
      &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \&quot;\&quot; };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c0152ad0-5909-4fed-8f84-95cb1951436a&quot;,
      &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;fullTitle&quot;: &quot;addUser Nel caso in cui sia passato un oggetto la cui chiave primaria è uguale a quella di un oggetto già esistente, il campo statusCode della risposta deve essere impostato a 409&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.addUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet user=\n{\n  name: \&quot;Mauro\&quot;,\n  username: \&quot;mou\&quot;\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Conflict&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 409);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;70286ef3-7e9a-447e-9e17-68bc3142ed62&quot;,
      &quot;parentUUID&quot;: &quot;7ac980aa-f64e-4f3d-8c2a-5b739b91f3b9&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;252eccac-4b9a-42f8-9af9-e6d699e93930&quot;,
      &quot;parentUUID&quot;: &quot;e285b6c0-ed97-4242-9633-b5b8c181d83e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: &#x27;mou&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6da076c0-3d30-4fac-94e4-4a146973c093&quot;,
      &quot;parentUUID&quot;: &quot;e285b6c0-ed97-4242-9633-b5b8c181d83e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.removeUser.returns(Rx.Observable.throw({ code: &#x27;ConditionalCheckFailedException&#x27; }));\nlet ev = { pathParameters: { username: &#x27;pippo&#x27; }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6b6fbf80-92bf-4031-a26a-639bd573e663&quot;,
      &quot;parentUUID&quot;: &quot;e285b6c0-ed97-4242-9633-b5b8c181d83e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;050e5250-1e63-4852-b306-8e24b640eee6&quot;,
      &quot;parentUUID&quot;: &quot;c10d8e7a-9e00-49b8-8523-3ac0d6b9d943&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l&#x27;utente richiesto&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\nlet ev = { pathParameters: { username: &#x27;mou&#x27;} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cab6a2d1-6fe2-48c7-a2d2-b5219594a56b&quot;,
      &quot;parentUUID&quot;: &quot;c10d8e7a-9e00-49b8-8523-3ac0d6b9d943&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;fullTitle&quot;: &quot;getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUser.returns(Rx.Observable.throw({ code: &#x27;Not found&#x27; }));\n          let ev = { pathParameters: { username: &#x27;pippo&#x27;} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Not found&#x27; }));\nexpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 404);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a45e9b7a-3177-4b9c-bacf-537c61bd8f6f&quot;,
      &quot;parentUUID&quot;: &quot;c10d8e7a-9e00-49b8-8523-3ac0d6b9d943&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b17e8659-c0cb-43a3-9afc-344abf554073&quot;,
      &quot;parentUUID&quot;: &quot;c840bd3e-98a5-4665-a53f-441881be5c6d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
      &quot;fullTitle&quot;: &quot;getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.getUserList.returns(Rx.Observable.of({ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ users: [{ name : &#x27;Mauro&#x27;, username : &#x27;mou&#x27; }, { name : &#x27;Nicola&#x27;, username : &#x27;tinto&#x27; }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;abe4d296-4e35-4248-9bad-9568d454116b&quot;,
      &quot;parentUUID&quot;: &quot;c840bd3e-98a5-4665-a53f-441881be5c6d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Internal server error&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 500);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5f53512a-dcf3-447c-a35e-49a6762de02e&quot;,
      &quot;parentUUID&quot;: &quot;948ecded-16a5-4b59-9853-f247b32964c1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \&quot;gianluca\&quot;\n};\nlet ev = { pathParameters: \&quot;mou\&quot;, body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;success&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 200);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;103ca95a-6251-4ce9-bf4e-bf8be825689f&quot;,
      &quot;parentUUID&quot;: &quot;948ecded-16a5-4b59-9853-f247b32964c1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;fullTitle&quot;: &quot;updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let ev = { pathParameters: \&quot;\&quot;, body: \&quot;\&quot; };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property(&#x27;body&#x27;, JSON.stringify({ message: &#x27;Bad Request&#x27; }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property(&#x27;statusCode&#x27;, 400);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a10364a7-6993-4073-95de-5896508de88a&quot;,
      &quot;parentUUID&quot;: &quot;948ecded-16a5-4b59-9853-f247b32964c1&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;216d7ba3-9505-4b6d-9810-ad8d0b5aae3c&quot;,
      &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;561ffda1-1532-41be-a2d6-8728834ace14&quot;,
      &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;msg&#x27;: &#x27;error getting guest&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d1ad3af6-0db1-411a-b972-82acd2989867&quot;,
      &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ &#x27;msg&#x27;: &#x27;error adding conversation&#x27; });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7340828e-233f-4665-961a-7fa663bd1b6f&quot;,
      &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
      &quot;fullTitle&quot;: &quot;onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;let context = { body: &#x27;&#x27; };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { &#x27;type&#x27;: &#x27;example&#x27; });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;6532740e-492d-4894-b1cc-b23b5ec5d50a&quot;,
      &quot;parentUUID&quot;: &quot;bf742699-ac3c-455b-a358-f35e233c9690&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
      &quot;fullTitle&quot;: &quot;query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith(&#x27;test&#x27;));\n\tlet result = context.succeed.getCall(0).args[0];\n            expect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n            done();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;74310b24-396f-472c-9045-f21ef6c302f8&quot;,
      &quot;parentUUID&quot;: &quot;9a9982d0-dc2b-41ea-a17d-b365069a6cd6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
      &quot;fullTitle&quot;: &quot;query Se la chiamata al modulo VAModule genera un&#x27;errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;agents.getAgent.returns(Rx.Observable.of(&#x27;aaa&#x27;));\n          va.query.returns(Promise.reject(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n            done();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bc6eacdb-d762-41c1-b76d-240b80da6346&quot;,
      &quot;parentUUID&quot;: &quot;9a9982d0-dc2b-41ea-a17d-b365069a6cd6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;08b416ef-6b47-4a45-b4c1-8af30b23e52d&quot;,
      &quot;parentUUID&quot;: &quot;96f2ecb5-a479-4e28-b76d-f8832d782a93&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;951465a6-0832-4329-8e8d-a08ba4aacdca&quot;,
      &quot;parentUUID&quot;: &quot;5108413b-e03f-4ba0-870b-cb2f776a81d2&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.addEnrollment.returns(Rx.Observable.throw(errore));\napi._addUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;585df43e-fe1c-4635-8bf3-2e1d05630718&quot;,
      &quot;parentUUID&quot;: &quot;5462f899-0bf8-46a1-95c0-d348272f334f&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8e4966b6-fde1-4679-819e-7f68890a238b&quot;,
      &quot;parentUUID&quot;: &quot;4bbb01bf-3cd5-4be1-b39e-639095dc6d9e&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e4eea84b-f84c-4f13-93c7-476de3e450f8&quot;,
      &quot;parentUUID&quot;: &quot;cbebbb49-802b-439b-81a9-ec44a9a4a6fc&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c1bf914b-21be-41bb-81f2-9bcad72a3721&quot;,
      &quot;parentUUID&quot;: &quot;06dbdeb3-20e3-4e34-83da-fee48d38f31a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;96e42e6e-4c57-44fc-8b87-c26947f83c80&quot;,
      &quot;parentUUID&quot;: &quot;56c3d595-e98c-4521-aa04-1b00884273c4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
      &quot;fullTitle&quot;: &quot;_loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.doLogin.returns(Rx.Observable.throw(errore));\napi._loginUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;93305c00-0b65-42f8-abca-cf39a453cd9d&quot;,
      &quot;parentUUID&quot;: &quot;323887bb-8fab-4dba-bb46-7110505e3e38&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          };\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;0fc744cf-8ab5-424d-9fab-d83371b0cd7e&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;d237b2ce-caed-4682-858d-3919ba1daf04&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;e31bef5b-f76b-42bd-8271-1c9627530134&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;47a5f0ad-04bf-4d39-8274-50cc94705b77&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;29ee8baa-e98c-4864-b1d5-5e9b0346c92d&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7db6716a-41b4-4159-91e8-53e12836d705&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;ba6cb505-baf3-4a21-9230-df1937a7c18b&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1a77c1aa-fc09-456b-8bc0-d34b437403f2&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1ab0085f-ae95-4015-8748-94a2fb749ebf&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Rules.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9aaf87f4-ff0a-451d-807f-08091d552ed6&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 1,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a5c7ce28-87c2-4fbb-b054-3dc49d69815a&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7f7d7be5-e89e-413f-b5bd-6205042269e2&quot;,
      &quot;parentUUID&quot;: &quot;34d39c6c-e17a-4d9a-9dd9-38719edb4e02&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._removeUser(&#x27;mou&#x27;).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;86b37758-cc9a-4cc2-96f4-437326a544b2&quot;,
      &quot;parentUUID&quot;: &quot;edd16b1b-2848-4163-bdfc-0a235e349b7d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\napi._getUser.returns(Rx.Observable.empty());\nvocalLogin.resetEnrollments.returns(Rx.Observable.throw(errore));\napi._resetUserEnrollment(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cbd9dbdc-ff08-4aad-9650-d55d97b83a2b&quot;,
      &quot;parentUUID&quot;: &quot;a9a5997b-4223-4585-aebf-01aea7226654&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;84a272bb-289d-4852-90fc-b307fa4bb737&quot;,
      &quot;parentUUID&quot;: &quot;229d8160-1071-4801-aa4b-c69e07707ad4&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;fullTitle&quot;: &quot;_updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l&#x27;Observable ritornato deve chiamare il metodo error dell&#x27;Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 4,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property(&#x27;code&#x27;, 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;5f79f361-39a1-4fa0-bbfd-ba56794ad4e4&quot;,
      &quot;parentUUID&quot;: &quot;4d1b9bae-6abd-4d9d-a099-cfe45a9d0c84&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;098d06dd-e6a5-4174-b054-9f7afc2632b8&quot;,
      &quot;parentUUID&quot;: &quot;02e97a6d-902d-467d-8cf4-c5cb5670b1f6&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b74572cc-8fc7-4122-a7c4-9caa26698e11&quot;,
      &quot;parentUUID&quot;: &quot;54363c6b-f4bd-46af-82b6-67e3344d385a&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1ddc0c88-fe65-4185-9184-e24ce44efdc5&quot;,
      &quot;parentUUID&quot;: &quot;2e4c08c9-84fd-4a84-8f76-712ad059b5d5&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo &#x27;result&#x27; pari a &#x27;Reject&#x27;, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 2,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject({ \&quot;result\&quot; : \&quot;Reject\&quot; }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7847c4d7-5c7e-4a87-a3a9-852afc45be4b&quot;,
      &quot;parentUUID&quot;: &quot;14388c7a-a9ae-4b7a-973b-19bd0860b778&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8e67fe00-6bd6-4e0d-91f8-4f51dc071e58&quot;,
      &quot;parentUUID&quot;: &quot;b62abe05-31fc-4de5-9965-1399e31338cb&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l&#x27;SRUserObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n  {\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f5e91688-96ff-47cd-97e0-91224b516fbf&quot;,
      &quot;parentUUID&quot;: &quot;e48e9887-0ed5-4eda-807d-e544783d35db&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;fullTitle&quot;: &quot;resetEnrollments Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l&#x27;ErrorObservable deve notificare l&#x27;ErrorObserver chiamando il suo metodo error.&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 3,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;promise.returns(Promise.reject(\n{\n  \&quot;error\&quot; :\n  {\n    \&quot;code\&quot; : \&quot;InternalServerError\&quot;,\n    \&quot;message\&quot; : \&quot;SpeakerInvalid\&quot;\n  }\n}));\nmicrosoft_login.resetEnrollments().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;47c9ba79-3d61-40e4-8aeb-31e6549fcfe1&quot;,
      &quot;parentUUID&quot;: &quot;bcfbb69a-a9f2-47d2-b07e-da7f7a38a158&quot;,
      &quot;skipped&quot;: false
    }
  ],
  &quot;allFailures&quot;: [
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.add&#x27; allora il metodo deve chiamare il metodo privato _addRule.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2001,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b0d1973c-8999-4483-a0ee-6ff2bce0258b&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.add&#x27; allora il metodo deve chiamare il metodo privato _addUser.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2001,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUser));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8f56444d-4ea6-480e-85ef-cb69c4e06f5a&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.addEnrollment&#x27; allora il metodo deve chiamare il metodo privato _addUserEnrollment.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2001,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._addUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_addUserEnrollment));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a62bb99e-109c-4536-8b68-6fba13237117&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.get&#x27; allora il metodo deve chiamare il metodo privato _getRule.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\n          promise.onCall(0).returns(Promise.resolve(va_response_getRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._getRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;61cff039-8c19-48fc-b2fc-be9822a85d87&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.getList&#x27; allora il metodo deve chiamare il metodo privato _getRuleList.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getRuleList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getRuleList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getRuleList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getRuleList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;374e4b65-e451-4ee1-9028-36401ced83e8&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.get&#x27; allora il metodo deve chiamare il metodo privato _getUser.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1871f858-9fff-4e83-ada6-123034b6cf27&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.getList&#x27; allora il metodo deve chiamare il metodo privato _getUserList.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._getUserList = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_getUserList));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._getUserList.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._getUserList.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1f96f57a-8d36-4f11-b9e4-3deee894c7fa&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.login&#x27; allora il metodo deve chiamare il metodo privato _loginUser.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;4c2ec230-fa9a-4e7b-889d-0f2d35885f13&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.remove&#x27; allora il metodo deve chiamare il metodo privato _removeRule.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2001,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b99d79ad-42e9-4d94-85cf-e4c023140f60&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.remove&#x27; allora il metodo deve chiamare il metodo privato _removeUser.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._removeUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_removeUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._removeUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._removeUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;abecccbc-1e66-4027-b832-8fc0e2428c23&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.resetEnrollment&#x27; allora il metodo deve chiamare il metodo privato _resetUserEnrollment.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1dac11d0-473d-4833-8390-8ff0968e0e34&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;rule.update&#x27; allora il metodo deve chiamare il metodo privato _updateRule.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateRule));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;99b05fb2-3e32-418e-80cf-24133ea2fbc1&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se l&#x27;action del body della risposta è uguale a &#x27;user.update&#x27; allora il metodo deve chiamare il metodo privato _updateUser.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._updateUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c9036fa3-3497-467c-b60c-977926b5b84e&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._loginUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_loginUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._loginUser.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n\texpect(api._loginUser.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;7d6dc886-bca5-4706-92e6-7845e2534ec5&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode è impostato ad un valore uguale a quello restituito dal microservizio Users.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2001,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._resetUserEnrollment = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_userResetEnrollment));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._resetUserEnrollment.returns(Rx.Observable.throw(errore_microservizio));\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._resetUserEnrollment.callCount).to.equal(1);\n\texpect(response).to.have.property(&#x27;statusCode&#x27;, errore_microservizio.code);\n\texpect(response).to.have.property(&#x27;body&#x27;, JSON.stringify({ message: errore_microservizio.msg }));\n            done();\n          }\n          api.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;68c4fb53-8fe5-4d3b-bf80-46d585b28be7&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
      &quot;fullTitle&quot;: &quot;queryLambda Se lo status code della risposta di un microservizio è pari a 200 e l&#x27;action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.&quot;,
      &quot;timedOut&quot;: true,
      &quot;duration&quot;: 2000,
      &quot;state&quot;: &quot;failed&quot;,
      &quot;pass&quot;: false,
      &quot;fail&quot;: true,
      &quot;pending&quot;: false,
      &quot;code&quot;: &quot;api._updateUser = sinon.stub();\nstt.speechToText.returns(Promise.resolve(&#x27;Test&#x27;));\npromise.onCall(0).returns(Promise.resolve(va_response_updateUser));\npromise.onCall(1).returns(Promise.resolve(empty_action_response));\napi._updateUser.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n\texpect(response).have.property(&#x27;statusCode&#x27;, 200);\n\tdone();\n};\napi.queryLambda(event, context);&quot;,
      &quot;err&quot;: {
        &quot;estack&quot;: &quot;Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves.\n&quot;
      },
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;bfab2fc5-0c9b-4737-baa7-aa56ce75d65d&quot;,
      &quot;parentUUID&quot;: &quot;f8db76ee-d235-45df-b9f1-1890eb39092d&quot;,
      &quot;skipped&quot;: false
    }
  ],
  &quot;copyrightYear&quot;: 2017
}" data-config="{&quot;reportDir&quot;:&quot;mochawesome-report&quot;,&quot;reportTitle&quot;:&quot;AtAVi&quot;,&quot;reportPageTitle&quot;:&quot;Mochawesome Report&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;charts&quot;:true,&quot;enableCharts&quot;:true,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;dev&quot;:false,&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;saveJson&quot;:true,&quot;jsonFile&quot;:&quot;H:\\src\\git\\AtAVi\\mochawesome-report\\mochawesome.json&quot;,&quot;htmlFile&quot;:&quot;H:\\src\\git\\AtAVi\\mochawesome-report\\mochawesome.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>