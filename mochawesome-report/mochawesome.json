{
  "stats": {
    "suites": 136,
    "tests": 185,
    "passes": 178,
    "pending": 3,
    "failures": 4,
    "start": "2017-05-06T02:11:49.781Z",
    "end": "2017-05-06T02:11:54.493Z",
    "duration": 4712,
    "testsRegistered": 185,
    "passPercent": 97.8,
    "pendingPercent": 1.6,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false,
    "passPercentClass": "success",
    "pendingPercentClass": "danger"
  },
  "suites": {
    "title": "",
    "suites": [
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "AdministrationWebhookService",
            "suites": [
              {
                "title": "webhook",
                "suites": [],
                "tests": [
                  {
                    "title": "La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.",
                    "fullTitle": "AdministrationWebhookService webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.",
                    "timedOut": false,
                    "duration": 1,
                    "state": "failed",
                    "pass": false,
                    "fail": true,
                    "pending": false,
                    "code": "jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});",
                    "err": {
                      "estack": "TypeError: service.webhook is not a function\n  at Context.<anonymous> (src\\test\\test_AdministrationWebhookService.js:72:17)\n"
                    },
                    "isRoot": false,
                    "uuid": "f58b050b-acad-45a7-810c-408e8eb9b8f7",
                    "parentUUID": "49cbbc3d-5775-435f-943e-eb1fc7b9224c",
                    "skipped": false
                  },
                  {
                    "title": "La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.",
                    "fullTitle": "AdministrationWebhookService webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.",
                    "timedOut": false,
                    "duration": 1,
                    "state": "failed",
                    "pass": false,
                    "fail": true,
                    "pending": false,
                    "code": "jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});",
                    "err": {
                      "estack": "TypeError: service.webhook is not a function\n  at Context.<anonymous> (src\\test\\test_AdministrationWebhookService.js:78:17)\n"
                    },
                    "isRoot": false,
                    "uuid": "aeb5ec22-81aa-4ffd-9170-3799ac0938cb",
                    "parentUUID": "49cbbc3d-5775-435f-943e-eb1fc7b9224c",
                    "skipped": false
                  }
                ],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_AdministrationWebhookService.js",
                "uuid": "49cbbc3d-5775-435f-943e-eb1fc7b9224c",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_AdministrationWebhookService.js",
                "passes": [],
                "failures": [
                  {
                    "title": "La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.",
                    "fullTitle": "AdministrationWebhookService webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.",
                    "timedOut": false,
                    "duration": 1,
                    "state": "failed",
                    "pass": false,
                    "fail": true,
                    "pending": false,
                    "code": "jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});",
                    "err": {
                      "estack": "TypeError: service.webhook is not a function\n  at Context.<anonymous> (src\\test\\test_AdministrationWebhookService.js:72:17)\n"
                    },
                    "isRoot": false,
                    "uuid": "f58b050b-acad-45a7-810c-408e8eb9b8f7",
                    "parentUUID": "49cbbc3d-5775-435f-943e-eb1fc7b9224c",
                    "skipped": false
                  },
                  {
                    "title": "La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.",
                    "fullTitle": "AdministrationWebhookService webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.",
                    "timedOut": false,
                    "duration": 1,
                    "state": "failed",
                    "pass": false,
                    "fail": true,
                    "pending": false,
                    "code": "jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});",
                    "err": {
                      "estack": "TypeError: service.webhook is not a function\n  at Context.<anonymous> (src\\test\\test_AdministrationWebhookService.js:78:17)\n"
                    },
                    "isRoot": false,
                    "uuid": "aeb5ec22-81aa-4ffd-9170-3799ac0938cb",
                    "parentUUID": "49cbbc3d-5775-435f-943e-eb1fc7b9224c",
                    "skipped": false
                  }
                ],
                "skipped": [],
                "hasTests": true,
                "hasSuites": false,
                "totalTests": 2,
                "totalPasses": 0,
                "totalFailures": 2,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": true,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 2,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_AdministrationWebhookService.js",
            "uuid": "a7de3c54-7d65-4772-b788-a29de868a0c0",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_AdministrationWebhookService.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_AdministrationWebhookService.js",
        "uuid": "b61853e6-9820-45ab-8929-f27771ae0bf6",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_AdministrationWebhookService.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "Agents",
            "suites": [
              {
                "title": "AgentsDAODynamoDB",
                "suites": [
                  {
                    "title": "addAgent",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui un agente di api.ai non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 3,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\"Requested resource not found\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "26893fa7-e651-42e7-92f1-173f4472299f",
                        "parentUUID": "4fadae18-f59d-4696-9466-88a623668476",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui un agente di api.ai sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b11d5fe2-9618-48a1-ac3c-d1de960468a8",
                        "parentUUID": "4fadae18-f59d-4696-9466-88a623668476",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_AgentsDAODynamoDB.js",
                    "uuid": "4fadae18-f59d-4696-9466-88a623668476",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui un agente di api.ai non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 3,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\"Requested resource not found\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "26893fa7-e651-42e7-92f1-173f4472299f",
                        "parentUUID": "4fadae18-f59d-4696-9466-88a623668476",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui un agente di api.ai sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "AgentsDAODynamoDB addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b11d5fe2-9618-48a1-ac3c-d1de960468a8",
                        "parentUUID": "4fadae18-f59d-4696-9466-88a623668476",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 4,
                    "rootEmpty": false
                  },
                  {
                    "title": "getAgent",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "AgentsDAODynamoDB getAgent Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.getAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\"error getting data\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "856587bf-b8e7-4410-b05a-83c006314f6b",
                        "parentUUID": "daf9c8b0-1de6-402d-b18c-33d6de82bff2",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "AgentsDAODynamoDB getAgent Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let observable = agents.getAgent('mock_name');\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "0deff0df-a3f9-4cc6-93c8-f36b7338c239",
                        "parentUUID": "daf9c8b0-1de6-402d-b18c-33d6de82bff2",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_AgentsDAODynamoDB.js",
                    "uuid": "daf9c8b0-1de6-402d-b18c-33d6de82bff2",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "AgentsDAODynamoDB getAgent Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.getAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\"error getting data\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "856587bf-b8e7-4410-b05a-83c006314f6b",
                        "parentUUID": "daf9c8b0-1de6-402d-b18c-33d6de82bff2",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "AgentsDAODynamoDB getAgent Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let observable = agents.getAgent('mock_name');\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "0deff0df-a3f9-4cc6-93c8-f36b7338c239",
                        "parentUUID": "daf9c8b0-1de6-402d-b18c-33d6de82bff2",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "getAgentList",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui un blocco di agenti non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "AgentsDAODynamoDB getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: '1'});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: '2'});\ndynamo_client.scan.yield({statusCode:500, msg:\"error getting data\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "9d868356-eaf9-48b4-bc4c-88c7dc0c9e6b",
                        "parentUUID": "a54c675d-d666-4ec5-a70f-d3516c0421af",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "AgentsDAODynamoDB getAgentList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: '1'});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "65aa7f88-a829-4ca3-8cc0-dae56dbeba01",
                        "parentUUID": "a54c675d-d666-4ec5-a70f-d3516c0421af",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_AgentsDAODynamoDB.js",
                    "uuid": "a54c675d-d666-4ec5-a70f-d3516c0421af",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui un blocco di agenti non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "AgentsDAODynamoDB getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: '1'});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: '2'});\ndynamo_client.scan.yield({statusCode:500, msg:\"error getting data\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "9d868356-eaf9-48b4-bc4c-88c7dc0c9e6b",
                        "parentUUID": "a54c675d-d666-4ec5-a70f-d3516c0421af",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "AgentsDAODynamoDB getAgentList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: '1'});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "65aa7f88-a829-4ca3-8cc0-dae56dbeba01",
                        "parentUUID": "a54c675d-d666-4ec5-a70f-d3516c0421af",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 4,
                    "rootEmpty": false
                  },
                  {
                    "title": "removeAgent",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui un agente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "AgentsDAODynamoDB removeAgent Nel caso in cui un agente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.removeAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\"error removing rule\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "1fc29d68-afe7-4b8f-827b-0b323e0c5d21",
                        "parentUUID": "6b8bbdc1-e9e9-4838-b66e-beb284a0abcc",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui un agente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "AgentsDAODynamoDB removeAgent Nel caso in cui un agente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.removeAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\"success\"});\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "04b81d03-22dd-487d-8f98-efce46540105",
                        "parentUUID": "6b8bbdc1-e9e9-4838-b66e-beb284a0abcc",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_AgentsDAODynamoDB.js",
                    "uuid": "6b8bbdc1-e9e9-4838-b66e-beb284a0abcc",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui un agente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "AgentsDAODynamoDB removeAgent Nel caso in cui un agente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.removeAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\"error removing rule\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "1fc29d68-afe7-4b8f-827b-0b323e0c5d21",
                        "parentUUID": "6b8bbdc1-e9e9-4838-b66e-beb284a0abcc",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui un agente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "AgentsDAODynamoDB removeAgent Nel caso in cui un agente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.removeAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\"success\"});\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "04b81d03-22dd-487d-8f98-efce46540105",
                        "parentUUID": "6b8bbdc1-e9e9-4838-b66e-beb284a0abcc",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "updateAgent",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui un agente non venga aggiornato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "AgentsDAODynamoDB updateAgent Nel caso in cui un agente non venga aggiornato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 5,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.updateAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\"error updating rule\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "dc87add1-fdf1-4105-904b-47fdea8ed1ad",
                        "parentUUID": "a0505902-4fbc-4a5e-9c0c-069857597be8",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui un agente sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "AgentsDAODynamoDB updateAgent Nel caso in cui un agente sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.updateAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "1d95d735-3753-4663-873a-33c773cc1f8d",
                        "parentUUID": "a0505902-4fbc-4a5e-9c0c-069857597be8",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_AgentsDAODynamoDB.js",
                    "uuid": "a0505902-4fbc-4a5e-9c0c-069857597be8",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui un agente non venga aggiornato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "AgentsDAODynamoDB updateAgent Nel caso in cui un agente non venga aggiornato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 5,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.updateAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\"error updating rule\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "dc87add1-fdf1-4105-904b-47fdea8ed1ad",
                        "parentUUID": "a0505902-4fbc-4a5e-9c0c-069857597be8",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui un agente sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "AgentsDAODynamoDB updateAgent Nel caso in cui un agente sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.updateAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "1d95d735-3753-4663-873a-33c773cc1f8d",
                        "parentUUID": "a0505902-4fbc-4a5e-9c0c-069857597be8",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 7,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_AgentsDAODynamoDB.js",
                "uuid": "3f168a0b-8d3c-458c-a8b4-1b5e49ac0426",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_AgentsDAODynamoDB.js",
            "uuid": "7cc31d32-c798-4dd2-9d34-bb5978a91295",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_AgentsDAODynamoDB.js",
        "uuid": "b43d857c-cd0e-4c79-8354-17a4a6e7adc9",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_AgentsDAODynamoDB.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "VirtualAssistant",
            "suites": [
              {
                "title": "ApiAiVAAdapter",
                "suites": [
                  {
                    "title": "query",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell'assistente virtuale",
                        "fullTitle": "ApiAiVAAdapter query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell'assistente virtuale",
                        "timedOut": false,
                        "duration": 3,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "6b34d0de-0aab-4944-a581-7b6f18c3debd",
                        "parentUUID": "0b68480d-7356-4390-9948-55a582959fa7",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta",
                        "fullTitle": "ApiAiVAAdapter query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e5143ea9-b3c4-4887-b44c-8a3bc38714f5",
                        "parentUUID": "0b68480d-7356-4390-9948-55a582959fa7",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_ApiAiVAAdapter.js",
                    "uuid": "0b68480d-7356-4390-9948-55a582959fa7",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell'assistente virtuale",
                        "fullTitle": "ApiAiVAAdapter query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell'assistente virtuale",
                        "timedOut": false,
                        "duration": 3,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "6b34d0de-0aab-4944-a581-7b6f18c3debd",
                        "parentUUID": "0b68480d-7356-4390-9948-55a582959fa7",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta",
                        "fullTitle": "ApiAiVAAdapter query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e5143ea9-b3c4-4887-b44c-8a3bc38714f5",
                        "parentUUID": "0b68480d-7356-4390-9948-55a582959fa7",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 5,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_ApiAiVAAdapter.js",
                "uuid": "37288eec-7317-4e2b-92c1-c542ab14d6ba",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_ApiAiVAAdapter.js",
            "uuid": "bb379d2f-5f0e-4175-a33a-de4c7533bd8d",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_ApiAiVAAdapter.js",
        "uuid": "c9ac6431-ee8f-4c35-8866-c6a8e6766138",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ApiAiVAAdapter.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "Conversations",
            "suites": [
              {
                "title": "ConversationsDAODynamoDB",
                "suites": [
                  {
                    "title": "addConversation",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \"Requested resource not found\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "f31c3da8-32ae-468c-9332-f60891c0c84a",
                        "parentUUID": "e4157c33-a462-4114-b13f-076e7a145fbc",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui una conversazione sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell' Observer iscritto un'unica volta.",
                        "fullTitle": "ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell' Observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a94ebceb-2e3d-4a39-a1db-71b22479cea6",
                        "parentUUID": "e4157c33-a462-4114-b13f-076e7a145fbc",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_ConversationsDAODynamoDB.js",
                    "uuid": "e4157c33-a462-4114-b13f-076e7a145fbc",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \"Requested resource not found\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "f31c3da8-32ae-468c-9332-f60891c0c84a",
                        "parentUUID": "e4157c33-a462-4114-b13f-076e7a145fbc",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui una conversazione sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell' Observer iscritto un'unica volta.",
                        "fullTitle": "ConversationsDAODynamoDB addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell' Observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a94ebceb-2e3d-4a39-a1db-71b22479cea6",
                        "parentUUID": "e4157c33-a462-4114-b13f-076e7a145fbc",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "addMessage",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.addMessage({sender:'mock_sender',text: 'mock_text', timestamp: '2000-10-10'},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \"error adding message\" });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "4fb15a05-eec8-4faa-9581-e6ad1ad68f1b",
                        "parentUUID": "47cc6cad-3104-486a-acbb-5dd29ade298c",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "fullTitle": "ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.addMessage({sender:'mock_sender',text: 'mock_text', timestamp: '2000-10-10'},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "45b408c3-af72-43eb-85b2-a04352e35534",
                        "parentUUID": "47cc6cad-3104-486a-acbb-5dd29ade298c",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_ConversationsDAODynamoDB.js",
                    "uuid": "47cc6cad-3104-486a-acbb-5dd29ade298c",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.addMessage({sender:'mock_sender',text: 'mock_text', timestamp: '2000-10-10'},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \"error adding message\" });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "4fb15a05-eec8-4faa-9581-e6ad1ad68f1b",
                        "parentUUID": "47cc6cad-3104-486a-acbb-5dd29ade298c",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "fullTitle": "ConversationsDAODynamoDB addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.addMessage({sender:'mock_sender',text: 'mock_text', timestamp: '2000-10-10'},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "45b408c3-af72-43eb-85b2-a04352e35534",
                        "parentUUID": "47cc6cad-3104-486a-acbb-5dd29ade298c",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "getConversation",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "ConversationsDAODynamoDB getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \"error downloading conversation\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "d64e5096-b768-4109-8f0b-55268a1aab9e",
                        "parentUUID": "d4754cff-a4d4-4fae-85f9-670b5909d980",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "fullTitle": "ConversationsDAODynamoDB getConversation Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "59195ec3-8a3f-41df-a427-f314b34eebf9",
                        "parentUUID": "d4754cff-a4d4-4fae-85f9-670b5909d980",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_ConversationsDAODynamoDB.js",
                    "uuid": "d4754cff-a4d4-4fae-85f9-670b5909d980",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "ConversationsDAODynamoDB getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \"error downloading conversation\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "d64e5096-b768-4109-8f0b-55268a1aab9e",
                        "parentUUID": "d4754cff-a4d4-4fae-85f9-670b5909d980",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "fullTitle": "ConversationsDAODynamoDB getConversation Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "59195ec3-8a3f-41df-a427-f314b34eebf9",
                        "parentUUID": "d4754cff-a4d4-4fae-85f9-670b5909d980",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "getConversationList",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui un blocco di conversazioni non venga restituito a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "ConversationsDAODynamoDB getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "7c39be02-44b1-4b5a-a683-ef0cd1396cf4",
                        "parentUUID": "e430a129-ab3c-476d-9af1-d96840e155e8",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "fullTitle": "ConversationsDAODynamoDB getConversationList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b0714c38-aaf1-49eb-9638-08393df3a4a5",
                        "parentUUID": "e430a129-ab3c-476d-9af1-d96840e155e8",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_ConversationsDAODynamoDB.js",
                    "uuid": "e430a129-ab3c-476d-9af1-d96840e155e8",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui un blocco di conversazioni non venga restituito a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "ConversationsDAODynamoDB getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "7c39be02-44b1-4b5a-a683-ef0cd1396cf4",
                        "parentUUID": "e430a129-ab3c-476d-9af1-d96840e155e8",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "fullTitle": "ConversationsDAODynamoDB getConversationList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b0714c38-aaf1-49eb-9638-08393df3a4a5",
                        "parentUUID": "e430a129-ab3c-476d-9af1-d96840e155e8",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  },
                  {
                    "title": "removeConversation",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \"error removing conversation\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "7d38a74b-deb5-4ad3-95ab-46e7b1a6ae9e",
                        "parentUUID": "b9275f54-5a82-49df-b283-cce9d5a9beb3",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui una conversazione sia eliminata correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "fullTitle": "ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \"success\" });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b4e04b39-2d53-4374-824d-77b9d236e686",
                        "parentUUID": "b9275f54-5a82-49df-b283-cce9d5a9beb3",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_ConversationsDAODynamoDB.js",
                    "uuid": "b9275f54-5a82-49df-b283-cce9d5a9beb3",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \"error removing conversation\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "7d38a74b-deb5-4ad3-95ab-46e7b1a6ae9e",
                        "parentUUID": "b9275f54-5a82-49df-b283-cce9d5a9beb3",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui una conversazione sia eliminata correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "fullTitle": "ConversationsDAODynamoDB removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \"success\" });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b4e04b39-2d53-4374-824d-77b9d236e686",
                        "parentUUID": "b9275f54-5a82-49df-b283-cce9d5a9beb3",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_ConversationsDAODynamoDB.js",
                "uuid": "609ea683-bc3f-46f1-a4bc-bc707d08087f",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_ConversationsDAODynamoDB.js",
            "uuid": "e3a8a38e-45c0-4205-90fa-471b537bf9a1",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_ConversationsDAODynamoDB.js",
        "uuid": "2ee0d461-1375-4c0c-9730-4d2ac8e84745",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ConversationsDAODynamoDB.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "ConversationWebhookService",
            "suites": [
              {
                "title": "webhook",
                "suites": [],
                "tests": [
                  {
                    "title": "La risposta deve avere il campo name del context uguale a 'admin' nel caso in cui l'utente sia stato riconosciuto come possibile amministratore.",
                    "fullTitle": "ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a 'admin' nel caso in cui l'utente sia stato riconosciuto come possibile amministratore.",
                    "timedOut": false,
                    "duration": 3,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "body.result.action = 'user.check';\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \"Mauro Carlin\", username : \"mou\"}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property('name', 'admin');",
                    "err": {},
                    "isRoot": false,
                    "uuid": "3c54a623-22f5-4647-be31-47d4c602ea32",
                    "parentUUID": "c8d8e18b-9394-4c7a-96c5-12f32dfea16a",
                    "skipped": false
                  },
                  {
                    "title": "La risposta deve avere il campo name del context uguale a 'welcome' nel caso in cui l'utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.",
                    "fullTitle": "ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a 'welcome' nel caso in cui l'utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.",
                    "timedOut": false,
                    "duration": 2,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "body.result.action = 'guest.check';\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \"Mauro Carlin\", username : \"mou\", company : \"Google\"}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property('name', 'welcome');",
                    "err": {},
                    "isRoot": false,
                    "uuid": "ad6f86ce-baef-48da-905c-9435a09d3ccc",
                    "parentUUID": "c8d8e18b-9394-4c7a-96c5-12f32dfea16a",
                    "skipped": false
                  }
                ],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_ConversationWebhookService.js",
                "uuid": "c8d8e18b-9394-4c7a-96c5-12f32dfea16a",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ConversationWebhookService.js",
                "passes": [
                  {
                    "title": "La risposta deve avere il campo name del context uguale a 'admin' nel caso in cui l'utente sia stato riconosciuto come possibile amministratore.",
                    "fullTitle": "ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a 'admin' nel caso in cui l'utente sia stato riconosciuto come possibile amministratore.",
                    "timedOut": false,
                    "duration": 3,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "body.result.action = 'user.check';\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \"Mauro Carlin\", username : \"mou\"}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property('name', 'admin');",
                    "err": {},
                    "isRoot": false,
                    "uuid": "3c54a623-22f5-4647-be31-47d4c602ea32",
                    "parentUUID": "c8d8e18b-9394-4c7a-96c5-12f32dfea16a",
                    "skipped": false
                  },
                  {
                    "title": "La risposta deve avere il campo name del context uguale a 'welcome' nel caso in cui l'utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.",
                    "fullTitle": "ConversationWebhookService webhook La risposta deve avere il campo name del context uguale a 'welcome' nel caso in cui l'utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.",
                    "timedOut": false,
                    "duration": 2,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "body.result.action = 'guest.check';\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \"Mauro Carlin\", username : \"mou\", company : \"Google\"}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property('name', 'welcome');",
                    "err": {},
                    "isRoot": false,
                    "uuid": "ad6f86ce-baef-48da-905c-9435a09d3ccc",
                    "parentUUID": "c8d8e18b-9394-4c7a-96c5-12f32dfea16a",
                    "skipped": false
                  }
                ],
                "failures": [],
                "skipped": [],
                "hasTests": true,
                "hasSuites": false,
                "totalTests": 2,
                "totalPasses": 2,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": true,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 5,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_ConversationWebhookService.js",
            "uuid": "23d3c4c2-4f5e-4eb9-b959-09f0e4689a6d",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ConversationWebhookService.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_ConversationWebhookService.js",
        "uuid": "286b2203-62ce-485f-8d11-7e988de817cd",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ConversationWebhookService.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Libs",
        "suites": [
          {
            "title": "ErrorObserver",
            "suites": [
              {
                "title": "next",
                "suites": [],
                "tests": [
                  {
                    "title": "Deve sollevare un'eccezione se viene chiamato.",
                    "fullTitle": "ErrorObserver next Deve sollevare un'eccezione se viene chiamato.",
                    "timedOut": false,
                    "duration": 1,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "expect(obs.next.bind(obs)).to.throw();",
                    "err": {},
                    "isRoot": false,
                    "uuid": "dfd0ca0b-ac0c-436e-a913-cd9b4969efaa",
                    "parentUUID": "756a3b68-64c5-4bb5-9c1e-59dbcc996680",
                    "skipped": false
                  }
                ],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_ErrorObserver.js",
                "uuid": "756a3b68-64c5-4bb5-9c1e-59dbcc996680",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ErrorObserver.js",
                "passes": [
                  {
                    "title": "Deve sollevare un'eccezione se viene chiamato.",
                    "fullTitle": "ErrorObserver next Deve sollevare un'eccezione se viene chiamato.",
                    "timedOut": false,
                    "duration": 1,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "expect(obs.next.bind(obs)).to.throw();",
                    "err": {},
                    "isRoot": false,
                    "uuid": "dfd0ca0b-ac0c-436e-a913-cd9b4969efaa",
                    "parentUUID": "756a3b68-64c5-4bb5-9c1e-59dbcc996680",
                    "skipped": false
                  }
                ],
                "failures": [],
                "skipped": [],
                "hasTests": true,
                "hasSuites": false,
                "totalTests": 1,
                "totalPasses": 1,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": true,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 1,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_ErrorObserver.js",
            "uuid": "8cb461bd-f0a8-4292-be73-3c6905efbfe1",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ErrorObserver.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_ErrorObserver.js",
        "uuid": "80cb0acb-2dab-4967-b69b-e475eecf15c9",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ErrorObserver.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "Guests",
            "suites": [
              {
                "title": "GuestsDAODynamoDB",
                "suites": [
                  {
                    "title": "addGuest",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "GuestsDAODynamoDB addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\"Requested resource not found\"});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "dc95fe5e-76a5-4fba-ad11-eba62b1325d1",
                        "parentUUID": "4a8f5f62-5c15-4f2f-8ce3-79210567d0ee",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui un ospite sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "fullTitle": "GuestsDAODynamoDB addGuest Nel caso in cui un ospite sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.addGuest('mauro','Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "f066f453-69fa-4926-bf8f-05eef32d8025",
                        "parentUUID": "4a8f5f62-5c15-4f2f-8ce3-79210567d0ee",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_GuestsDAODynamoDB.js",
                    "uuid": "4a8f5f62-5c15-4f2f-8ce3-79210567d0ee",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "GuestsDAODynamoDB addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\"Requested resource not found\"});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "dc95fe5e-76a5-4fba-ad11-eba62b1325d1",
                        "parentUUID": "4a8f5f62-5c15-4f2f-8ce3-79210567d0ee",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui un ospite sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "fullTitle": "GuestsDAODynamoDB addGuest Nel caso in cui un ospite sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.addGuest('mauro','Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "f066f453-69fa-4926-bf8f-05eef32d8025",
                        "parentUUID": "4a8f5f62-5c15-4f2f-8ce3-79210567d0ee",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "getGuest",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "GuestsDAODynamoDB getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.getGuest('Mauro', 'Zero12').subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \"error getting data\" });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c61f3362-04cf-4598-a65c-de16c8640d3d",
                        "parentUUID": "9a1d8c07-ea5b-4d5d-8439-26640542c387",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "fullTitle": "GuestsDAODynamoDB getGuest Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.getGuest('Mauro', 'Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \"Mauro\", company : \"Zero12\" }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \"Mauro\");\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\"Zero12\");\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "bd7fd340-1a6f-474e-a23f-8fac1e080e6d",
                        "parentUUID": "9a1d8c07-ea5b-4d5d-8439-26640542c387",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_GuestsDAODynamoDB.js",
                    "uuid": "9a1d8c07-ea5b-4d5d-8439-26640542c387",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "GuestsDAODynamoDB getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.getGuest('Mauro', 'Zero12').subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \"error getting data\" });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c61f3362-04cf-4598-a65c-de16c8640d3d",
                        "parentUUID": "9a1d8c07-ea5b-4d5d-8439-26640542c387",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "fullTitle": "GuestsDAODynamoDB getGuest Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.getGuest('Mauro', 'Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \"Mauro\", company : \"Zero12\" }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \"Mauro\");\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\"Zero12\");\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "bd7fd340-1a6f-474e-a23f-8fac1e080e6d",
                        "parentUUID": "9a1d8c07-ea5b-4d5d-8439-26640542c387",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 0,
                    "rootEmpty": false
                  },
                  {
                    "title": "getGuestList",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "GuestsDAODynamoDB getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \"Mauro\", company : \"Zero12\" }], LastEvaluatedKey: 'Piero'});\ndynamo_client.scan.yield(null, {Items: [{ name : \"Piero\", company : \"Google\" }], LastEvaluatedKey: 'Luca'});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('Mauro');\nexpect(callNext.args[0].company).to.equal('Zero12');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('Piero');\nexpect(callNext.args[0].company).to.equal('Google');\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "11e9802c-02e7-4a52-98f3-0f14e498bde6",
                        "parentUUID": "dadef009-1355-4a77-87f5-3738bb7e66f8",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "fullTitle": "GuestsDAODynamoDB getGuestList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \"Mauro\", company : \"Zero12\" }], LastEvaluatedKey: 'Piero'});\ndynamo_client.scan.yield(null, {Items: [{name : \"Piero\", company : \"Google\" }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('Mauro');\nexpect(callNext.args[0].company).to.equal('Zero12');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('Piero');\nexpect(callNext.args[0].company).to.equal('Google');\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "7a666708-c559-4ba8-a691-329a017e3fc1",
                        "parentUUID": "dadef009-1355-4a77-87f5-3738bb7e66f8",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_GuestsDAODynamoDB.js",
                    "uuid": "dadef009-1355-4a77-87f5-3738bb7e66f8",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "GuestsDAODynamoDB getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \"Mauro\", company : \"Zero12\" }], LastEvaluatedKey: 'Piero'});\ndynamo_client.scan.yield(null, {Items: [{ name : \"Piero\", company : \"Google\" }], LastEvaluatedKey: 'Luca'});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('Mauro');\nexpect(callNext.args[0].company).to.equal('Zero12');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('Piero');\nexpect(callNext.args[0].company).to.equal('Google');\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "11e9802c-02e7-4a52-98f3-0f14e498bde6",
                        "parentUUID": "dadef009-1355-4a77-87f5-3738bb7e66f8",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "fullTitle": "GuestsDAODynamoDB getGuestList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \"Mauro\", company : \"Zero12\" }], LastEvaluatedKey: 'Piero'});\ndynamo_client.scan.yield(null, {Items: [{name : \"Piero\", company : \"Google\" }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('Mauro');\nexpect(callNext.args[0].company).to.equal('Zero12');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('Piero');\nexpect(callNext.args[0].company).to.equal('Google');\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "7a666708-c559-4ba8-a691-329a017e3fc1",
                        "parentUUID": "dadef009-1355-4a77-87f5-3738bb7e66f8",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "removeGuest",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "GuestsDAODynamoDB removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.removeGuest('mou').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \"error removing guest\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "9e20406b-fa00-4116-a8ca-6e0529a7b354",
                        "parentUUID": "ecda102d-8229-49e6-8ecf-4d8918f2a571",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui un ospite sia eliminato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "fullTitle": "GuestsDAODynamoDB removeGuest Nel caso in cui un ospite sia eliminato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.removeGuest('mou','Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \"success\" });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "ff719bb8-c323-4299-aa80-e357a2b668ff",
                        "parentUUID": "ecda102d-8229-49e6-8ecf-4d8918f2a571",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_GuestsDAODynamoDB.js",
                    "uuid": "ecda102d-8229-49e6-8ecf-4d8918f2a571",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "GuestsDAODynamoDB removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.removeGuest('mou').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \"error removing guest\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "9e20406b-fa00-4116-a8ca-6e0529a7b354",
                        "parentUUID": "ecda102d-8229-49e6-8ecf-4d8918f2a571",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui un ospite sia eliminato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "fullTitle": "GuestsDAODynamoDB removeGuest Nel caso in cui un ospite sia eliminato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.removeGuest('mou','Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \"success\" });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "ff719bb8-c323-4299-aa80-e357a2b668ff",
                        "parentUUID": "ecda102d-8229-49e6-8ecf-4d8918f2a571",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  },
                  {
                    "title": "updateGuest",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "GuestsDAODynamoDB updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.updateGuest('mou').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\"error updating guest\"});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "1a403bfa-73ba-408c-9db7-6c7b2633ed97",
                        "parentUUID": "16b23eac-f406-487a-bf90-05d97938f888",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui un ospite sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "fullTitle": "GuestsDAODynamoDB updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.updateGuest('mou','Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "3b8240b9-4326-4022-8296-b59a8896b8fb",
                        "parentUUID": "16b23eac-f406-487a-bf90-05d97938f888",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_GuestsDAODynamoDB.js",
                    "uuid": "16b23eac-f406-487a-bf90-05d97938f888",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "GuestsDAODynamoDB updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.updateGuest('mou').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\"error updating guest\"});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "1a403bfa-73ba-408c-9db7-6c7b2633ed97",
                        "parentUUID": "16b23eac-f406-487a-bf90-05d97938f888",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui un ospite sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "fullTitle": "GuestsDAODynamoDB updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.updateGuest('mou','Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "3b8240b9-4326-4022-8296-b59a8896b8fb",
                        "parentUUID": "16b23eac-f406-487a-bf90-05d97938f888",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "addConversation",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui si provi ad aggiungere l'id di una conversazione gi presente, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "GuestsDAODynamoDB addConversation Nel caso in cui si provi ad aggiungere l'id di una conversazione gi presente, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.addConversation('Mauro', 'Zero12', 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "750c214e-81a1-4c9b-9752-6c4918b40401",
                        "parentUUID": "0e2cba76-65dc-4050-b4eb-103509990c73",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui venga aggiunto correttamente l'id di una conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "fullTitle": "GuestsDAODynamoDB addConversation Nel caso in cui venga aggiunto correttamente l'id di una conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.addConversation('Mauro', 'Zero12', 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "2c22e6b9-297c-467c-b9d1-381785ab4859",
                        "parentUUID": "0e2cba76-65dc-4050-b4eb-103509990c73",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_GuestsDAODynamoDB.js",
                    "uuid": "0e2cba76-65dc-4050-b4eb-103509990c73",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui si provi ad aggiungere l'id di una conversazione gi presente, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "fullTitle": "GuestsDAODynamoDB addConversation Nel caso in cui si provi ad aggiungere l'id di una conversazione gi presente, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.addConversation('Mauro', 'Zero12', 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "750c214e-81a1-4c9b-9752-6c4918b40401",
                        "parentUUID": "0e2cba76-65dc-4050-b4eb-103509990c73",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui venga aggiunto correttamente l'id di una conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "fullTitle": "GuestsDAODynamoDB addConversation Nel caso in cui venga aggiunto correttamente l'id di una conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "guests.addConversation('Mauro', 'Zero12', 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "2c22e6b9-297c-467c-b9d1-381785ab4859",
                        "parentUUID": "0e2cba76-65dc-4050-b4eb-103509990c73",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_GuestsDAODynamoDB.js",
                "uuid": "cd52aa9a-abf6-4760-b8de-42fdd4ab288d",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_GuestsDAODynamoDB.js",
            "uuid": "e9554e50-a27d-46ba-9d7f-eb6c8c1a2eaa",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_GuestsDAODynamoDB.js",
        "uuid": "4e2fc102-a880-42e6-8114-4260b542b4cd",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_GuestsDAODynamoDB.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "Members",
            "suites": [
              {
                "title": "MembersDAOSlack",
                "suites": [
                  {
                    "title": "addMember",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
                        "fullTitle": "MembersDAOSlack addMember Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "members.addMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "02c90b6d-866c-4d20-9039-4360eda8cccd",
                        "parentUUID": "9af67e4a-18cf-4645-90d6-25862c96083d",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_MembersDAOSlack.js",
                    "uuid": "9af67e4a-18cf-4645-90d6-25862c96083d",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js",
                    "passes": [
                      {
                        "title": "Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
                        "fullTitle": "MembersDAOSlack addMember Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "members.addMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "02c90b6d-866c-4d20-9039-4360eda8cccd",
                        "parentUUID": "9af67e4a-18cf-4645-90d6-25862c96083d",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 0,
                    "rootEmpty": false
                  },
                  {
                    "title": "getMember",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui il metodo ottenga il membro dell'azienda allora l'Observable invia tale Member all'Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.",
                        "fullTitle": "MembersDAOSlack getMember Nel caso in cui il metodo ottenga il membro dell'azienda allora l'Observable invia tale Member all'Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "members.getMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t'ok': true,\n\t'user':\n\t{\n\t\t'id': 'U023BECGF',\n\t\t'name': 'bobby',\n\t\t'deleted': false,\n\t\t'color': '9f69e7',\n\t\t'profile':\n\t\t{\n\t\t\t'avatar_hash': 'ge3b51ca72de',\n\t\t\t'current_status': ':mountain_railway: riding a train',\n\t\t\t'first_name': 'Bobby',\n\t\t\t'last_name': 'Tables',\n\t\t\t'real_name': 'Bobby Tables',\n\t\t\t'email': 'bobby@slack.com',\n\t\t\t'skype': 'my-skype-name',\n\t\t\t'phone': '+1 (123) 456 7890'\n\t\t},\n\t\t'is_admin': true,\n\t\t'is_owner': true,\n\t\t'updated': 1490054400,\n\t\t'has_2fa': true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "ff5aefbd-f636-4c74-a713-a44af12b6cd8",
                        "parentUUID": "f496455b-3885-46b8-a45d-b91c857490d2",
                        "skipped": false
                      },
                      {
                        "title": "Se si verifica un errore nell'ottenere il membro dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
                        "fullTitle": "MembersDAOSlack getMember Se si verifica un errore nell'ottenere il membro dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "members.getMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t'ok': false,\n\t'error': 'not_authed'\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal('not_authed');\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "863e06bc-cf24-4155-8e0c-1adb021ed578",
                        "parentUUID": "f496455b-3885-46b8-a45d-b91c857490d2",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_MembersDAOSlack.js",
                    "uuid": "f496455b-3885-46b8-a45d-b91c857490d2",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui il metodo ottenga il membro dell'azienda allora l'Observable invia tale Member all'Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.",
                        "fullTitle": "MembersDAOSlack getMember Nel caso in cui il metodo ottenga il membro dell'azienda allora l'Observable invia tale Member all'Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "members.getMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t'ok': true,\n\t'user':\n\t{\n\t\t'id': 'U023BECGF',\n\t\t'name': 'bobby',\n\t\t'deleted': false,\n\t\t'color': '9f69e7',\n\t\t'profile':\n\t\t{\n\t\t\t'avatar_hash': 'ge3b51ca72de',\n\t\t\t'current_status': ':mountain_railway: riding a train',\n\t\t\t'first_name': 'Bobby',\n\t\t\t'last_name': 'Tables',\n\t\t\t'real_name': 'Bobby Tables',\n\t\t\t'email': 'bobby@slack.com',\n\t\t\t'skype': 'my-skype-name',\n\t\t\t'phone': '+1 (123) 456 7890'\n\t\t},\n\t\t'is_admin': true,\n\t\t'is_owner': true,\n\t\t'updated': 1490054400,\n\t\t'has_2fa': true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "ff5aefbd-f636-4c74-a713-a44af12b6cd8",
                        "parentUUID": "f496455b-3885-46b8-a45d-b91c857490d2",
                        "skipped": false
                      },
                      {
                        "title": "Se si verifica un errore nell'ottenere il membro dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
                        "fullTitle": "MembersDAOSlack getMember Se si verifica un errore nell'ottenere il membro dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "members.getMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t'ok': false,\n\t'error': 'not_authed'\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal('not_authed');\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "863e06bc-cf24-4155-8e0c-1adb021ed578",
                        "parentUUID": "f496455b-3885-46b8-a45d-b91c857490d2",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "getMemberList",
                    "suites": [],
                    "tests": [
                      {
                        "title": "L'Observable deve notificare l'Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.",
                        "fullTitle": "MembersDAOSlack getMemberList L'Observable deve notificare l'Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\"ok\": true,\n\t\"members\":\n\t[\n\t\t{\n\t\t\t\"id\": \"U023BECGF\",\n\t\t\t\"team_id\": \"T021F9ZE2\",\n\t\t\t\"name\": \"mauro\",\n\t\t\t\"deleted\": false,\n\t\t\t\"status\": null,\n\t\t\t\"color\": \"9f69e7\",\n\t\t\t\"real_name\": \"Mauro Bocciofilo\",\n\t\t\t\"tz\": \"America\\/Los_Angeles\",\n\t\t\t\"tz_label\": \"Pacific Daylight Time\",\n\t\t\t\"tz_offset\": -25200,\n\t\t\t\"profile\":\n\t\t\t{\n\t\t\t\t\"avatar_hash\": \"ge3b51ca72de\",\n\t\t\t\t\"current_status\": \":mountain_railway: riding a train\",\n\t\t\t\t\"first_name\": \"Bobby\",\n\t\t\t\t\"last_name\": \"Tables\",\n\t\t\t\t\"real_name\": \"Bobby Tables\",\n\t\t\t\t\"email\": \"bobby@slack.com\",\n\t\t\t\t\"skype\": \"my-skype-name\",\n\t\t\t\t\"phone\": \"+1 (123) 456 7890\"\n\t\t\t},\n\t\t\t\"is_admin\": true,\n\t\t\t\"is_owner\": true,\n\t\t\t\"updated\": 1490054400,\n\t\t\t\"has_2fa\": false\n\t\t},\n\t\t{\n\t\t\t\"id\": \"U023BECLL\",\n\t\t\t\"team_id\": \"T021F9ZE2\",\n\t\t\t\"name\": \"bobby\",\n\t\t\t\"deleted\": false,\n\t\t\t\"status\": null,\n\t\t\t\"color\": \"9f69e7\",\n\t\t\t\"real_name\": \"Bobby Tables\",\n\t\t\t\"tz\": \"America\\/Los_Angeles\",\n\t\t\t\"tz_label\": \"Pacific Daylight Time\",\n\t\t\t\"tz_offset\": -25200,\n\t\t\t\"profile\":\n\t\t\t{\n\t\t\t\t\"avatar_hash\": \"ge3b51ca72de\",\n\t\t\t\t\"current_status\": \":mountain_railway: riding a train\",\n\t\t\t\t\"first_name\": \"Bobby\",\n\t\t\t\t\"last_name\": \"Tables\",\n\t\t\t\t\"real_name\": \"Bobby Tables\",\n\t\t\t\t\"email\": \"bobby@slack.com\",\n\t\t\t\t\"skype\": \"my-skype-name\",\n\t\t\t\t\"phone\": \"+1 (123) 456 7890\",\n\t\t\t},\n\t\t\t\"is_admin\": true,\n\t\t\t\"is_owner\": true,\n\t\t\t\"updated\": 1490054400,\n\t\t\t\"has_2fa\": false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b734ee6e-a8cf-447b-8980-62e7803d3734",
                        "parentUUID": "75f84416-5a90-49df-9969-8fe6b9ce7f77",
                        "skipped": false
                      },
                      {
                        "title": "Se si verifica un errore nell'ottenere la lista dei membri dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
                        "fullTitle": "MembersDAOSlack getMemberList Se si verifica un errore nell'ottenere la lista dei membri dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t'ok': false,\n\t'error': 'not_authed'\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal('not_authed');\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "45d2c132-4196-4121-bfc3-2941853864cc",
                        "parentUUID": "75f84416-5a90-49df-9969-8fe6b9ce7f77",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_MembersDAOSlack.js",
                    "uuid": "75f84416-5a90-49df-9969-8fe6b9ce7f77",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js",
                    "passes": [
                      {
                        "title": "L'Observable deve notificare l'Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.",
                        "fullTitle": "MembersDAOSlack getMemberList L'Observable deve notificare l'Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\"ok\": true,\n\t\"members\":\n\t[\n\t\t{\n\t\t\t\"id\": \"U023BECGF\",\n\t\t\t\"team_id\": \"T021F9ZE2\",\n\t\t\t\"name\": \"mauro\",\n\t\t\t\"deleted\": false,\n\t\t\t\"status\": null,\n\t\t\t\"color\": \"9f69e7\",\n\t\t\t\"real_name\": \"Mauro Bocciofilo\",\n\t\t\t\"tz\": \"America\\/Los_Angeles\",\n\t\t\t\"tz_label\": \"Pacific Daylight Time\",\n\t\t\t\"tz_offset\": -25200,\n\t\t\t\"profile\":\n\t\t\t{\n\t\t\t\t\"avatar_hash\": \"ge3b51ca72de\",\n\t\t\t\t\"current_status\": \":mountain_railway: riding a train\",\n\t\t\t\t\"first_name\": \"Bobby\",\n\t\t\t\t\"last_name\": \"Tables\",\n\t\t\t\t\"real_name\": \"Bobby Tables\",\n\t\t\t\t\"email\": \"bobby@slack.com\",\n\t\t\t\t\"skype\": \"my-skype-name\",\n\t\t\t\t\"phone\": \"+1 (123) 456 7890\"\n\t\t\t},\n\t\t\t\"is_admin\": true,\n\t\t\t\"is_owner\": true,\n\t\t\t\"updated\": 1490054400,\n\t\t\t\"has_2fa\": false\n\t\t},\n\t\t{\n\t\t\t\"id\": \"U023BECLL\",\n\t\t\t\"team_id\": \"T021F9ZE2\",\n\t\t\t\"name\": \"bobby\",\n\t\t\t\"deleted\": false,\n\t\t\t\"status\": null,\n\t\t\t\"color\": \"9f69e7\",\n\t\t\t\"real_name\": \"Bobby Tables\",\n\t\t\t\"tz\": \"America\\/Los_Angeles\",\n\t\t\t\"tz_label\": \"Pacific Daylight Time\",\n\t\t\t\"tz_offset\": -25200,\n\t\t\t\"profile\":\n\t\t\t{\n\t\t\t\t\"avatar_hash\": \"ge3b51ca72de\",\n\t\t\t\t\"current_status\": \":mountain_railway: riding a train\",\n\t\t\t\t\"first_name\": \"Bobby\",\n\t\t\t\t\"last_name\": \"Tables\",\n\t\t\t\t\"real_name\": \"Bobby Tables\",\n\t\t\t\t\"email\": \"bobby@slack.com\",\n\t\t\t\t\"skype\": \"my-skype-name\",\n\t\t\t\t\"phone\": \"+1 (123) 456 7890\",\n\t\t\t},\n\t\t\t\"is_admin\": true,\n\t\t\t\"is_owner\": true,\n\t\t\t\"updated\": 1490054400,\n\t\t\t\"has_2fa\": false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b734ee6e-a8cf-447b-8980-62e7803d3734",
                        "parentUUID": "75f84416-5a90-49df-9969-8fe6b9ce7f77",
                        "skipped": false
                      },
                      {
                        "title": "Se si verifica un errore nell'ottenere la lista dei membri dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
                        "fullTitle": "MembersDAOSlack getMemberList Se si verifica un errore nell'ottenere la lista dei membri dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t'ok': false,\n\t'error': 'not_authed'\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal('not_authed');\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "45d2c132-4196-4121-bfc3-2941853864cc",
                        "parentUUID": "75f84416-5a90-49df-9969-8fe6b9ce7f77",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "removeMember",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
                        "fullTitle": "MembersDAOSlack removeMember Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "members.removeMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a5d59fe5-2a67-4407-8b93-70e32d0a391a",
                        "parentUUID": "b55027f0-3c8d-4942-8d33-906e3a6b27de",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_MembersDAOSlack.js",
                    "uuid": "b55027f0-3c8d-4942-8d33-906e3a6b27de",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js",
                    "passes": [
                      {
                        "title": "Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
                        "fullTitle": "MembersDAOSlack removeMember Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "members.removeMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a5d59fe5-2a67-4407-8b93-70e32d0a391a",
                        "parentUUID": "b55027f0-3c8d-4942-8d33-906e3a6b27de",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 0,
                    "rootEmpty": false
                  },
                  {
                    "title": "updateMember",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
                        "fullTitle": "MembersDAOSlack updateMember Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "members.updateMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "1f57d3f5-677b-44ed-8d66-1a120667b18d",
                        "parentUUID": "ee9569e5-5359-4b17-8858-1b444fdecd21",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_MembersDAOSlack.js",
                    "uuid": "ee9569e5-5359-4b17-8858-1b444fdecd21",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js",
                    "passes": [
                      {
                        "title": "Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
                        "fullTitle": "MembersDAOSlack updateMember Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "members.updateMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "1f57d3f5-677b-44ed-8d66-1a120667b18d",
                        "parentUUID": "ee9569e5-5359-4b17-8858-1b444fdecd21",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_MembersDAOSlack.js",
                "uuid": "fcf37b32-ef1a-421f-92b7-219abfc0a7f2",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_MembersDAOSlack.js",
            "uuid": "68304de3-a933-4e59-bf2c-3ff05d85b89b",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_MembersDAOSlack.js",
        "uuid": "04ecd71e-7d7b-4c15-ad3a-b8279fff9c69",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_MembersDAOSlack.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "Notifications",
            "suites": [
              {
                "title": "NotificationService",
                "suites": [
                  {
                    "title": "getChannelList",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 3,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = {body: '', queryStringParameters: ''};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields('errore');\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property('statusCode', 500);\n  done();\n}",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a03595bc-4005-47dc-8f88-9f35fb5d3093",
                        "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = {body: '', queryStringParameters: ''};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields('errore');\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property('statusCode', 500);\n            done();\n          }",
                        "err": {},
                        "isRoot": false,
                        "uuid": "614e27bb-15a4-472e-bef7-beba02ee0f64",
                        "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = {body: '', queryStringParameters: ''};\n          service.getChannelList(ev, context);\n          client.groups.list.yields('errore');\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property('statusCode', 500);\n            done();\n          }",
                        "err": {},
                        "isRoot": false,
                        "uuid": "15ec6b31-d1f3-419c-87fb-ac3350c32f2d",
                        "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.",
                        "fullTitle": "NotificationService getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = {body: '', queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property('statusCode', 200);\n  done();\n}",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e7d3f27b-f8e4-42ec-91ba-bbc1ed2da38c",
                        "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_NotificationService.js",
                    "uuid": "1cea4c65-d253-45c9-bbbe-1757c1650056",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 3,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = {body: '', queryStringParameters: ''};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields('errore');\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property('statusCode', 500);\n  done();\n}",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a03595bc-4005-47dc-8f88-9f35fb5d3093",
                        "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = {body: '', queryStringParameters: ''};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields('errore');\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property('statusCode', 500);\n            done();\n          }",
                        "err": {},
                        "isRoot": false,
                        "uuid": "614e27bb-15a4-472e-bef7-beba02ee0f64",
                        "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "NotificationService getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = {body: '', queryStringParameters: ''};\n          service.getChannelList(ev, context);\n          client.groups.list.yields('errore');\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property('statusCode', 500);\n            done();\n          }",
                        "err": {},
                        "isRoot": false,
                        "uuid": "15ec6b31-d1f3-419c-87fb-ac3350c32f2d",
                        "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.",
                        "fullTitle": "NotificationService getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = {body: '', queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property('statusCode', 200);\n  done();\n}",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e7d3f27b-f8e4-42ec-91ba-bbc1ed2da38c",
                        "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 4,
                    "totalPasses": 4,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 6,
                    "rootEmpty": false
                  },
                  {
                    "title": "sendMsg",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "NotificationService sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield('errore');\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "ae8cf8d6-4571-48fb-be84-956e4b9d6f30",
                        "parentUUID": "66ed54d0-d725-42a7-9d8b-256e464c7d4d",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.",
                        "fullTitle": "NotificationService sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b4c761ba-ee0e-4b8a-bff5-1f395660f1bc",
                        "parentUUID": "66ed54d0-d725-42a7-9d8b-256e464c7d4d",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
                        "fullTitle": "NotificationService sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\n\nexpect(context.succeed.callCount).to.equal(1);\t\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property('statusCode', 400);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "8a26cac5-7042-4edb-a571-29cf75d4ea72",
                        "parentUUID": "66ed54d0-d725-42a7-9d8b-256e464c7d4d",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_NotificationService.js",
                    "uuid": "66ed54d0-d725-42a7-9d8b-256e464c7d4d",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "NotificationService sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield('errore');\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "ae8cf8d6-4571-48fb-be84-956e4b9d6f30",
                        "parentUUID": "66ed54d0-d725-42a7-9d8b-256e464c7d4d",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.",
                        "fullTitle": "NotificationService sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b4c761ba-ee0e-4b8a-bff5-1f395660f1bc",
                        "parentUUID": "66ed54d0-d725-42a7-9d8b-256e464c7d4d",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
                        "fullTitle": "NotificationService sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\n\nexpect(context.succeed.callCount).to.equal(1);\t\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property('statusCode', 400);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "8a26cac5-7042-4edb-a571-29cf75d4ea72",
                        "parentUUID": "66ed54d0-d725-42a7-9d8b-256e464c7d4d",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 3,
                    "totalPasses": 3,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_NotificationService.js",
                "uuid": "990eb7ac-4701-483d-85b5-bbc79b0895ae",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_NotificationService.js",
            "uuid": "5550942a-d07f-41cc-8e6a-90d381b72538",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_NotificationService.js",
        "uuid": "a8c9e797-da30-4005-9451-97b8d290701c",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_NotificationService.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Libs",
        "suites": [
          {
            "title": "ObserverAdapter",
            "suites": [
              {
                "title": "complete",
                "suites": [],
                "tests": [
                  {
                    "title": "Deve chiamare complete_cb",
                    "fullTitle": "ObserverAdapter complete Deve chiamare complete_cb",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \"il callback di complete non  stato chiamato esattamente una volta.\").to.equal(1);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "ef9c9039-f6f5-40d6-97d1-70b94fcd26db",
                    "parentUUID": "59c5c0f1-bb37-4b83-9257-931e791a6665",
                    "skipped": false
                  },
                  {
                    "title": "Non deve chiamare complete_cb se l'observer  in pausa",
                    "fullTitle": "ObserverAdapter complete Non deve chiamare complete_cb se l'observer  in pausa",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "6bcd6731-20e5-4535-90e3-8e5709f7ab8a",
                    "parentUUID": "59c5c0f1-bb37-4b83-9257-931e791a6665",
                    "skipped": false
                  },
                  {
                    "title": "Deve chiamare complete_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
                    "fullTitle": "ObserverAdapter complete Deve chiamare complete_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "ad63bef1-4072-4682-9079-624c2f18b53a",
                    "parentUUID": "59c5c0f1-bb37-4b83-9257-931e791a6665",
                    "skipped": false
                  }
                ],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_ObserverAdapter.js",
                "uuid": "59c5c0f1-bb37-4b83-9257-931e791a6665",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js",
                "passes": [
                  {
                    "title": "Deve chiamare complete_cb",
                    "fullTitle": "ObserverAdapter complete Deve chiamare complete_cb",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \"il callback di complete non  stato chiamato esattamente una volta.\").to.equal(1);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "ef9c9039-f6f5-40d6-97d1-70b94fcd26db",
                    "parentUUID": "59c5c0f1-bb37-4b83-9257-931e791a6665",
                    "skipped": false
                  },
                  {
                    "title": "Non deve chiamare complete_cb se l'observer  in pausa",
                    "fullTitle": "ObserverAdapter complete Non deve chiamare complete_cb se l'observer  in pausa",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "6bcd6731-20e5-4535-90e3-8e5709f7ab8a",
                    "parentUUID": "59c5c0f1-bb37-4b83-9257-931e791a6665",
                    "skipped": false
                  },
                  {
                    "title": "Deve chiamare complete_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
                    "fullTitle": "ObserverAdapter complete Deve chiamare complete_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "ad63bef1-4072-4682-9079-624c2f18b53a",
                    "parentUUID": "59c5c0f1-bb37-4b83-9257-931e791a6665",
                    "skipped": false
                  }
                ],
                "failures": [],
                "skipped": [],
                "hasTests": true,
                "hasSuites": false,
                "totalTests": 3,
                "totalPasses": 3,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": true,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              },
              {
                "title": "error",
                "suites": [],
                "tests": [
                  {
                    "title": "Deve chiamare error_cb",
                    "fullTitle": "ObserverAdapter error Deve chiamare error_cb",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "let err = new Error('Errore');\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "ccd804ad-6a28-4339-9e0c-24f5a161d70d",
                    "parentUUID": "1ec6d4e7-c568-4ec1-8285-20c05faaf50a",
                    "skipped": false
                  },
                  {
                    "title": "Non deve chiamare error_cb se l'observer  in pausa",
                    "fullTitle": "ObserverAdapter error Non deve chiamare error_cb se l'observer  in pausa",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "obs.onError(success);\nobs.pause();\nobs.error('errore');\n        expect(success.callCount).to.equal(0);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "e3a1cf5e-99cf-4258-9b89-b9b0cef7fd36",
                    "parentUUID": "1ec6d4e7-c568-4ec1-8285-20c05faaf50a",
                    "skipped": false
                  },
                  {
                    "title": "Deve chiamare error_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
                    "fullTitle": "ObserverAdapter error Deve chiamare error_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "let err = new Error('Errore');\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "e193717c-9272-4eb9-8ae7-100137f55ea9",
                    "parentUUID": "1ec6d4e7-c568-4ec1-8285-20c05faaf50a",
                    "skipped": false
                  }
                ],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_ObserverAdapter.js",
                "uuid": "1ec6d4e7-c568-4ec1-8285-20c05faaf50a",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js",
                "passes": [
                  {
                    "title": "Deve chiamare error_cb",
                    "fullTitle": "ObserverAdapter error Deve chiamare error_cb",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "let err = new Error('Errore');\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "ccd804ad-6a28-4339-9e0c-24f5a161d70d",
                    "parentUUID": "1ec6d4e7-c568-4ec1-8285-20c05faaf50a",
                    "skipped": false
                  },
                  {
                    "title": "Non deve chiamare error_cb se l'observer  in pausa",
                    "fullTitle": "ObserverAdapter error Non deve chiamare error_cb se l'observer  in pausa",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "obs.onError(success);\nobs.pause();\nobs.error('errore');\n        expect(success.callCount).to.equal(0);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "e3a1cf5e-99cf-4258-9b89-b9b0cef7fd36",
                    "parentUUID": "1ec6d4e7-c568-4ec1-8285-20c05faaf50a",
                    "skipped": false
                  },
                  {
                    "title": "Deve chiamare error_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
                    "fullTitle": "ObserverAdapter error Deve chiamare error_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "let err = new Error('Errore');\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "e193717c-9272-4eb9-8ae7-100137f55ea9",
                    "parentUUID": "1ec6d4e7-c568-4ec1-8285-20c05faaf50a",
                    "skipped": false
                  }
                ],
                "failures": [],
                "skipped": [],
                "hasTests": true,
                "hasSuites": false,
                "totalTests": 3,
                "totalPasses": 3,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": true,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              },
              {
                "title": "next",
                "suites": [],
                "tests": [
                  {
                    "title": "Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l'observer non  in pausa.",
                    "fullTitle": "ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l'observer non  in pausa.",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "obs.onNext(success);\nobs.next('data');\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal('data');",
                    "err": {},
                    "isRoot": false,
                    "uuid": "4ce1ffae-80fb-4cb2-ba87-03004aa1f785",
                    "parentUUID": "8394b522-9ca0-4007-acbd-f56b5cdd4bdf",
                    "skipped": false
                  },
                  {
                    "title": "Non deve chiamare next_cb se l'observer  in pausa",
                    "fullTitle": "ObserverAdapter next Non deve chiamare next_cb se l'observer  in pausa",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "obs.onNext(success);\nobs.pause();\nobs.next('Function called');\nexpect(success.callCount).to.equal(0);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "6ffa568f-39f1-4a88-90a9-44c3c3ff1a11",
                    "parentUUID": "8394b522-9ca0-4007-acbd-f56b5cdd4bdf",
                    "skipped": false
                  },
                  {
                    "title": "Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l'observer ha ripreso.",
                    "fullTitle": "ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l'observer ha ripreso.",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "obs.onNext(success);\nobs.next('data');\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next('data');\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next('other data');\nexpect(success.callCount).to.equal(2);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "b7df49b6-2cc9-4415-8c28-cb59c4ed6391",
                    "parentUUID": "8394b522-9ca0-4007-acbd-f56b5cdd4bdf",
                    "skipped": false
                  }
                ],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_ObserverAdapter.js",
                "uuid": "8394b522-9ca0-4007-acbd-f56b5cdd4bdf",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js",
                "passes": [
                  {
                    "title": "Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l'observer non  in pausa.",
                    "fullTitle": "ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l'observer non  in pausa.",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "obs.onNext(success);\nobs.next('data');\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal('data');",
                    "err": {},
                    "isRoot": false,
                    "uuid": "4ce1ffae-80fb-4cb2-ba87-03004aa1f785",
                    "parentUUID": "8394b522-9ca0-4007-acbd-f56b5cdd4bdf",
                    "skipped": false
                  },
                  {
                    "title": "Non deve chiamare next_cb se l'observer  in pausa",
                    "fullTitle": "ObserverAdapter next Non deve chiamare next_cb se l'observer  in pausa",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "obs.onNext(success);\nobs.pause();\nobs.next('Function called');\nexpect(success.callCount).to.equal(0);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "6ffa568f-39f1-4a88-90a9-44c3c3ff1a11",
                    "parentUUID": "8394b522-9ca0-4007-acbd-f56b5cdd4bdf",
                    "skipped": false
                  },
                  {
                    "title": "Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l'observer ha ripreso.",
                    "fullTitle": "ObserverAdapter next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l'observer ha ripreso.",
                    "timedOut": false,
                    "duration": 0,
                    "state": "passed",
                    "speed": "fast",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "obs.onNext(success);\nobs.next('data');\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next('data');\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next('other data');\nexpect(success.callCount).to.equal(2);",
                    "err": {},
                    "isRoot": false,
                    "uuid": "b7df49b6-2cc9-4415-8c28-cb59c4ed6391",
                    "parentUUID": "8394b522-9ca0-4007-acbd-f56b5cdd4bdf",
                    "skipped": false
                  }
                ],
                "failures": [],
                "skipped": [],
                "hasTests": true,
                "hasSuites": false,
                "totalTests": 3,
                "totalPasses": 3,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": true,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_ObserverAdapter.js",
            "uuid": "57412476-ad58-4480-ac9d-379a5ae0b331",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_ObserverAdapter.js",
        "uuid": "a8f73bc3-8a1e-4b0b-9203-2facba49e91d",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_ObserverAdapter.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "Rules",
            "suites": [
              {
                "title": "RulesDAODynamoDB",
                "suites": [
                  {
                    "title": "addRule",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "RulesDAODynamoDB addRule Nel caso in cui una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\"Requested resource not found\"});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "089db301-228f-4a19-a1af-36e3bcba89cb",
                        "parentUUID": "7c6f9016-2624-40c3-8b6a-d16a274d03e1",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "RulesDAODynamoDB addRule Nel caso in cui una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "4ac71995-fe96-4624-aa03-da1927853bce",
                        "parentUUID": "7c6f9016-2624-40c3-8b6a-d16a274d03e1",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_RulesDAODynamoDB.js",
                    "uuid": "7c6f9016-2624-40c3-8b6a-d16a274d03e1",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "RulesDAODynamoDB addRule Nel caso in cui una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\"Requested resource not found\"});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "089db301-228f-4a19-a1af-36e3bcba89cb",
                        "parentUUID": "7c6f9016-2624-40c3-8b6a-d16a274d03e1",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "RulesDAODynamoDB addRule Nel caso in cui una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "4ac71995-fe96-4624-aa03-da1927853bce",
                        "parentUUID": "7c6f9016-2624-40c3-8b6a-d16a274d03e1",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  },
                  {
                    "title": "getRule",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "RulesDAODynamoDB getRule Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\"error getting data\"});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "d62cbc44-0f55-463c-93ae-2d70c0f90b20",
                        "parentUUID": "abf42e37-4b7b-484d-8800-a6bdda5f82c2",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "RulesDAODynamoDB getRule Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "f297c8e6-2069-4f39-87c1-1cc923099ffa",
                        "parentUUID": "abf42e37-4b7b-484d-8800-a6bdda5f82c2",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_RulesDAODynamoDB.js",
                    "uuid": "abf42e37-4b7b-484d-8800-a6bdda5f82c2",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "RulesDAODynamoDB getRule Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\"error getting data\"});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "d62cbc44-0f55-463c-93ae-2d70c0f90b20",
                        "parentUUID": "abf42e37-4b7b-484d-8800-a6bdda5f82c2",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "RulesDAODynamoDB getRule Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "f297c8e6-2069-4f39-87c1-1cc923099ffa",
                        "parentUUID": "abf42e37-4b7b-484d-8800-a6bdda5f82c2",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "getRuleList",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui un blocco di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "RulesDAODynamoDB getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "cfb14092-49d1-4c90-8294-1a0e823bbb40",
                        "parentUUID": "63b3612e-8067-4d44-ba08-8bd0a4b9892a",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "RulesDAODynamoDB getRuleList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "75bf4c6a-663d-4e20-beae-eb17a150cc2e",
                        "parentUUID": "63b3612e-8067-4d44-ba08-8bd0a4b9892a",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "RulesDAODynamoDB getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "//da definire",
                        "err": {},
                        "isRoot": false,
                        "uuid": "1a785b97-b413-4d56-88df-895cac1ccaab",
                        "parentUUID": "63b3612e-8067-4d44-ba08-8bd0a4b9892a",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_RulesDAODynamoDB.js",
                    "uuid": "63b3612e-8067-4d44-ba08-8bd0a4b9892a",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui un blocco di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "RulesDAODynamoDB getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "cfb14092-49d1-4c90-8294-1a0e823bbb40",
                        "parentUUID": "63b3612e-8067-4d44-ba08-8bd0a4b9892a",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "RulesDAODynamoDB getRuleList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "75bf4c6a-663d-4e20-beae-eb17a150cc2e",
                        "parentUUID": "63b3612e-8067-4d44-ba08-8bd0a4b9892a",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "RulesDAODynamoDB getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "//da definire",
                        "err": {},
                        "isRoot": false,
                        "uuid": "1a785b97-b413-4d56-88df-895cac1ccaab",
                        "parentUUID": "63b3612e-8067-4d44-ba08-8bd0a4b9892a",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 3,
                    "totalPasses": 3,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "removeRule",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "RulesDAODynamoDB removeRule Nel caso in cui una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\"error removing rule\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "caa39041-0f72-4888-90c8-65c61336a1a3",
                        "parentUUID": "423e1330-63d3-4117-b3f4-628dd1233ea5",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "RulesDAODynamoDB removeRule Nel caso in cui una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\"success\"});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "bd963fc4-421e-4c38-b7de-05eae863be08",
                        "parentUUID": "423e1330-63d3-4117-b3f4-628dd1233ea5",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_RulesDAODynamoDB.js",
                    "uuid": "423e1330-63d3-4117-b3f4-628dd1233ea5",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "RulesDAODynamoDB removeRule Nel caso in cui una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\"error removing rule\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "caa39041-0f72-4888-90c8-65c61336a1a3",
                        "parentUUID": "423e1330-63d3-4117-b3f4-628dd1233ea5",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "RulesDAODynamoDB removeRule Nel caso in cui una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\"success\"});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "bd963fc4-421e-4c38-b7de-05eae863be08",
                        "parentUUID": "423e1330-63d3-4117-b3f4-628dd1233ea5",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  },
                  {
                    "title": "updateRule",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "RulesDAODynamoDB updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\"error updating rule\"});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "bd274684-4120-49d6-b2de-cb7323b9fb09",
                        "parentUUID": "d89bcd03-42ad-4e60-91be-b78a848e33ea",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "RulesDAODynamoDB updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "95b845b3-a047-4201-a321-ba4f89ed81d9",
                        "parentUUID": "d89bcd03-42ad-4e60-91be-b78a848e33ea",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_RulesDAODynamoDB.js",
                    "uuid": "d89bcd03-42ad-4e60-91be-b78a848e33ea",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "RulesDAODynamoDB updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\"error updating rule\"});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "bd274684-4120-49d6-b2de-cb7323b9fb09",
                        "parentUUID": "d89bcd03-42ad-4e60-91be-b78a848e33ea",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "RulesDAODynamoDB updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "95b845b3-a047-4201-a321-ba4f89ed81d9",
                        "parentUUID": "d89bcd03-42ad-4e60-91be-b78a848e33ea",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_RulesDAODynamoDB.js",
                "uuid": "44c0d759-098e-4c80-a5d0-dc2fc8529593",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_RulesDAODynamoDB.js",
            "uuid": "bd65cefc-a561-4106-9fc4-6df4ccb591bb",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_RulesDAODynamoDB.js",
        "uuid": "3814141c-6d55-4b1c-8bf7-394cd9459b8f",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesDAODynamoDB.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "Rules",
            "suites": [
              {
                "title": "RulesService",
                "suites": [
                  {
                    "title": "addRule",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
                        "fullTitle": "RulesService addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \"\"};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 400);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c42876a2-86d4-482b-8da3-ede34ad9213f",
                        "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "RulesService addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "0e1fc861-dca2-4a2d-8e2f-860f4a40942f",
                        "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
                        "fullTitle": "RulesService addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c763b098-1ad3-41f3-82f1-edbd4ba347bd",
                        "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
                        "fullTitle": "RulesService addRule Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.addRule.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Conflict' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 409);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a015e9da-bf4e-458e-81c7-b7a34c72cdd0",
                        "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_RulesService.js",
                    "uuid": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
                        "fullTitle": "RulesService addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \"\"};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 400);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c42876a2-86d4-482b-8da3-ede34ad9213f",
                        "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "RulesService addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "0e1fc861-dca2-4a2d-8e2f-860f4a40942f",
                        "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
                        "fullTitle": "RulesService addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c763b098-1ad3-41f3-82f1-edbd4ba347bd",
                        "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
                        "fullTitle": "RulesService addRule Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.addRule.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Conflict' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 409);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a015e9da-bf4e-458e-81c7-b7a34c72cdd0",
                        "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 4,
                    "totalPasses": 4,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 5,
                    "rootEmpty": false
                  },
                  {
                    "title": "deleteRule",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "RulesService deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "29852138-9793-4a61-82dd-f284c94406cd",
                        "parentUUID": "5313bfde-f4d8-4ba7-9f07-ba7680c064e4",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
                        "fullTitle": "RulesService deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "66e7deee-a097-4f35-a8fa-842d0d1fdbcb",
                        "parentUUID": "5313bfde-f4d8-4ba7-9f07-ba7680c064e4",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
                        "fullTitle": "RulesService deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 404);\n};",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c6a70335-3dfc-41c1-b57f-51a24c3b3d72",
                        "parentUUID": "5313bfde-f4d8-4ba7-9f07-ba7680c064e4",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_RulesService.js",
                    "uuid": "5313bfde-f4d8-4ba7-9f07-ba7680c064e4",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "RulesService deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "29852138-9793-4a61-82dd-f284c94406cd",
                        "parentUUID": "5313bfde-f4d8-4ba7-9f07-ba7680c064e4",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
                        "fullTitle": "RulesService deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "66e7deee-a097-4f35-a8fa-842d0d1fdbcb",
                        "parentUUID": "5313bfde-f4d8-4ba7-9f07-ba7680c064e4",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
                        "fullTitle": "RulesService deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 404);\n};",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c6a70335-3dfc-41c1-b57f-51a24c3b3d72",
                        "parentUUID": "5313bfde-f4d8-4ba7-9f07-ba7680c064e4",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 3,
                    "totalPasses": 3,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "getRule",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.",
                        "fullTitle": "RulesService getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b862d873-13ab-4147-93a1-973bde319874",
                        "parentUUID": "fc64a12a-bf9c-4ce2-8c4f-0f62b1fe073f",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "RulesService getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "326099c3-e462-4b7d-a2cf-e9b185586fee",
                        "parentUUID": "fc64a12a-bf9c-4ce2-8c4f-0f62b1fe073f",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
                        "fullTitle": "RulesService getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.getRule.returns(Rx.Observable.throw({ code: 'Not found' }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 404);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "44d6c908-c026-4f9c-ace3-bb1a06996727",
                        "parentUUID": "fc64a12a-bf9c-4ce2-8c4f-0f62b1fe073f",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_RulesService.js",
                    "uuid": "fc64a12a-bf9c-4ce2-8c4f-0f62b1fe073f",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.",
                        "fullTitle": "RulesService getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b862d873-13ab-4147-93a1-973bde319874",
                        "parentUUID": "fc64a12a-bf9c-4ce2-8c4f-0f62b1fe073f",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "RulesService getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "326099c3-e462-4b7d-a2cf-e9b185586fee",
                        "parentUUID": "fc64a12a-bf9c-4ce2-8c4f-0f62b1fe073f",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
                        "fullTitle": "RulesService getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.getRule.returns(Rx.Observable.throw({ code: 'Not found' }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 404);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "44d6c908-c026-4f9c-ace3-bb1a06996727",
                        "parentUUID": "fc64a12a-bf9c-4ce2-8c4f-0f62b1fe073f",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 3,
                    "totalPasses": 3,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  },
                  {
                    "title": "getRuleList",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.",
                        "fullTitle": "RulesService getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "aa1d48d6-198a-4af4-afac-c7db759a1f38",
                        "parentUUID": "d73704ca-5230-41e5-8743-f3f3736b1622",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "RulesService getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c72d60cd-1b2c-40c6-935b-d6652128f8df",
                        "parentUUID": "d73704ca-5230-41e5-8743-f3f3736b1622",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_RulesService.js",
                    "uuid": "d73704ca-5230-41e5-8743-f3f3736b1622",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.",
                        "fullTitle": "RulesService getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "aa1d48d6-198a-4af4-afac-c7db759a1f38",
                        "parentUUID": "d73704ca-5230-41e5-8743-f3f3736b1622",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "RulesService getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c72d60cd-1b2c-40c6-935b-d6652128f8df",
                        "parentUUID": "d73704ca-5230-41e5-8743-f3f3736b1622",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  },
                  {
                    "title": "getTaskList",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.",
                        "fullTitle": "RulesService getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "116af487-0d65-4a4d-a337-8b1877a1d9cd",
                        "parentUUID": "02c31782-3d8b-4a20-9866-3e283c5dfc71",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "RulesService getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a28ec737-df8e-4c62-818f-82c5ab39be61",
                        "parentUUID": "02c31782-3d8b-4a20-9866-3e283c5dfc71",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_RulesService.js",
                    "uuid": "02c31782-3d8b-4a20-9866-3e283c5dfc71",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.",
                        "fullTitle": "RulesService getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "116af487-0d65-4a4d-a337-8b1877a1d9cd",
                        "parentUUID": "02c31782-3d8b-4a20-9866-3e283c5dfc71",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "RulesService getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a28ec737-df8e-4c62-818f-82c5ab39be61",
                        "parentUUID": "02c31782-3d8b-4a20-9866-3e283c5dfc71",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  },
                  {
                    "title": "updateRule",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
                        "fullTitle": "RulesService updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "6b1cc0eb-5a3b-4c05-8b3a-4bdf0221c572",
                        "parentUUID": "0cd041b3-ae95-4251-b4f8-b914d0cb3135",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
                        "fullTitle": "RulesService updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \"\" , body: \"\"};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 400);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "9e880780-5b00-4cae-98e7-d55e9547d9fe",
                        "parentUUID": "0cd041b3-ae95-4251-b4f8-b914d0cb3135",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "RulesService updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b9ef09a1-5610-46f7-b448-23e2c1fa9d78",
                        "parentUUID": "0cd041b3-ae95-4251-b4f8-b914d0cb3135",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_RulesService.js",
                    "uuid": "0cd041b3-ae95-4251-b4f8-b914d0cb3135",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
                        "fullTitle": "RulesService updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "6b1cc0eb-5a3b-4c05-8b3a-4bdf0221c572",
                        "parentUUID": "0cd041b3-ae95-4251-b4f8-b914d0cb3135",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
                        "fullTitle": "RulesService updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \"\" , body: \"\"};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 400);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "9e880780-5b00-4cae-98e7-d55e9547d9fe",
                        "parentUUID": "0cd041b3-ae95-4251-b4f8-b914d0cb3135",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "fullTitle": "RulesService updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b9ef09a1-5610-46f7-b448-23e2c1fa9d78",
                        "parentUUID": "0cd041b3-ae95-4251-b4f8-b914d0cb3135",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 3,
                    "totalPasses": 3,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 4,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_RulesService.js",
                "uuid": "c46605a8-04f8-45e3-8a9d-fe0b172abf82",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_RulesService.js",
            "uuid": "873a1185-3210-41a7-882c-2716baac62dc",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_RulesService.js",
        "uuid": "fecca845-f430-49f9-875b-504e3756cb4b",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_RulesService.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "STT",
            "suites": [
              {
                "title": "STTWatsonAdapter",
                "suites": [
                  {
                    "title": "speechToText",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.",
                        "fullTitle": "STTWatsonAdapter speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "failed",
                        "pass": false,
                        "fail": true,
                        "pending": false,
                        "code": "let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});",
                        "err": {
                          "estack": "TypeError: this.streamifier.createReadStream is not a function\n  at STTWatsonAdapter.speechToText (src\\Back-end\\STT\\STTWatsonAdapter.js:24:31)\n  at Context.<anonymous> (src\\test\\test_STTWatsonAdapter.js:20:27)\n"
                        },
                        "isRoot": false,
                        "uuid": "22b323e5-4414-433b-8d21-a5a8c44dac14",
                        "parentUUID": "36203f4f-132f-485a-ac03-b4b81bfda3c6",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_STTWatsonAdapter.js",
                    "uuid": "36203f4f-132f-485a-ac03-b4b81bfda3c6",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js",
                    "passes": [],
                    "failures": [
                      {
                        "title": "Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.",
                        "fullTitle": "STTWatsonAdapter speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "failed",
                        "pass": false,
                        "fail": true,
                        "pending": false,
                        "code": "let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});",
                        "err": {
                          "estack": "TypeError: this.streamifier.createReadStream is not a function\n  at STTWatsonAdapter.speechToText (src\\Back-end\\STT\\STTWatsonAdapter.js:24:31)\n  at Context.<anonymous> (src\\test\\test_STTWatsonAdapter.js:20:27)\n"
                        },
                        "isRoot": false,
                        "uuid": "22b323e5-4414-433b-8d21-a5a8c44dac14",
                        "parentUUID": "36203f4f-132f-485a-ac03-b4b81bfda3c6",
                        "skipped": false
                      }
                    ],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 0,
                    "totalFailures": 1,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": false,
                    "hasFailures": true,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 0,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_STTWatsonAdapter.js",
                "uuid": "811d0012-67db-4bca-bc0e-a4fb4cec41b7",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_STTWatsonAdapter.js",
            "uuid": "6e489e46-875c-4fb6-9530-76c0c544acdf",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_STTWatsonAdapter.js",
        "uuid": "8c9466a0-cfa2-4aa7-b9f1-9fbaf08ec1f1",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_STTWatsonAdapter.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "Tasks",
            "suites": [
              {
                "title": "TasksDAODynamoDB",
                "suites": [
                  {
                    "title": "addTask",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\"Requested resource not found\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a276b1eb-82b7-4cf5-b8a0-36d29f31be3c",
                        "parentUUID": "b9a9fc5d-6685-416d-8b86-7f1b637b3e49",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "df25eabe-4714-423f-b556-4ad97e51757e",
                        "parentUUID": "b9a9fc5d-6685-416d-8b86-7f1b637b3e49",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_TasksDAODynamoDB.js",
                    "uuid": "b9a9fc5d-6685-416d-8b86-7f1b637b3e49",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\"Requested resource not found\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a276b1eb-82b7-4cf5-b8a0-36d29f31be3c",
                        "parentUUID": "b9a9fc5d-6685-416d-8b86-7f1b637b3e49",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "TasksDAODynamoDB addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "df25eabe-4714-423f-b556-4ad97e51757e",
                        "parentUUID": "b9a9fc5d-6685-416d-8b86-7f1b637b3e49",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  },
                  {
                    "title": "getTask",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "TasksDAODynamoDB getTask Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.getTask('mock_type').subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\"error getting data\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c7ac7543-162a-4438-b32e-73661278a15e",
                        "parentUUID": "30151355-dc16-413c-a70a-47ff8e09efa5",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "TasksDAODynamoDB getTask Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let observable = tasks.getTask('mock_type');\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "7fdfd483-1ca7-442b-a53a-ed9394370f36",
                        "parentUUID": "30151355-dc16-413c-a70a-47ff8e09efa5",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_TasksDAODynamoDB.js",
                    "uuid": "30151355-dc16-413c-a70a-47ff8e09efa5",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "TasksDAODynamoDB getTask Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.getTask('mock_type').subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\"error getting data\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c7ac7543-162a-4438-b32e-73661278a15e",
                        "parentUUID": "30151355-dc16-413c-a70a-47ff8e09efa5",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "TasksDAODynamoDB getTask Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let observable = tasks.getTask('mock_type');\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "7fdfd483-1ca7-442b-a53a-ed9394370f36",
                        "parentUUID": "30151355-dc16-413c-a70a-47ff8e09efa5",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "getTaskList",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "TasksDAODynamoDB getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \"mock_type2\"});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \"mock_type3\"});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "55fbad25-7a07-4799-84b5-4272348136aa",
                        "parentUUID": "2fef8d26-d97d-4580-9522-a3ac93cb3059",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "TasksDAODynamoDB getTaskList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 8,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\"mock_type2\"});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "3b4895e9-e4ae-4490-a218-dd0021254961",
                        "parentUUID": "2fef8d26-d97d-4580-9522-a3ac93cb3059",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_TasksDAODynamoDB.js",
                    "uuid": "2fef8d26-d97d-4580-9522-a3ac93cb3059",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "TasksDAODynamoDB getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \"mock_type2\"});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \"mock_type3\"});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "55fbad25-7a07-4799-84b5-4272348136aa",
                        "parentUUID": "2fef8d26-d97d-4580-9522-a3ac93cb3059",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "TasksDAODynamoDB getTaskList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 8,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\"mock_type2\"});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "3b4895e9-e4ae-4490-a218-dd0021254961",
                        "parentUUID": "2fef8d26-d97d-4580-9522-a3ac93cb3059",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 9,
                    "rootEmpty": false
                  },
                  {
                    "title": "removeTask",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.removeTask('mock_type').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\"error removing rule\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e4ed2919-9ce3-4633-89e4-e1cd5f574a4d",
                        "parentUUID": "bdb9059f-2f29-4b41-980f-4173950eac2e",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.removeTask('mock_type').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\"success\"});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "44f04a09-2ed0-44ea-a85d-612b1b2735ad",
                        "parentUUID": "bdb9059f-2f29-4b41-980f-4173950eac2e",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_TasksDAODynamoDB.js",
                    "uuid": "bdb9059f-2f29-4b41-980f-4173950eac2e",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.removeTask('mock_type').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\"error removing rule\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e4ed2919-9ce3-4633-89e4-e1cd5f574a4d",
                        "parentUUID": "bdb9059f-2f29-4b41-980f-4173950eac2e",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "TasksDAODynamoDB removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.removeTask('mock_type').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\"success\"});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "44f04a09-2ed0-44ea-a85d-612b1b2735ad",
                        "parentUUID": "bdb9059f-2f29-4b41-980f-4173950eac2e",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "updateTask",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.updateTask('mock_type').subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\"error updating rule\"});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "ef2806e7-70c2-4af8-97f5-ff003d6baf7e",
                        "parentUUID": "23924557-8f5b-44fb-982a-9d6448e20d57",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.updateTask('mock_type').subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "885c756f-cfdc-48d1-b42c-442a960578ed",
                        "parentUUID": "23924557-8f5b-44fb-982a-9d6448e20d57",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_TasksDAODynamoDB.js",
                    "uuid": "23924557-8f5b-44fb-982a-9d6448e20d57",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.updateTask('mock_type').subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\"error updating rule\"});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "ef2806e7-70c2-4af8-97f5-ff003d6baf7e",
                        "parentUUID": "23924557-8f5b-44fb-982a-9d6448e20d57",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "TasksDAODynamoDB updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "tasks.updateTask('mock_type').subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "885c756f-cfdc-48d1-b42c-442a960578ed",
                        "parentUUID": "23924557-8f5b-44fb-982a-9d6448e20d57",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 3,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_TasksDAODynamoDB.js",
                "uuid": "fec6489f-cadc-47f3-8ebd-2b64c308b657",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_TasksDAODynamoDB.js",
            "uuid": "33ec9a50-decf-474c-8246-583b448e35e3",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_TasksDAODynamoDB.js",
        "uuid": "37f9ebb3-c668-47be-92d7-e74460e92744",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_TasksDAODynamoDB.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "Users",
            "suites": [
              {
                "title": "UsersDAODynamoDB",
                "suites": [
                  {
                    "title": "addUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui l'utente non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "UsersDAODynamoDB addUser Nel caso in cui l'utente non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.addUser('mou').subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\"Requested resource not found\"});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "83390f62-e457-4833-a4f7-363b187fc70f",
                        "parentUUID": "86e1fc1f-283c-43bb-8db0-c8a7180e4a11",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'utente sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "UsersDAODynamoDB addUser Nel caso in cui l'utente sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.addUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "1b3cc114-22b1-4b8e-b3a5-9d09c8f6ae55",
                        "parentUUID": "86e1fc1f-283c-43bb-8db0-c8a7180e4a11",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_UsersDAODynamoDB.js",
                    "uuid": "86e1fc1f-283c-43bb-8db0-c8a7180e4a11",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui l'utente non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "UsersDAODynamoDB addUser Nel caso in cui l'utente non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.addUser('mou').subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\"Requested resource not found\"});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "83390f62-e457-4833-a4f7-363b187fc70f",
                        "parentUUID": "86e1fc1f-283c-43bb-8db0-c8a7180e4a11",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'utente sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "UsersDAODynamoDB addUser Nel caso in cui l'utente sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.addUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "1b3cc114-22b1-4b8e-b3a5-9d09c8f6ae55",
                        "parentUUID": "86e1fc1f-283c-43bb-8db0-c8a7180e4a11",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "getUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "UsersDAODynamoDB getUser Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.getUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\"error getting data\"});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "5e3bf7fa-7013-490f-8e25-c75a17d65dd4",
                        "parentUUID": "5a59f620-7101-415c-bb68-753a76c4a91a",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "UsersDAODynamoDB getUser Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let observable = users.getUser('mou');\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \"mauro\", username: \"mou\"}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal('mauro');\n\t\t\t\t\texpect(callNext.args[0].username).to.equal('mou');\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "2f0b6bb3-924d-4ab8-af71-3a6c83f48e70",
                        "parentUUID": "5a59f620-7101-415c-bb68-753a76c4a91a",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_UsersDAODynamoDB.js",
                    "uuid": "5a59f620-7101-415c-bb68-753a76c4a91a",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "UsersDAODynamoDB getUser Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.getUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\"error getting data\"});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "5e3bf7fa-7013-490f-8e25-c75a17d65dd4",
                        "parentUUID": "5a59f620-7101-415c-bb68-753a76c4a91a",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "UsersDAODynamoDB getUser Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let observable = users.getUser('mou');\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \"mauro\", username: \"mou\"}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal('mauro');\n\t\t\t\t\texpect(callNext.args[0].username).to.equal('mou');\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "2f0b6bb3-924d-4ab8-af71-3a6c83f48e70",
                        "parentUUID": "5a59f620-7101-415c-bb68-753a76c4a91a",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  },
                  {
                    "title": "getUserList",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "UsersDAODynamoDB getUserList Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'piero'});\ndynamo_client.scan.yield(null, {Items: [{name: \"piero\", username: \"sun\"}], LastEvaluatedKey: 'marco'});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('piero');\nexpect(callNext.args[0].username).to.equal('sun');\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "1bafd5a7-696d-4e0a-af34-cec10d210af2",
                        "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "UsersDAODynamoDB getUserList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'piero'});\ndynamo_client.scan.yield(null, {Items: [{name: \"piero\", username: \"sun\"}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('piero');\nexpect(callNext.args[0].username).to.equal('sun');\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "06b74b70-c937-420b-a443-0405f46da7b6",
                        "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let query =\n{\n\tname: 'mauro'\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'sun'});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"sun\"}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property('FilterExpression', 'full_name = :full_name');\nexpect(callScan.args[0]).to.have.deep.property('ExpressionAttributeValues.:full_name', 'mauro' );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('sun');",
                        "err": {},
                        "isRoot": false,
                        "uuid": "899a4b20-6042-45fa-8e66-898436549096",
                        "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let query =\n{\n\tname: 'mauro',\n\tslack_channel: 'channel'\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'sun'});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"sun\"}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property('FilterExpression', 'full_name = :full_name and slack_channel = :slack_channel');\nexpect(callScan.args[0]).to.have.deep.property('ExpressionAttributeValues.:full_name', 'mauro' );\nexpect(callScan.args[0]).to.have.deep.property('ExpressionAttributeValues.:slack_channel', 'channel' );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('sun');",
                        "err": {},
                        "isRoot": false,
                        "uuid": "3795bb44-9d26-4560-9346-92c7e731a900",
                        "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_UsersDAODynamoDB.js",
                    "uuid": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "UsersDAODynamoDB getUserList Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'piero'});\ndynamo_client.scan.yield(null, {Items: [{name: \"piero\", username: \"sun\"}], LastEvaluatedKey: 'marco'});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('piero');\nexpect(callNext.args[0].username).to.equal('sun');\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "1bafd5a7-696d-4e0a-af34-cec10d210af2",
                        "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "UsersDAODynamoDB getUserList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'piero'});\ndynamo_client.scan.yield(null, {Items: [{name: \"piero\", username: \"sun\"}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('piero');\nexpect(callNext.args[0].username).to.equal('sun');\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "06b74b70-c937-420b-a443-0405f46da7b6",
                        "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let query =\n{\n\tname: 'mauro'\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'sun'});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"sun\"}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property('FilterExpression', 'full_name = :full_name');\nexpect(callScan.args[0]).to.have.deep.property('ExpressionAttributeValues.:full_name', 'mauro' );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('sun');",
                        "err": {},
                        "isRoot": false,
                        "uuid": "899a4b20-6042-45fa-8e66-898436549096",
                        "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "fullTitle": "UsersDAODynamoDB getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let query =\n{\n\tname: 'mauro',\n\tslack_channel: 'channel'\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'sun'});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"sun\"}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property('FilterExpression', 'full_name = :full_name and slack_channel = :slack_channel');\nexpect(callScan.args[0]).to.have.deep.property('ExpressionAttributeValues.:full_name', 'mauro' );\nexpect(callScan.args[0]).to.have.deep.property('ExpressionAttributeValues.:slack_channel', 'channel' );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('sun');",
                        "err": {},
                        "isRoot": false,
                        "uuid": "3795bb44-9d26-4560-9346-92c7e731a900",
                        "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 4,
                    "totalPasses": 4,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 4,
                    "rootEmpty": false
                  },
                  {
                    "title": "removeUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui l'utente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "UsersDAODynamoDB removeUser Nel caso in cui l'utente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.removeUser('mou').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \"error removing user\"});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "53ac7672-612e-4787-9785-54a42920be9d",
                        "parentUUID": "51ad4ccd-ddb6-4050-bfa8-85b53ef84e53",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'utente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta",
                        "fullTitle": "UsersDAODynamoDB removeUser Nel caso in cui l'utente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.removeUser('mou').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "37d4128b-b13b-4066-81cb-67abf9163c26",
                        "parentUUID": "51ad4ccd-ddb6-4050-bfa8-85b53ef84e53",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_UsersDAODynamoDB.js",
                    "uuid": "51ad4ccd-ddb6-4050-bfa8-85b53ef84e53",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui l'utente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "UsersDAODynamoDB removeUser Nel caso in cui l'utente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.removeUser('mou').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \"error removing user\"});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "53ac7672-612e-4787-9785-54a42920be9d",
                        "parentUUID": "51ad4ccd-ddb6-4050-bfa8-85b53ef84e53",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'utente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta",
                        "fullTitle": "UsersDAODynamoDB removeUser Nel caso in cui l'utente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.removeUser('mou').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "37d4128b-b13b-4066-81cb-67abf9163c26",
                        "parentUUID": "51ad4ccd-ddb6-4050-bfa8-85b53ef84e53",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 0,
                    "rootEmpty": false
                  },
                  {
                    "title": "updateUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui l'utente non venga modificato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "UsersDAODynamoDB updateUser Nel caso in cui l'utente non venga modificato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.updateUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \"error updating user\"});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c9d72e9b-400e-4a63-8a5a-0bb42072df45",
                        "parentUUID": "39f8b44e-228f-4e9d-b5d2-85e7338d6e56",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'utente sia modificato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "UsersDAODynamoDB updateUser Nel caso in cui l'utente sia modificato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.updateUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "6ec9eb13-06e0-4d4a-90c3-0c061c3a7032",
                        "parentUUID": "39f8b44e-228f-4e9d-b5d2-85e7338d6e56",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_UsersDAODynamoDB.js",
                    "uuid": "39f8b44e-228f-4e9d-b5d2-85e7338d6e56",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui l'utente non venga modificato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "fullTitle": "UsersDAODynamoDB updateUser Nel caso in cui l'utente non venga modificato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.updateUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \"error updating user\"});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c9d72e9b-400e-4a63-8a5a-0bb42072df45",
                        "parentUUID": "39f8b44e-228f-4e9d-b5d2-85e7338d6e56",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui l'utente sia modificato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "fullTitle": "UsersDAODynamoDB updateUser Nel caso in cui l'utente sia modificato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users.updateUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "6ec9eb13-06e0-4d4a-90c3-0c061c3a7032",
                        "parentUUID": "39f8b44e-228f-4e9d-b5d2-85e7338d6e56",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_UsersDAODynamoDB.js",
                "uuid": "52c4a239-fb71-4aae-96b8-ca472dd3375d",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_UsersDAODynamoDB.js",
            "uuid": "d3d4ad9f-d82f-4b8d-b27b-1b16dbbc10aa",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_UsersDAODynamoDB.js",
        "uuid": "ff64e286-547c-43a7-be10-1907d885f09c",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersDAODynamoDB.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "Users",
            "suites": [
              {
                "title": "UsersService",
                "suites": [
                  {
                    "title": "addUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "fullTitle": "UsersService addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \"Mauro\",\n  username: \"mou\"\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c6a2295e-ba40-4f1a-8628-cd97ae2bf1e6",
                        "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
                        "fullTitle": "UsersService addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \"Mauro\",\n  username: \"mou\"\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "5e5830df-00ce-408a-a900-ab0e9c6c0797",
                        "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
                        "fullTitle": "UsersService addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \"\" };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 400);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "4f3d3c4a-eb50-4fa1-9c1c-3d6cc2090d59",
                        "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
                        "fullTitle": "UsersService addUser Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.addUser.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\nlet user=\n{\n  name: \"Mauro\",\n  username: \"mou\"\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Conflict' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 409);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "687ee9d9-9f48-4e81-9f18-904b1bb8dca7",
                        "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_UsersService.js",
                    "uuid": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "fullTitle": "UsersService addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \"Mauro\",\n  username: \"mou\"\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c6a2295e-ba40-4f1a-8628-cd97ae2bf1e6",
                        "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
                        "fullTitle": "UsersService addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \"Mauro\",\n  username: \"mou\"\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "5e5830df-00ce-408a-a900-ab0e9c6c0797",
                        "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
                        "fullTitle": "UsersService addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \"\" };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 400);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "4f3d3c4a-eb50-4fa1-9c1c-3d6cc2090d59",
                        "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
                        "fullTitle": "UsersService addUser Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.addUser.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\nlet user=\n{\n  name: \"Mauro\",\n  username: \"mou\"\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Conflict' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 409);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "687ee9d9-9f48-4e81-9f18-904b1bb8dca7",
                        "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 4,
                    "totalPasses": 4,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  },
                  {
                    "title": "deleteUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "fullTitle": "UsersService deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: 'mou' }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "99ddf7d8-5cd8-4bb2-84bd-0931669279b1",
                        "parentUUID": "ad7d0256-dcc0-44d8-bb37-a96ec436d965",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
                        "fullTitle": "UsersService deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: 'mou' }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "40f01a52-b13e-46df-958c-0f237f509ac6",
                        "parentUUID": "ad7d0256-dcc0-44d8-bb37-a96ec436d965",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
                        "fullTitle": "UsersService deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.removeUser.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\nlet ev = { pathParameters: { username: 'pippo' }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 404);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "2a1dfcc2-b9d7-4023-ac73-f6b3783bf264",
                        "parentUUID": "ad7d0256-dcc0-44d8-bb37-a96ec436d965",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_UsersService.js",
                    "uuid": "ad7d0256-dcc0-44d8-bb37-a96ec436d965",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "fullTitle": "UsersService deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: 'mou' }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "99ddf7d8-5cd8-4bb2-84bd-0931669279b1",
                        "parentUUID": "ad7d0256-dcc0-44d8-bb37-a96ec436d965",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
                        "fullTitle": "UsersService deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: 'mou' }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "40f01a52-b13e-46df-958c-0f237f509ac6",
                        "parentUUID": "ad7d0256-dcc0-44d8-bb37-a96ec436d965",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
                        "fullTitle": "UsersService deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.removeUser.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\nlet ev = { pathParameters: { username: 'pippo' }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 404);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "2a1dfcc2-b9d7-4023-ac73-f6b3783bf264",
                        "parentUUID": "ad7d0256-dcc0-44d8-bb37-a96ec436d965",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 3,
                    "totalPasses": 3,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 3,
                    "rootEmpty": false
                  },
                  {
                    "title": "getUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "fullTitle": "UsersService getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: 'mou'} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "48db7279-31e0-4233-80ed-422f789105fb",
                        "parentUUID": "d08d3ef1-a1f7-4218-bd16-3f1f61bc779c",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l'utente richiesto",
                        "fullTitle": "UsersService getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l'utente richiesto",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.getUser.returns(Rx.Observable.of({ name : 'Mauro', username : 'mou' }));\nlet ev = { pathParameters: { username: 'mou'} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ name : 'Mauro', username : 'mou' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "3cdcaca0-379d-4a4d-9477-26e429c38528",
                        "parentUUID": "d08d3ef1-a1f7-4218-bd16-3f1f61bc779c",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
                        "fullTitle": "UsersService getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.getUser.returns(Rx.Observable.throw({ code: 'Not found' }));\n          let ev = { pathParameters: { username: 'pippo'} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 404);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "21292dce-2ca3-4f92-a8e4-b25640dd6198",
                        "parentUUID": "d08d3ef1-a1f7-4218-bd16-3f1f61bc779c",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_UsersService.js",
                    "uuid": "d08d3ef1-a1f7-4218-bd16-3f1f61bc779c",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "fullTitle": "UsersService getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: 'mou'} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "48db7279-31e0-4233-80ed-422f789105fb",
                        "parentUUID": "d08d3ef1-a1f7-4218-bd16-3f1f61bc779c",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l'utente richiesto",
                        "fullTitle": "UsersService getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l'utente richiesto",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.getUser.returns(Rx.Observable.of({ name : 'Mauro', username : 'mou' }));\nlet ev = { pathParameters: { username: 'mou'} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ name : 'Mauro', username : 'mou' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "3cdcaca0-379d-4a4d-9477-26e429c38528",
                        "parentUUID": "d08d3ef1-a1f7-4218-bd16-3f1f61bc779c",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
                        "fullTitle": "UsersService getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.getUser.returns(Rx.Observable.throw({ code: 'Not found' }));\n          let ev = { pathParameters: { username: 'pippo'} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 404);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "21292dce-2ca3-4f92-a8e4-b25640dd6198",
                        "parentUUID": "d08d3ef1-a1f7-4218-bd16-3f1f61bc779c",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 3,
                    "totalPasses": 3,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "getUserList",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "fullTitle": "UsersService getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "5aa15209-a566-4a0d-8c59-c211b9784440",
                        "parentUUID": "8b17897e-5dda-49ca-a254-e36f1ff1a75f",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti",
                        "fullTitle": "UsersService getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.getUserList.returns(Rx.Observable.of({ name : 'Mauro', username : 'mou' }, { name : 'Nicola', username : 'tinto' }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ users: [{ name : 'Mauro', username : 'mou' }, { name : 'Nicola', username : 'tinto' }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "5a430af6-5708-466b-ad31-cbeb0d6be891",
                        "parentUUID": "8b17897e-5dda-49ca-a254-e36f1ff1a75f",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_UsersService.js",
                    "uuid": "8b17897e-5dda-49ca-a254-e36f1ff1a75f",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "fullTitle": "UsersService getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "5aa15209-a566-4a0d-8c59-c211b9784440",
                        "parentUUID": "8b17897e-5dda-49ca-a254-e36f1ff1a75f",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti",
                        "fullTitle": "UsersService getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.getUserList.returns(Rx.Observable.of({ name : 'Mauro', username : 'mou' }, { name : 'Nicola', username : 'tinto' }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ users: [{ name : 'Mauro', username : 'mou' }, { name : 'Nicola', username : 'tinto' }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "5a430af6-5708-466b-ad31-cbeb0d6be891",
                        "parentUUID": "8b17897e-5dda-49ca-a254-e36f1ff1a75f",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "updateUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "fullTitle": "UsersService updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \"gianluca\"\n};\nlet ev = { pathParameters: \"mou\", body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "9047a0f8-88ea-4a42-b99b-b5fb166e8088",
                        "parentUUID": "a21d3f36-9b8f-4d52-9b6f-e3692901b11a",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
                        "fullTitle": "UsersService updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \"gianluca\"\n};\nlet ev = { pathParameters: \"mou\", body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "29eab6dc-e65b-4a60-988c-2ae9c38fd5ce",
                        "parentUUID": "a21d3f36-9b8f-4d52-9b6f-e3692901b11a",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
                        "fullTitle": "UsersService updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = { pathParameters: \"\", body: \"\" };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 400);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c5ff3096-f1c4-4306-9ff5-bc1de292eb41",
                        "parentUUID": "a21d3f36-9b8f-4d52-9b6f-e3692901b11a",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_UsersService.js",
                    "uuid": "a21d3f36-9b8f-4d52-9b6f-e3692901b11a",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "fullTitle": "UsersService updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \"gianluca\"\n};\nlet ev = { pathParameters: \"mou\", body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "9047a0f8-88ea-4a42-b99b-b5fb166e8088",
                        "parentUUID": "a21d3f36-9b8f-4d52-9b6f-e3692901b11a",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
                        "fullTitle": "UsersService updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \"gianluca\"\n};\nlet ev = { pathParameters: \"mou\", body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "29eab6dc-e65b-4a60-988c-2ae9c38fd5ce",
                        "parentUUID": "a21d3f36-9b8f-4d52-9b6f-e3692901b11a",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
                        "fullTitle": "UsersService updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let ev = { pathParameters: \"\", body: \"\" };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 400);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c5ff3096-f1c4-4306-9ff5-bc1de292eb41",
                        "parentUUID": "a21d3f36-9b8f-4d52-9b6f-e3692901b11a",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 3,
                    "totalPasses": 3,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_UsersService.js",
                "uuid": "676ff6fa-ba99-4e30-a440-9fcaabce11fe",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_UsersService.js",
            "uuid": "fdd3d3fa-f209-44ac-916a-c8082afdead0",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_UsersService.js",
        "uuid": "73a6eda2-a92f-4aff-b0cd-9092a4e514ef",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_UsersService.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "Events",
            "suites": [
              {
                "title": "VAMessageListener",
                "suites": [
                  {
                    "title": "onMessage",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "fullTitle": "VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let context = { body: '' };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
                        "err": {},
                        "isRoot": false,
                        "uuid": "75a00fd3-8b57-462e-9008-aa7ddd3176e6",
                        "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "fullTitle": "VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let context = { body: '' };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
                        "err": {},
                        "isRoot": false,
                        "uuid": "83aa1bd0-491d-421f-9292-68c4e8e53054",
                        "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "fullTitle": "VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let context = { body: '' };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { 'msg': 'error getting guest' });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e2282794-72b6-49f6-8890-7e1b7e3887f5",
                        "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "fullTitle": "VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let context = { body: '' };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ 'msg': 'error adding conversation' });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
                        "err": {},
                        "isRoot": false,
                        "uuid": "179cb7ef-cded-4f68-bb66-7b6ba42b3757",
                        "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.",
                        "fullTitle": "VAMessageListener onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let context = { body: '' };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { 'type': 'example' });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;",
                        "err": {},
                        "isRoot": false,
                        "uuid": "0175c2d2-9c56-4bf6-98f8-0fe7d399752b",
                        "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VAMessageListener.js",
                    "uuid": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js",
                    "passes": [
                      {
                        "title": "Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "fullTitle": "VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let context = { body: '' };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
                        "err": {},
                        "isRoot": false,
                        "uuid": "75a00fd3-8b57-462e-9008-aa7ddd3176e6",
                        "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "fullTitle": "VAMessageListener onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let context = { body: '' };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
                        "err": {},
                        "isRoot": false,
                        "uuid": "83aa1bd0-491d-421f-9292-68c4e8e53054",
                        "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "fullTitle": "VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let context = { body: '' };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { 'msg': 'error getting guest' });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e2282794-72b6-49f6-8890-7e1b7e3887f5",
                        "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "fullTitle": "VAMessageListener onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let context = { body: '' };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ 'msg': 'error adding conversation' });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
                        "err": {},
                        "isRoot": false,
                        "uuid": "179cb7ef-cded-4f68-bb66-7b6ba42b3757",
                        "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
                        "skipped": false
                      },
                      {
                        "title": "Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.",
                        "fullTitle": "VAMessageListener onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "let context = { body: '' };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { 'type': 'example' });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;",
                        "err": {},
                        "isRoot": false,
                        "uuid": "0175c2d2-9c56-4bf6-98f8-0fe7d399752b",
                        "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 5,
                    "totalPasses": 5,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 4,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_VAMessageListener.js",
                "uuid": "77115b9b-9e66-4c53-b3af-157cdb438921",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_VAMessageListener.js",
            "uuid": "ff3fc0d7-f036-4505-84e7-c140b9f70f81",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_VAMessageListener.js",
        "uuid": "466a8ec7-e38c-4024-83a8-5b6b9787f289",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VAMessageListener.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "VirtualAssistant",
            "suites": [
              {
                "title": "VAService",
                "suites": [
                  {
                    "title": "query",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.",
                        "fullTitle": "VAService query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.getAgent.returns(Rx.Observable.empty());\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\n          \nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith('test'));\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "26943c6b-36c1-4591-899b-99b958b8c87b",
                        "parentUUID": "16233e0a-62d6-4264-920a-636c20622f59",
                        "skipped": false
                      },
                      {
                        "title": "Se la chiamata al modulo VAModule genera un'errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.",
                        "fullTitle": "VAService query Se la chiamata al modulo VAModule genera un'errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.",
                        "timedOut": false,
                        "duration": 4,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.getAgent.returns(Rx.Observable.throw(new Error()));\n          va.query.returns(Promise.resolve(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\n          \nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "d9b71483-53e7-4d59-ae4d-5003ac406d76",
                        "parentUUID": "16233e0a-62d6-4264-920a-636c20622f59",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VAService.js",
                    "uuid": "16233e0a-62d6-4264-920a-636c20622f59",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js",
                    "passes": [
                      {
                        "title": "Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.",
                        "fullTitle": "VAService query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.getAgent.returns(Rx.Observable.empty());\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\n          \nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith('test'));\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "26943c6b-36c1-4591-899b-99b958b8c87b",
                        "parentUUID": "16233e0a-62d6-4264-920a-636c20622f59",
                        "skipped": false
                      },
                      {
                        "title": "Se la chiamata al modulo VAModule genera un'errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.",
                        "fullTitle": "VAService query Se la chiamata al modulo VAModule genera un'errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.",
                        "timedOut": false,
                        "duration": 4,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "agents.getAgent.returns(Rx.Observable.throw(new Error()));\n          va.query.returns(Promise.resolve(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\n          \nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "d9b71483-53e7-4d59-ae4d-5003ac406d76",
                        "parentUUID": "16233e0a-62d6-4264-920a-636c20622f59",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 2,
                    "totalPasses": 2,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 5,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_VAService.js",
                "uuid": "11317ef8-3581-44ba-b4d1-3992cd341c0c",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_VAService.js",
            "uuid": "da2ad268-5e57-46e7-932e-6c9ea1d3a216",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_VAService.js",
        "uuid": "ae951187-496b-4e66-b351-9e3b63411bc1",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VAService.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "APIGateway",
            "suites": [
              {
                "title": "VocalAPI",
                "suites": [
                  {
                    "title": "_addRule",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 4,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "ff6f0521-106c-4d65-bda0-c5d06f974239",
                        "parentUUID": "81cb31d0-ac2f-452c-9542-317b14c7a96e",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalAPI.js",
                    "uuid": "81cb31d0-ac2f-452c-9542-317b14c7a96e",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                    "passes": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 4,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "ff6f0521-106c-4d65-bda0-c5d06f974239",
                        "parentUUID": "81cb31d0-ac2f-452c-9542-317b14c7a96e",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 4,
                    "rootEmpty": false
                  },
                  {
                    "title": "_addUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e8fa641b-4a95-40f9-b87c-e030c2b411e7",
                        "parentUUID": "416dab94-3533-4280-9a42-f1128bc5226b",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalAPI.js",
                    "uuid": "416dab94-3533-4280-9a42-f1128bc5226b",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                    "passes": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e8fa641b-4a95-40f9-b87c-e030c2b411e7",
                        "parentUUID": "416dab94-3533-4280-9a42-f1128bc5226b",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "_addUserEnrollment",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 0,
                        "pass": false,
                        "fail": false,
                        "pending": true,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "42c8f399-1f6e-413b-888b-3d77d715c74c",
                        "parentUUID": "aa13c3d7-9425-4cda-863f-00de49e521f3",
                        "skipped": false
                      }
                    ],
                    "pending": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 0,
                        "pass": false,
                        "fail": false,
                        "pending": true,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "42c8f399-1f6e-413b-888b-3d77d715c74c",
                        "parentUUID": "aa13c3d7-9425-4cda-863f-00de49e521f3",
                        "skipped": false
                      }
                    ],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalAPI.js",
                    "uuid": "aa13c3d7-9425-4cda-863f-00de49e521f3",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                    "passes": [],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 0,
                    "totalFailures": 0,
                    "totalPending": 1,
                    "totalSkipped": 0,
                    "hasPasses": false,
                    "hasFailures": false,
                    "hasPending": true,
                    "hasSkipped": false,
                    "duration": 0,
                    "rootEmpty": false
                  },
                  {
                    "title": "_getRule",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "failed",
                        "pass": false,
                        "fail": true,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {
                          "estack": "ReferenceError: S_SERVICE_URL is not defined\n  at Observable._subscribe (src\\Back-end\\APIGateway\\VocalAPI.js:134:13)\n  at Observable._trySubscribe (node_modules\\rxjs\\Observable.js:57:25)\n  at Observable.subscribe (node_modules\\rxjs\\Observable.js:45:27)\n  at Context.<anonymous> (src\\test\\test_VocalAPI.js:86:22)\n"
                        },
                        "isRoot": false,
                        "uuid": "bc261c7c-9476-4010-894b-2b668a7e529b",
                        "parentUUID": "73e77d55-28dd-48e5-9c30-d906ccab88dc",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalAPI.js",
                    "uuid": "73e77d55-28dd-48e5-9c30-d906ccab88dc",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                    "passes": [],
                    "failures": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "failed",
                        "pass": false,
                        "fail": true,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {
                          "estack": "ReferenceError: S_SERVICE_URL is not defined\n  at Observable._subscribe (src\\Back-end\\APIGateway\\VocalAPI.js:134:13)\n  at Observable._trySubscribe (node_modules\\rxjs\\Observable.js:57:25)\n  at Observable.subscribe (node_modules\\rxjs\\Observable.js:45:27)\n  at Context.<anonymous> (src\\test\\test_VocalAPI.js:86:22)\n"
                        },
                        "isRoot": false,
                        "uuid": "bc261c7c-9476-4010-894b-2b668a7e529b",
                        "parentUUID": "73e77d55-28dd-48e5-9c30-d906ccab88dc",
                        "skipped": false
                      }
                    ],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 0,
                    "totalFailures": 1,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": false,
                    "hasFailures": true,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  },
                  {
                    "title": "_getRuleList",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "cf3616ad-feba-4d3d-a924-05d5b2fe7956",
                        "parentUUID": "4108b2b3-b97a-49fe-81b0-8e39c54a421e",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalAPI.js",
                    "uuid": "4108b2b3-b97a-49fe-81b0-8e39c54a421e",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                    "passes": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "cf3616ad-feba-4d3d-a924-05d5b2fe7956",
                        "parentUUID": "4108b2b3-b97a-49fe-81b0-8e39c54a421e",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "_getUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._getUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "595d8437-7df9-43b7-b580-c051c833926b",
                        "parentUUID": "e59073d2-5134-4fc2-9749-afa301669c38",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalAPI.js",
                    "uuid": "e59073d2-5134-4fc2-9749-afa301669c38",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                    "passes": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._getUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "595d8437-7df9-43b7-b580-c051c833926b",
                        "parentUUID": "e59073d2-5134-4fc2-9749-afa301669c38",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "_getUserList",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 3,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "6949a687-3043-46b4-9332-b074e13746b4",
                        "parentUUID": "e771685a-9cdb-456c-890c-c6b9273d9487",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalAPI.js",
                    "uuid": "e771685a-9cdb-456c-890c-c6b9273d9487",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                    "passes": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 3,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "6949a687-3043-46b4-9332-b074e13746b4",
                        "parentUUID": "e771685a-9cdb-456c-890c-c6b9273d9487",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 3,
                    "rootEmpty": false
                  },
                  {
                    "title": "_loginUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.",
                        "fullTitle": "VocalAPI _loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.",
                        "timedOut": false,
                        "duration": 0,
                        "pass": false,
                        "fail": false,
                        "pending": true,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "9ed801cb-e267-425a-8e43-46633582053b",
                        "parentUUID": "1540a04f-0422-4415-b1c6-682f1ad01a7c",
                        "skipped": false
                      }
                    ],
                    "pending": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.",
                        "fullTitle": "VocalAPI _loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.",
                        "timedOut": false,
                        "duration": 0,
                        "pass": false,
                        "fail": false,
                        "pending": true,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "9ed801cb-e267-425a-8e43-46633582053b",
                        "parentUUID": "1540a04f-0422-4415-b1c6-682f1ad01a7c",
                        "skipped": false
                      }
                    ],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalAPI.js",
                    "uuid": "1540a04f-0422-4415-b1c6-682f1ad01a7c",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                    "passes": [],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 0,
                    "totalFailures": 0,
                    "totalPending": 1,
                    "totalSkipped": 0,
                    "hasPasses": false,
                    "hasFailures": false,
                    "hasPending": true,
                    "hasSkipped": false,
                    "duration": 0,
                    "rootEmpty": false
                  },
                  {
                    "title": "queryLambda",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.",
                        "fullTitle": "VocalAPI queryLambda Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "583e7901-d1c5-4fe4-86b9-13d4a3ce203e",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se lo status della risposta ricevuta dall'assistente virtuale  diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio 'Errore nel contattare l'assistente virtuale'.",
                        "fullTitle": "VocalAPI queryLambda Se lo status della risposta ricevuta dall'assistente virtuale  diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio 'Errore nel contattare l'assistente virtuale'.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "949b81aa-ddc8-4a4b-9190-bf18e33e54b8",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'rule.add' allora il metodo deve chiamare il metodo privato _addRule.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'rule.add' allora il metodo deve chiamare il metodo privato _addRule.",
                        "timedOut": false,
                        "duration": 7,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve('Test'));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "5e9f7648-3fe4-4443-935a-310e61ed678d",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.add' allora il metodo deve chiamare il metodo privato _addUser.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.add' allora il metodo deve chiamare il metodo privato _addUser.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "fbfd4f11-e04a-4dec-842b-95869763f778",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.addEnrollment' allora il metodo deve chiamare il metodo privato _addUserEnrollment.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.addEnrollment' allora il metodo deve chiamare il metodo privato _addUserEnrollment.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "658c3032-e0e4-4dc1-8542-7cc206941890",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'rule.get' allora il metodo deve chiamare il metodo privato _getRule.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'rule.get' allora il metodo deve chiamare il metodo privato _getRule.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "988b12cf-c46e-4b5a-a5da-a9fbe4835a1c",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'rule.getList' allora il metodo deve chiamare il metodo privato _getRuleList.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'rule.getList' allora il metodo deve chiamare il metodo privato _getRuleList.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "99a7d5ec-e2ec-400c-a26a-daff2c3dff09",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.get' allora il metodo deve chiamare il metodo privato _getUser.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.get' allora il metodo deve chiamare il metodo privato _getUser.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "9848483b-ab68-4ab3-8c39-1d3c32a3e85c",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.getList' allora il metodo deve chiamare il metodo privato _getUserList.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.getList' allora il metodo deve chiamare il metodo privato _getUserList.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e3612547-bc6e-4334-96da-90a503de5759",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.login' allora il metodo deve chiamare il metodo privato _loginUser.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.login' allora il metodo deve chiamare il metodo privato _loginUser.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "5b91c259-8079-4a76-99fb-9529861bb57d",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'rule.remove' allora il metodo deve chiamare il metodo privato _removeRule.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'rule.remove' allora il metodo deve chiamare il metodo privato _removeRule.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "ae28f2fb-1c74-4d56-82bd-09249f9b2944",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.remove' allora il metodo deve chiamare il metodo privato _removeUser.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.remove' allora il metodo deve chiamare il metodo privato _removeUser.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "38e2757e-47bb-455b-9a16-1723dc95bf89",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.resetEnrollment' allora il metodo deve chiamare il metodo privato _resetUserEnrollment.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.resetEnrollment' allora il metodo deve chiamare il metodo privato _resetUserEnrollment.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "5628ba86-dfbb-4ec3-82cc-862f9278dea1",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'rule.update' allora il metodo deve chiamare il metodo privato _updateRule.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'rule.update' allora il metodo deve chiamare il metodo privato _updateRule.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "9a22581d-2dfd-4374-98b3-362d4b0b256d",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.update' allora il metodo deve chiamare il metodo privato _updateUser.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.update' allora il metodo deve chiamare il metodo privato _updateUser.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c61a2eb0-32b2-4732-8d7e-71d6cc7b7638",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e0bd704a-494b-4da0-a41f-99de192dd690",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c234ea6e-6bb8-4f6c-984a-a39dd5e2b1b9",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "d1fc3c08-6c09-41f8-a3b5-d07a45e7b0b1",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "7423b8fd-e8d0-4730-90de-d2721997f836",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "0772f537-14b1-4030-9411-25348fbdff5a",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "14258172-9f19-4a1b-baac-21b069dcc2d4",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a956bd2d-27e0-43f7-81ec-0ab80c76e493",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a714bccc-015e-4d59-b048-057d5673c136",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "7b9c9419-6ac0-4782-8632-db65abea1178",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "acbe1440-eb09-41d4-b0d9-4871d25b7da6",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e59430c7-587a-4d1c-9a5e-fcc8762e82f8",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "36389c3d-9499-4aed-9a58-447f8e5c9716",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b9edd18e-a431-40d4-854d-7ca53cb20232",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari allo status dell'errore.",
                        "fullTitle": "VocalAPI queryLambda Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari allo status dell'errore.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "720adc5e-2640-4ce2-96cf-be140b0c6f25",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se lo status code della risposta di un microservizio  pari a 200 e l'action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.",
                        "fullTitle": "VocalAPI queryLambda Se lo status code della risposta di un microservizio  pari a 200 e l'action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e3948158-affd-4224-9e83-0149050d04c1",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalAPI.js",
                    "uuid": "ebbc15d4-867c-475c-9353-0fefb7514069",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                    "passes": [
                      {
                        "title": "Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.",
                        "fullTitle": "VocalAPI queryLambda Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "583e7901-d1c5-4fe4-86b9-13d4a3ce203e",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se lo status della risposta ricevuta dall'assistente virtuale  diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio 'Errore nel contattare l'assistente virtuale'.",
                        "fullTitle": "VocalAPI queryLambda Se lo status della risposta ricevuta dall'assistente virtuale  diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio 'Errore nel contattare l'assistente virtuale'.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "949b81aa-ddc8-4a4b-9190-bf18e33e54b8",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'rule.add' allora il metodo deve chiamare il metodo privato _addRule.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'rule.add' allora il metodo deve chiamare il metodo privato _addRule.",
                        "timedOut": false,
                        "duration": 7,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve('Test'));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);",
                        "err": {},
                        "isRoot": false,
                        "uuid": "5e9f7648-3fe4-4443-935a-310e61ed678d",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.add' allora il metodo deve chiamare il metodo privato _addUser.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.add' allora il metodo deve chiamare il metodo privato _addUser.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "fbfd4f11-e04a-4dec-842b-95869763f778",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.addEnrollment' allora il metodo deve chiamare il metodo privato _addUserEnrollment.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.addEnrollment' allora il metodo deve chiamare il metodo privato _addUserEnrollment.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "658c3032-e0e4-4dc1-8542-7cc206941890",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'rule.get' allora il metodo deve chiamare il metodo privato _getRule.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'rule.get' allora il metodo deve chiamare il metodo privato _getRule.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "988b12cf-c46e-4b5a-a5da-a9fbe4835a1c",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'rule.getList' allora il metodo deve chiamare il metodo privato _getRuleList.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'rule.getList' allora il metodo deve chiamare il metodo privato _getRuleList.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "99a7d5ec-e2ec-400c-a26a-daff2c3dff09",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.get' allora il metodo deve chiamare il metodo privato _getUser.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.get' allora il metodo deve chiamare il metodo privato _getUser.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "9848483b-ab68-4ab3-8c39-1d3c32a3e85c",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.getList' allora il metodo deve chiamare il metodo privato _getUserList.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.getList' allora il metodo deve chiamare il metodo privato _getUserList.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e3612547-bc6e-4334-96da-90a503de5759",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.login' allora il metodo deve chiamare il metodo privato _loginUser.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.login' allora il metodo deve chiamare il metodo privato _loginUser.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "5b91c259-8079-4a76-99fb-9529861bb57d",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'rule.remove' allora il metodo deve chiamare il metodo privato _removeRule.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'rule.remove' allora il metodo deve chiamare il metodo privato _removeRule.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "ae28f2fb-1c74-4d56-82bd-09249f9b2944",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.remove' allora il metodo deve chiamare il metodo privato _removeUser.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.remove' allora il metodo deve chiamare il metodo privato _removeUser.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "38e2757e-47bb-455b-9a16-1723dc95bf89",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.resetEnrollment' allora il metodo deve chiamare il metodo privato _resetUserEnrollment.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.resetEnrollment' allora il metodo deve chiamare il metodo privato _resetUserEnrollment.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "5628ba86-dfbb-4ec3-82cc-862f9278dea1",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'rule.update' allora il metodo deve chiamare il metodo privato _updateRule.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'rule.update' allora il metodo deve chiamare il metodo privato _updateRule.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "9a22581d-2dfd-4374-98b3-362d4b0b256d",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se l'action del body della risposta  uguale a 'user.update' allora il metodo deve chiamare il metodo privato _updateUser.",
                        "fullTitle": "VocalAPI queryLambda Se l'action del body della risposta  uguale a 'user.update' allora il metodo deve chiamare il metodo privato _updateUser.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c61a2eb0-32b2-4732-8d7e-71d6cc7b7638",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e0bd704a-494b-4da0-a41f-99de192dd690",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "c234ea6e-6bb8-4f6c-984a-a39dd5e2b1b9",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "d1fc3c08-6c09-41f8-a3b5-d07a45e7b0b1",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "7423b8fd-e8d0-4730-90de-d2721997f836",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "0772f537-14b1-4030-9411-25348fbdff5a",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "14258172-9f19-4a1b-baac-21b069dcc2d4",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a956bd2d-27e0-43f7-81ec-0ab80c76e493",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "a714bccc-015e-4d59-b048-057d5673c136",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "7b9c9419-6ac0-4782-8632-db65abea1178",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "acbe1440-eb09-41d4-b0d9-4871d25b7da6",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e59430c7-587a-4d1c-9a5e-fcc8762e82f8",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "36389c3d-9499-4aed-9a58-447f8e5c9716",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "fullTitle": "VocalAPI queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "b9edd18e-a431-40d4-854d-7ca53cb20232",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari allo status dell'errore.",
                        "fullTitle": "VocalAPI queryLambda Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari allo status dell'errore.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "720adc5e-2640-4ce2-96cf-be140b0c6f25",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      },
                      {
                        "title": "Se lo status code della risposta di un microservizio  pari a 200 e l'action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.",
                        "fullTitle": "VocalAPI queryLambda Se lo status code della risposta di un microservizio  pari a 200 e l'action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.",
                        "timedOut": false,
                        "duration": 0,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e3948158-affd-4224-9e83-0149050d04c1",
                        "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 30,
                    "totalPasses": 30,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 8,
                    "rootEmpty": false
                  },
                  {
                    "title": "_removeRule",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "141f4f30-4ff7-4c7f-b728-6851abbb3d37",
                        "parentUUID": "7c914302-e6ad-49e8-9771-b1b677d0f05e",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalAPI.js",
                    "uuid": "7c914302-e6ad-49e8-9771-b1b677d0f05e",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                    "passes": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "141f4f30-4ff7-4c7f-b728-6851abbb3d37",
                        "parentUUID": "7c914302-e6ad-49e8-9771-b1b677d0f05e",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "_removeUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 3,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._removeUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "daf11510-401b-413e-bd1f-76e05f6de872",
                        "parentUUID": "0a9e3709-fc73-4f47-8ae2-1aad8bc3420c",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalAPI.js",
                    "uuid": "0a9e3709-fc73-4f47-8ae2-1aad8bc3420c",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                    "passes": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 3,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._removeUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "daf11510-401b-413e-bd1f-76e05f6de872",
                        "parentUUID": "0a9e3709-fc73-4f47-8ae2-1aad8bc3420c",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 3,
                    "rootEmpty": false
                  },
                  {
                    "title": "_resetUserEnrollment",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 0,
                        "pass": false,
                        "fail": false,
                        "pending": true,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "3ea7b78f-845c-480d-91ed-35640b99ea92",
                        "parentUUID": "b816b55e-6cc7-4746-84dc-e8665fe5109f",
                        "skipped": false
                      }
                    ],
                    "pending": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 0,
                        "pass": false,
                        "fail": false,
                        "pending": true,
                        "code": "",
                        "err": {},
                        "isRoot": false,
                        "uuid": "3ea7b78f-845c-480d-91ed-35640b99ea92",
                        "parentUUID": "b816b55e-6cc7-4746-84dc-e8665fe5109f",
                        "skipped": false
                      }
                    ],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalAPI.js",
                    "uuid": "b816b55e-6cc7-4746-84dc-e8665fe5109f",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                    "passes": [],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 0,
                    "totalFailures": 0,
                    "totalPending": 1,
                    "totalSkipped": 0,
                    "hasPasses": false,
                    "hasFailures": false,
                    "hasPending": true,
                    "hasSkipped": false,
                    "duration": 0,
                    "rootEmpty": false
                  },
                  {
                    "title": "_updateRule",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e07a3412-7087-4174-871c-352e867b8043",
                        "parentUUID": "9db1915e-bb37-4e6e-b8a6-3d12d3a3d7ab",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalAPI.js",
                    "uuid": "9db1915e-bb37-4e6e-b8a6-3d12d3a3d7ab",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                    "passes": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "e07a3412-7087-4174-871c-352e867b8043",
                        "parentUUID": "9db1915e-bb37-4e6e-b8a6-3d12d3a3d7ab",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "_updateUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 4,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "70747eb8-1151-4d2c-9b3c-0786fd2e5fb7",
                        "parentUUID": "70b2ad21-56e9-49de-b504-81d363cdefc5",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalAPI.js",
                    "uuid": "70b2ad21-56e9-49de-b504-81d363cdefc5",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                    "passes": [
                      {
                        "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "fullTitle": "VocalAPI _updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
                        "timedOut": false,
                        "duration": 4,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "70747eb8-1151-4d2c-9b3c-0786fd2e5fb7",
                        "parentUUID": "70b2ad21-56e9-49de-b504-81d363cdefc5",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 4,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_VocalAPI.js",
                "uuid": "48f3dcb7-c58f-4510-a8dc-453fa32e1655",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_VocalAPI.js",
            "uuid": "030cadb1-ef16-4590-ae2b-914e0603b7b9",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_VocalAPI.js",
        "uuid": "1442d7ac-c0bf-4733-88e2-916a71288ac4",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalAPI.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      },
      {
        "title": "Back-end",
        "suites": [
          {
            "title": "Users",
            "suites": [
              {
                "title": "VocalLoginMicrosoftModule",
                "suites": [
                  {
                    "title": "addEnrollment",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "fullTitle": "VocalLoginMicrosoftModule addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 3,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "7a7e915c-e835-4785-9a96-b0cc37d8970f",
                        "parentUUID": "5915b3d6-0198-4526-980a-b013aa879e1a",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalLoginMicrosoftModule.js",
                    "uuid": "5915b3d6-0198-4526-980a-b013aa879e1a",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js",
                    "passes": [
                      {
                        "title": "Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "fullTitle": "VocalLoginMicrosoftModule addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 3,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});",
                        "err": {},
                        "isRoot": false,
                        "uuid": "7a7e915c-e835-4785-9a96-b0cc37d8970f",
                        "parentUUID": "5915b3d6-0198-4526-980a-b013aa879e1a",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 3,
                    "rootEmpty": false
                  },
                  {
                    "title": "createUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.",
                        "fullTitle": "VocalLoginMicrosoftModule createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
                        "err": {},
                        "isRoot": false,
                        "uuid": "eccb4a39-962a-4f3a-a6f8-e86589269f4a",
                        "parentUUID": "8289f800-d2cf-473a-9c24-d259725382c5",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalLoginMicrosoftModule.js",
                    "uuid": "8289f800-d2cf-473a-9c24-d259725382c5",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js",
                    "passes": [
                      {
                        "title": "Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.",
                        "fullTitle": "VocalLoginMicrosoftModule createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 1,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
                        "err": {},
                        "isRoot": false,
                        "uuid": "eccb4a39-962a-4f3a-a6f8-e86589269f4a",
                        "parentUUID": "8289f800-d2cf-473a-9c24-d259725382c5",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 1,
                    "rootEmpty": false
                  },
                  {
                    "title": "deleteUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "fullTitle": "VocalLoginMicrosoftModule deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
                        "err": {},
                        "isRoot": false,
                        "uuid": "cf0cf000-146e-4040-86cf-061a2850ddb6",
                        "parentUUID": "b296dfee-7cb9-4158-acb4-82698071dff8",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalLoginMicrosoftModule.js",
                    "uuid": "b296dfee-7cb9-4158-acb4-82698071dff8",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js",
                    "passes": [
                      {
                        "title": "Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "fullTitle": "VocalLoginMicrosoftModule deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
                        "err": {},
                        "isRoot": false,
                        "uuid": "cf0cf000-146e-4040-86cf-061a2850ddb6",
                        "parentUUID": "b296dfee-7cb9-4158-acb4-82698071dff8",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "doLogin",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo 'result' pari a 'Reject', l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "fullTitle": "VocalLoginMicrosoftModule doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo 'result' pari a 'Reject', l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject({ \"result\" : \"Reject\" }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
                        "err": {},
                        "isRoot": false,
                        "uuid": "2476e090-845f-47c9-b8ec-3e8cb74da2fb",
                        "parentUUID": "990aebc1-8494-46d3-9123-236660e612ca",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalLoginMicrosoftModule.js",
                    "uuid": "990aebc1-8494-46d3-9123-236660e612ca",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js",
                    "passes": [
                      {
                        "title": "Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo 'result' pari a 'Reject', l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "fullTitle": "VocalLoginMicrosoftModule doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo 'result' pari a 'Reject', l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject({ \"result\" : \"Reject\" }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
                        "err": {},
                        "isRoot": false,
                        "uuid": "2476e090-845f-47c9-b8ec-3e8cb74da2fb",
                        "parentUUID": "990aebc1-8494-46d3-9123-236660e612ca",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "getList",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
                        "fullTitle": "VocalLoginMicrosoftModule getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
                        "err": {},
                        "isRoot": false,
                        "uuid": "6d2b6082-9fb3-4105-97de-dc3038e560dd",
                        "parentUUID": "0a551883-894e-47c9-8981-ab12e485d5e2",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalLoginMicrosoftModule.js",
                    "uuid": "0a551883-894e-47c9-8981-ab12e485d5e2",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js",
                    "passes": [
                      {
                        "title": "Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
                        "fullTitle": "VocalLoginMicrosoftModule getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
                        "err": {},
                        "isRoot": false,
                        "uuid": "6d2b6082-9fb3-4105-97de-dc3038e560dd",
                        "parentUUID": "0a551883-894e-47c9-8981-ab12e485d5e2",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "getUser",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
                        "fullTitle": "VocalLoginMicrosoftModule getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(\n  {\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
                        "err": {},
                        "isRoot": false,
                        "uuid": "27cc3c17-0123-49d7-9d5d-6ea8e226ae0b",
                        "parentUUID": "2035d6cd-adc3-4ff2-9ec0-b2aafe8cd5fb",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalLoginMicrosoftModule.js",
                    "uuid": "2035d6cd-adc3-4ff2-9ec0-b2aafe8cd5fb",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js",
                    "passes": [
                      {
                        "title": "Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
                        "fullTitle": "VocalLoginMicrosoftModule getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(\n  {\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
                        "err": {},
                        "isRoot": false,
                        "uuid": "27cc3c17-0123-49d7-9d5d-6ea8e226ae0b",
                        "parentUUID": "2035d6cd-adc3-4ff2-9ec0-b2aafe8cd5fb",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  },
                  {
                    "title": "resetEnrollment",
                    "suites": [],
                    "tests": [
                      {
                        "title": "Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "fullTitle": "VocalLoginMicrosoftModule resetEnrollment Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.resetEnrollment().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
                        "err": {},
                        "isRoot": false,
                        "uuid": "ae6b267d-a925-46f4-a76b-a6ed8e2aa5b0",
                        "parentUUID": "5b90d4b3-27c9-48b5-aa79-aaade1225681",
                        "skipped": false
                      }
                    ],
                    "pending": [],
                    "root": false,
                    "_timeout": 2000,
                    "file": "\\src\\test\\test_VocalLoginMicrosoftModule.js",
                    "uuid": "5b90d4b3-27c9-48b5-aa79-aaade1225681",
                    "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js",
                    "passes": [
                      {
                        "title": "Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "fullTitle": "VocalLoginMicrosoftModule resetEnrollment Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
                        "timedOut": false,
                        "duration": 2,
                        "state": "passed",
                        "speed": "fast",
                        "pass": true,
                        "fail": false,
                        "pending": false,
                        "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.resetEnrollment().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
                        "err": {},
                        "isRoot": false,
                        "uuid": "ae6b267d-a925-46f4-a76b-a6ed8e2aa5b0",
                        "parentUUID": "5b90d4b3-27c9-48b5-aa79-aaade1225681",
                        "skipped": false
                      }
                    ],
                    "failures": [],
                    "skipped": [],
                    "hasTests": true,
                    "hasSuites": false,
                    "totalTests": 1,
                    "totalPasses": 1,
                    "totalFailures": 0,
                    "totalPending": 0,
                    "totalSkipped": 0,
                    "hasPasses": true,
                    "hasFailures": false,
                    "hasPending": false,
                    "hasSkipped": false,
                    "duration": 2,
                    "rootEmpty": false
                  }
                ],
                "tests": [],
                "pending": [],
                "root": false,
                "_timeout": 2000,
                "file": "\\src\\test\\test_VocalLoginMicrosoftModule.js",
                "uuid": "61695bd5-6e95-4cec-860e-e325cc0c63b7",
                "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js",
                "passes": [],
                "failures": [],
                "skipped": [],
                "hasTests": false,
                "hasSuites": true,
                "totalTests": 0,
                "totalPasses": 0,
                "totalFailures": 0,
                "totalPending": 0,
                "totalSkipped": 0,
                "hasPasses": false,
                "hasFailures": false,
                "hasPending": false,
                "hasSkipped": false,
                "duration": 0,
                "rootEmpty": false
              }
            ],
            "tests": [],
            "pending": [],
            "root": false,
            "_timeout": 2000,
            "file": "\\src\\test\\test_VocalLoginMicrosoftModule.js",
            "uuid": "3844218f-08e7-4d4b-b65b-1fe0594616fa",
            "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js",
            "passes": [],
            "failures": [],
            "skipped": [],
            "hasTests": false,
            "hasSuites": true,
            "totalTests": 0,
            "totalPasses": 0,
            "totalFailures": 0,
            "totalPending": 0,
            "totalSkipped": 0,
            "hasPasses": false,
            "hasFailures": false,
            "hasPending": false,
            "hasSkipped": false,
            "duration": 0,
            "rootEmpty": false
          }
        ],
        "tests": [],
        "pending": [],
        "root": false,
        "_timeout": 2000,
        "file": "\\src\\test\\test_VocalLoginMicrosoftModule.js",
        "uuid": "2de3ca40-7206-4d22-bdd0-51cd837cc5c7",
        "fullFile": "H:\\src\\git\\AtAVi\\src\\test\\test_VocalLoginMicrosoftModule.js",
        "passes": [],
        "failures": [],
        "skipped": [],
        "hasTests": false,
        "hasSuites": true,
        "totalTests": 0,
        "totalPasses": 0,
        "totalFailures": 0,
        "totalPending": 0,
        "totalSkipped": 0,
        "hasPasses": false,
        "hasFailures": false,
        "hasPending": false,
        "hasSkipped": false,
        "duration": 0,
        "rootEmpty": false
      }
    ],
    "tests": [],
    "pending": [],
    "root": true,
    "_timeout": 2000,
    "uuid": "1f1216ff-e9ff-4757-9332-6d9a7f24bccd",
    "fullFile": "",
    "file": "",
    "passes": [],
    "failures": [],
    "skipped": [],
    "hasTests": false,
    "hasSuites": true,
    "totalTests": 0,
    "totalPasses": 0,
    "totalFailures": 0,
    "totalPending": 0,
    "totalSkipped": 0,
    "hasPasses": false,
    "hasFailures": false,
    "hasPending": false,
    "hasSkipped": false,
    "duration": 0,
    "rootEmpty": true
  },
  "allTests": [
    {
      "title": "La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.",
      "fullTitle": "webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.",
      "timedOut": false,
      "duration": 1,
      "state": "failed",
      "pass": false,
      "fail": true,
      "pending": false,
      "code": "jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});",
      "err": {
        "estack": "TypeError: service.webhook is not a function\n  at Context.<anonymous> (src\\test\\test_AdministrationWebhookService.js:72:17)\n"
      },
      "isRoot": false,
      "uuid": "f58b050b-acad-45a7-810c-408e8eb9b8f7",
      "parentUUID": "49cbbc3d-5775-435f-943e-eb1fc7b9224c",
      "skipped": false
    },
    {
      "title": "La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.",
      "fullTitle": "webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.",
      "timedOut": false,
      "duration": 1,
      "state": "failed",
      "pass": false,
      "fail": true,
      "pending": false,
      "code": "jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});",
      "err": {
        "estack": "TypeError: service.webhook is not a function\n  at Context.<anonymous> (src\\test\\test_AdministrationWebhookService.js:78:17)\n"
      },
      "isRoot": false,
      "uuid": "aeb5ec22-81aa-4ffd-9170-3799ac0938cb",
      "parentUUID": "49cbbc3d-5775-435f-943e-eb1fc7b9224c",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un agente di api.ai non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 3,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\"Requested resource not found\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);",
      "err": {},
      "isRoot": false,
      "uuid": "26893fa7-e651-42e7-92f1-173f4472299f",
      "parentUUID": "4fadae18-f59d-4696-9466-88a623668476",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un agente di api.ai sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "b11d5fe2-9618-48a1-ac3c-d1de960468a8",
      "parentUUID": "4fadae18-f59d-4696-9466-88a623668476",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getAgent Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.getAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\"error getting data\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
      "err": {},
      "isRoot": false,
      "uuid": "856587bf-b8e7-4410-b05a-83c006314f6b",
      "parentUUID": "daf9c8b0-1de6-402d-b18c-33d6de82bff2",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getAgent Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let observable = agents.getAgent('mock_name');\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "0deff0df-a3f9-4cc6-93c8-f36b7338c239",
      "parentUUID": "daf9c8b0-1de6-402d-b18c-33d6de82bff2",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un blocco di agenti non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: '1'});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: '2'});\ndynamo_client.scan.yield({statusCode:500, msg:\"error getting data\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
      "err": {},
      "isRoot": false,
      "uuid": "9d868356-eaf9-48b4-bc4c-88c7dc0c9e6b",
      "parentUUID": "a54c675d-d666-4ec5-a70f-d3516c0421af",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getAgentList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: '1'});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "65aa7f88-a829-4ca3-8cc0-dae56dbeba01",
      "parentUUID": "a54c675d-d666-4ec5-a70f-d3516c0421af",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un agente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "removeAgent Nel caso in cui un agente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.removeAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\"error removing rule\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
      "err": {},
      "isRoot": false,
      "uuid": "1fc29d68-afe7-4b8f-827b-0b323e0c5d21",
      "parentUUID": "6b8bbdc1-e9e9-4838-b66e-beb284a0abcc",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un agente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "removeAgent Nel caso in cui un agente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.removeAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\"success\"});\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "04b81d03-22dd-487d-8f98-efce46540105",
      "parentUUID": "6b8bbdc1-e9e9-4838-b66e-beb284a0abcc",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un agente non venga aggiornato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "updateAgent Nel caso in cui un agente non venga aggiornato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 5,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.updateAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\"error updating rule\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
      "err": {},
      "isRoot": false,
      "uuid": "dc87add1-fdf1-4105-904b-47fdea8ed1ad",
      "parentUUID": "a0505902-4fbc-4a5e-9c0c-069857597be8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un agente sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "updateAgent Nel caso in cui un agente sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.updateAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "1d95d735-3753-4663-873a-33c773cc1f8d",
      "parentUUID": "a0505902-4fbc-4a5e-9c0c-069857597be8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell'assistente virtuale",
      "fullTitle": "query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell'assistente virtuale",
      "timedOut": false,
      "duration": 3,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);",
      "err": {},
      "isRoot": false,
      "uuid": "6b34d0de-0aab-4944-a581-7b6f18c3debd",
      "parentUUID": "0b68480d-7356-4390-9948-55a582959fa7",
      "skipped": false
    },
    {
      "title": "Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta",
      "fullTitle": "query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});",
      "err": {},
      "isRoot": false,
      "uuid": "e5143ea9-b3c4-4887-b44c-8a3bc38714f5",
      "parentUUID": "0b68480d-7356-4390-9948-55a582959fa7",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \"Requested resource not found\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "f31c3da8-32ae-468c-9332-f60891c0c84a",
      "parentUUID": "e4157c33-a462-4114-b13f-076e7a145fbc",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una conversazione sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell' Observer iscritto un'unica volta.",
      "fullTitle": "addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell' Observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "a94ebceb-2e3d-4a39-a1db-71b22479cea6",
      "parentUUID": "e4157c33-a462-4114-b13f-076e7a145fbc",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.addMessage({sender:'mock_sender',text: 'mock_text', timestamp: '2000-10-10'},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \"error adding message\" });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "4fb15a05-eec8-4faa-9581-e6ad1ad68f1b",
      "parentUUID": "47cc6cad-3104-486a-acbb-5dd29ade298c",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "fullTitle": "addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.addMessage({sender:'mock_sender',text: 'mock_text', timestamp: '2000-10-10'},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "45b408c3-af72-43eb-85b2-a04352e35534",
      "parentUUID": "47cc6cad-3104-486a-acbb-5dd29ade298c",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \"error downloading conversation\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "d64e5096-b768-4109-8f0b-55268a1aab9e",
      "parentUUID": "d4754cff-a4d4-4fae-85f9-670b5909d980",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "fullTitle": "getConversation Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "59195ec3-8a3f-41df-a427-f314b34eebf9",
      "parentUUID": "d4754cff-a4d4-4fae-85f9-670b5909d980",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un blocco di conversazioni non venga restituito a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "7c39be02-44b1-4b5a-a683-ef0cd1396cf4",
      "parentUUID": "e430a129-ab3c-476d-9af1-d96840e155e8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "fullTitle": "getConversationList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "b0714c38-aaf1-49eb-9638-08393df3a4a5",
      "parentUUID": "e430a129-ab3c-476d-9af1-d96840e155e8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \"error removing conversation\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "7d38a74b-deb5-4ad3-95ab-46e7b1a6ae9e",
      "parentUUID": "b9275f54-5a82-49df-b283-cce9d5a9beb3",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una conversazione sia eliminata correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "fullTitle": "removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \"success\" });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "b4e04b39-2d53-4374-824d-77b9d236e686",
      "parentUUID": "b9275f54-5a82-49df-b283-cce9d5a9beb3",
      "skipped": false
    },
    {
      "title": "La risposta deve avere il campo name del context uguale a 'admin' nel caso in cui l'utente sia stato riconosciuto come possibile amministratore.",
      "fullTitle": "webhook La risposta deve avere il campo name del context uguale a 'admin' nel caso in cui l'utente sia stato riconosciuto come possibile amministratore.",
      "timedOut": false,
      "duration": 3,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "body.result.action = 'user.check';\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \"Mauro Carlin\", username : \"mou\"}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property('name', 'admin');",
      "err": {},
      "isRoot": false,
      "uuid": "3c54a623-22f5-4647-be31-47d4c602ea32",
      "parentUUID": "c8d8e18b-9394-4c7a-96c5-12f32dfea16a",
      "skipped": false
    },
    {
      "title": "La risposta deve avere il campo name del context uguale a 'welcome' nel caso in cui l'utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.",
      "fullTitle": "webhook La risposta deve avere il campo name del context uguale a 'welcome' nel caso in cui l'utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "body.result.action = 'guest.check';\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \"Mauro Carlin\", username : \"mou\", company : \"Google\"}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property('name', 'welcome');",
      "err": {},
      "isRoot": false,
      "uuid": "ad6f86ce-baef-48da-905c-9435a09d3ccc",
      "parentUUID": "c8d8e18b-9394-4c7a-96c5-12f32dfea16a",
      "skipped": false
    },
    {
      "title": "Deve sollevare un'eccezione se viene chiamato.",
      "fullTitle": "next Deve sollevare un'eccezione se viene chiamato.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "expect(obs.next.bind(obs)).to.throw();",
      "err": {},
      "isRoot": false,
      "uuid": "dfd0ca0b-ac0c-436e-a913-cd9b4969efaa",
      "parentUUID": "756a3b68-64c5-4bb5-9c1e-59dbcc996680",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\"Requested resource not found\"});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "dc95fe5e-76a5-4fba-ad11-eba62b1325d1",
      "parentUUID": "4a8f5f62-5c15-4f2f-8ce3-79210567d0ee",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un ospite sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "fullTitle": "addGuest Nel caso in cui un ospite sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.addGuest('mauro','Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "f066f453-69fa-4926-bf8f-05eef32d8025",
      "parentUUID": "4a8f5f62-5c15-4f2f-8ce3-79210567d0ee",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.getGuest('Mauro', 'Zero12').subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \"error getting data\" });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "c61f3362-04cf-4598-a65c-de16c8640d3d",
      "parentUUID": "9a1d8c07-ea5b-4d5d-8439-26640542c387",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "fullTitle": "getGuest Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.getGuest('Mauro', 'Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \"Mauro\", company : \"Zero12\" }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \"Mauro\");\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\"Zero12\");\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "bd7fd340-1a6f-474e-a23f-8fac1e080e6d",
      "parentUUID": "9a1d8c07-ea5b-4d5d-8439-26640542c387",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \"Mauro\", company : \"Zero12\" }], LastEvaluatedKey: 'Piero'});\ndynamo_client.scan.yield(null, {Items: [{ name : \"Piero\", company : \"Google\" }], LastEvaluatedKey: 'Luca'});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('Mauro');\nexpect(callNext.args[0].company).to.equal('Zero12');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('Piero');\nexpect(callNext.args[0].company).to.equal('Google');\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "11e9802c-02e7-4a52-98f3-0f14e498bde6",
      "parentUUID": "dadef009-1355-4a77-87f5-3738bb7e66f8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "fullTitle": "getGuestList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \"Mauro\", company : \"Zero12\" }], LastEvaluatedKey: 'Piero'});\ndynamo_client.scan.yield(null, {Items: [{name : \"Piero\", company : \"Google\" }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('Mauro');\nexpect(callNext.args[0].company).to.equal('Zero12');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('Piero');\nexpect(callNext.args[0].company).to.equal('Google');\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "7a666708-c559-4ba8-a691-329a017e3fc1",
      "parentUUID": "dadef009-1355-4a77-87f5-3738bb7e66f8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.removeGuest('mou').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \"error removing guest\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "9e20406b-fa00-4116-a8ca-6e0529a7b354",
      "parentUUID": "ecda102d-8229-49e6-8ecf-4d8918f2a571",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un ospite sia eliminato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "fullTitle": "removeGuest Nel caso in cui un ospite sia eliminato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.removeGuest('mou','Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \"success\" });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "ff719bb8-c323-4299-aa80-e357a2b668ff",
      "parentUUID": "ecda102d-8229-49e6-8ecf-4d8918f2a571",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.updateGuest('mou').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\"error updating guest\"});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "1a403bfa-73ba-408c-9db7-6c7b2633ed97",
      "parentUUID": "16b23eac-f406-487a-bf90-05d97938f888",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un ospite sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "fullTitle": "updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.updateGuest('mou','Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "3b8240b9-4326-4022-8296-b59a8896b8fb",
      "parentUUID": "16b23eac-f406-487a-bf90-05d97938f888",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si provi ad aggiungere l'id di una conversazione gi presente, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "addConversation Nel caso in cui si provi ad aggiungere l'id di una conversazione gi presente, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.addConversation('Mauro', 'Zero12', 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);",
      "err": {},
      "isRoot": false,
      "uuid": "750c214e-81a1-4c9b-9752-6c4918b40401",
      "parentUUID": "0e2cba76-65dc-4050-b4eb-103509990c73",
      "skipped": false
    },
    {
      "title": "Nel caso in cui venga aggiunto correttamente l'id di una conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "fullTitle": "addConversation Nel caso in cui venga aggiunto correttamente l'id di una conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.addConversation('Mauro', 'Zero12', 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "2c22e6b9-297c-467c-b9d1-381785ab4859",
      "parentUUID": "0e2cba76-65dc-4050-b4eb-103509990c73",
      "skipped": false
    },
    {
      "title": "Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
      "fullTitle": "addMember Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "members.addMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "02c90b6d-866c-4d20-9039-4360eda8cccd",
      "parentUUID": "9af67e4a-18cf-4645-90d6-25862c96083d",
      "skipped": false
    },
    {
      "title": "Nel caso in cui il metodo ottenga il membro dell'azienda allora l'Observable invia tale Member all'Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.",
      "fullTitle": "getMember Nel caso in cui il metodo ottenga il membro dell'azienda allora l'Observable invia tale Member all'Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "members.getMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t'ok': true,\n\t'user':\n\t{\n\t\t'id': 'U023BECGF',\n\t\t'name': 'bobby',\n\t\t'deleted': false,\n\t\t'color': '9f69e7',\n\t\t'profile':\n\t\t{\n\t\t\t'avatar_hash': 'ge3b51ca72de',\n\t\t\t'current_status': ':mountain_railway: riding a train',\n\t\t\t'first_name': 'Bobby',\n\t\t\t'last_name': 'Tables',\n\t\t\t'real_name': 'Bobby Tables',\n\t\t\t'email': 'bobby@slack.com',\n\t\t\t'skype': 'my-skype-name',\n\t\t\t'phone': '+1 (123) 456 7890'\n\t\t},\n\t\t'is_admin': true,\n\t\t'is_owner': true,\n\t\t'updated': 1490054400,\n\t\t'has_2fa': true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "ff5aefbd-f636-4c74-a713-a44af12b6cd8",
      "parentUUID": "f496455b-3885-46b8-a45d-b91c857490d2",
      "skipped": false
    },
    {
      "title": "Se si verifica un errore nell'ottenere il membro dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
      "fullTitle": "getMember Se si verifica un errore nell'ottenere il membro dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "members.getMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t'ok': false,\n\t'error': 'not_authed'\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal('not_authed');\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "863e06bc-cf24-4155-8e0c-1adb021ed578",
      "parentUUID": "f496455b-3885-46b8-a45d-b91c857490d2",
      "skipped": false
    },
    {
      "title": "L'Observable deve notificare l'Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.",
      "fullTitle": "getMemberList L'Observable deve notificare l'Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\"ok\": true,\n\t\"members\":\n\t[\n\t\t{\n\t\t\t\"id\": \"U023BECGF\",\n\t\t\t\"team_id\": \"T021F9ZE2\",\n\t\t\t\"name\": \"mauro\",\n\t\t\t\"deleted\": false,\n\t\t\t\"status\": null,\n\t\t\t\"color\": \"9f69e7\",\n\t\t\t\"real_name\": \"Mauro Bocciofilo\",\n\t\t\t\"tz\": \"America\\/Los_Angeles\",\n\t\t\t\"tz_label\": \"Pacific Daylight Time\",\n\t\t\t\"tz_offset\": -25200,\n\t\t\t\"profile\":\n\t\t\t{\n\t\t\t\t\"avatar_hash\": \"ge3b51ca72de\",\n\t\t\t\t\"current_status\": \":mountain_railway: riding a train\",\n\t\t\t\t\"first_name\": \"Bobby\",\n\t\t\t\t\"last_name\": \"Tables\",\n\t\t\t\t\"real_name\": \"Bobby Tables\",\n\t\t\t\t\"email\": \"bobby@slack.com\",\n\t\t\t\t\"skype\": \"my-skype-name\",\n\t\t\t\t\"phone\": \"+1 (123) 456 7890\"\n\t\t\t},\n\t\t\t\"is_admin\": true,\n\t\t\t\"is_owner\": true,\n\t\t\t\"updated\": 1490054400,\n\t\t\t\"has_2fa\": false\n\t\t},\n\t\t{\n\t\t\t\"id\": \"U023BECLL\",\n\t\t\t\"team_id\": \"T021F9ZE2\",\n\t\t\t\"name\": \"bobby\",\n\t\t\t\"deleted\": false,\n\t\t\t\"status\": null,\n\t\t\t\"color\": \"9f69e7\",\n\t\t\t\"real_name\": \"Bobby Tables\",\n\t\t\t\"tz\": \"America\\/Los_Angeles\",\n\t\t\t\"tz_label\": \"Pacific Daylight Time\",\n\t\t\t\"tz_offset\": -25200,\n\t\t\t\"profile\":\n\t\t\t{\n\t\t\t\t\"avatar_hash\": \"ge3b51ca72de\",\n\t\t\t\t\"current_status\": \":mountain_railway: riding a train\",\n\t\t\t\t\"first_name\": \"Bobby\",\n\t\t\t\t\"last_name\": \"Tables\",\n\t\t\t\t\"real_name\": \"Bobby Tables\",\n\t\t\t\t\"email\": \"bobby@slack.com\",\n\t\t\t\t\"skype\": \"my-skype-name\",\n\t\t\t\t\"phone\": \"+1 (123) 456 7890\",\n\t\t\t},\n\t\t\t\"is_admin\": true,\n\t\t\t\"is_owner\": true,\n\t\t\t\"updated\": 1490054400,\n\t\t\t\"has_2fa\": false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "b734ee6e-a8cf-447b-8980-62e7803d3734",
      "parentUUID": "75f84416-5a90-49df-9969-8fe6b9ce7f77",
      "skipped": false
    },
    {
      "title": "Se si verifica un errore nell'ottenere la lista dei membri dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
      "fullTitle": "getMemberList Se si verifica un errore nell'ottenere la lista dei membri dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t'ok': false,\n\t'error': 'not_authed'\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal('not_authed');\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "45d2c132-4196-4121-bfc3-2941853864cc",
      "parentUUID": "75f84416-5a90-49df-9969-8fe6b9ce7f77",
      "skipped": false
    },
    {
      "title": "Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
      "fullTitle": "removeMember Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "members.removeMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "a5d59fe5-2a67-4407-8b93-70e32d0a391a",
      "parentUUID": "b55027f0-3c8d-4942-8d33-906e3a6b27de",
      "skipped": false
    },
    {
      "title": "Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
      "fullTitle": "updateMember Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "members.updateMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "1f57d3f5-677b-44ed-8d66-1a120667b18d",
      "parentUUID": "ee9569e5-5359-4b17-8858-1b444fdecd21",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 3,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = {body: '', queryStringParameters: ''};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields('errore');\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property('statusCode', 500);\n  done();\n}",
      "err": {},
      "isRoot": false,
      "uuid": "a03595bc-4005-47dc-8f88-9f35fb5d3093",
      "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = {body: '', queryStringParameters: ''};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields('errore');\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property('statusCode', 500);\n            done();\n          }",
      "err": {},
      "isRoot": false,
      "uuid": "614e27bb-15a4-472e-bef7-beba02ee0f64",
      "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = {body: '', queryStringParameters: ''};\n          service.getChannelList(ev, context);\n          client.groups.list.yields('errore');\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property('statusCode', 500);\n            done();\n          }",
      "err": {},
      "isRoot": false,
      "uuid": "15ec6b31-d1f3-419c-87fb-ac3350c32f2d",
      "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.",
      "fullTitle": "getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = {body: '', queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property('statusCode', 200);\n  done();\n}",
      "err": {},
      "isRoot": false,
      "uuid": "e7d3f27b-f8e4-42ec-91ba-bbc1ed2da38c",
      "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield('errore');\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "ae8cf8d6-4571-48fb-be84-956e4b9d6f30",
      "parentUUID": "66ed54d0-d725-42a7-9d8b-256e464c7d4d",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.",
      "fullTitle": "sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "b4c761ba-ee0e-4b8a-bff5-1f395660f1bc",
      "parentUUID": "66ed54d0-d725-42a7-9d8b-256e464c7d4d",
      "skipped": false
    },
    {
      "title": "Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
      "fullTitle": "sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\n\nexpect(context.succeed.callCount).to.equal(1);\t\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property('statusCode', 400);",
      "err": {},
      "isRoot": false,
      "uuid": "8a26cac5-7042-4edb-a571-29cf75d4ea72",
      "parentUUID": "66ed54d0-d725-42a7-9d8b-256e464c7d4d",
      "skipped": false
    },
    {
      "title": "Deve chiamare complete_cb",
      "fullTitle": "complete Deve chiamare complete_cb",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \"il callback di complete non  stato chiamato esattamente una volta.\").to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "ef9c9039-f6f5-40d6-97d1-70b94fcd26db",
      "parentUUID": "59c5c0f1-bb37-4b83-9257-931e791a6665",
      "skipped": false
    },
    {
      "title": "Non deve chiamare complete_cb se l'observer  in pausa",
      "fullTitle": "complete Non deve chiamare complete_cb se l'observer  in pausa",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "6bcd6731-20e5-4535-90e3-8e5709f7ab8a",
      "parentUUID": "59c5c0f1-bb37-4b83-9257-931e791a6665",
      "skipped": false
    },
    {
      "title": "Deve chiamare complete_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
      "fullTitle": "complete Deve chiamare complete_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);",
      "err": {},
      "isRoot": false,
      "uuid": "ad63bef1-4072-4682-9079-624c2f18b53a",
      "parentUUID": "59c5c0f1-bb37-4b83-9257-931e791a6665",
      "skipped": false
    },
    {
      "title": "Deve chiamare error_cb",
      "fullTitle": "error Deve chiamare error_cb",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let err = new Error('Errore');\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);",
      "err": {},
      "isRoot": false,
      "uuid": "ccd804ad-6a28-4339-9e0c-24f5a161d70d",
      "parentUUID": "1ec6d4e7-c568-4ec1-8285-20c05faaf50a",
      "skipped": false
    },
    {
      "title": "Non deve chiamare error_cb se l'observer  in pausa",
      "fullTitle": "error Non deve chiamare error_cb se l'observer  in pausa",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "obs.onError(success);\nobs.pause();\nobs.error('errore');\n        expect(success.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "e3a1cf5e-99cf-4258-9b89-b9b0cef7fd36",
      "parentUUID": "1ec6d4e7-c568-4ec1-8285-20c05faaf50a",
      "skipped": false
    },
    {
      "title": "Deve chiamare error_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
      "fullTitle": "error Deve chiamare error_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let err = new Error('Errore');\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);",
      "err": {},
      "isRoot": false,
      "uuid": "e193717c-9272-4eb9-8ae7-100137f55ea9",
      "parentUUID": "1ec6d4e7-c568-4ec1-8285-20c05faaf50a",
      "skipped": false
    },
    {
      "title": "Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l'observer non  in pausa.",
      "fullTitle": "next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l'observer non  in pausa.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "obs.onNext(success);\nobs.next('data');\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal('data');",
      "err": {},
      "isRoot": false,
      "uuid": "4ce1ffae-80fb-4cb2-ba87-03004aa1f785",
      "parentUUID": "8394b522-9ca0-4007-acbd-f56b5cdd4bdf",
      "skipped": false
    },
    {
      "title": "Non deve chiamare next_cb se l'observer  in pausa",
      "fullTitle": "next Non deve chiamare next_cb se l'observer  in pausa",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "obs.onNext(success);\nobs.pause();\nobs.next('Function called');\nexpect(success.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "6ffa568f-39f1-4a88-90a9-44c3c3ff1a11",
      "parentUUID": "8394b522-9ca0-4007-acbd-f56b5cdd4bdf",
      "skipped": false
    },
    {
      "title": "Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l'observer ha ripreso.",
      "fullTitle": "next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l'observer ha ripreso.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "obs.onNext(success);\nobs.next('data');\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next('data');\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next('other data');\nexpect(success.callCount).to.equal(2);",
      "err": {},
      "isRoot": false,
      "uuid": "b7df49b6-2cc9-4415-8c28-cb59c4ed6391",
      "parentUUID": "8394b522-9ca0-4007-acbd-f56b5cdd4bdf",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "addRule Nel caso in cui una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\"Requested resource not found\"});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "089db301-228f-4a19-a1af-36e3bcba89cb",
      "parentUUID": "7c6f9016-2624-40c3-8b6a-d16a274d03e1",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "addRule Nel caso in cui una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "4ac71995-fe96-4624-aa03-da1927853bce",
      "parentUUID": "7c6f9016-2624-40c3-8b6a-d16a274d03e1",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getRule Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\"error getting data\"});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "d62cbc44-0f55-463c-93ae-2d70c0f90b20",
      "parentUUID": "abf42e37-4b7b-484d-8800-a6bdda5f82c2",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getRule Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "f297c8e6-2069-4f39-87c1-1cc923099ffa",
      "parentUUID": "abf42e37-4b7b-484d-8800-a6bdda5f82c2",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un blocco di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "cfb14092-49d1-4c90-8294-1a0e823bbb40",
      "parentUUID": "63b3612e-8067-4d44-ba08-8bd0a4b9892a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getRuleList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "75bf4c6a-663d-4e20-beae-eb17a150cc2e",
      "parentUUID": "63b3612e-8067-4d44-ba08-8bd0a4b9892a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "//da definire",
      "err": {},
      "isRoot": false,
      "uuid": "1a785b97-b413-4d56-88df-895cac1ccaab",
      "parentUUID": "63b3612e-8067-4d44-ba08-8bd0a4b9892a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "removeRule Nel caso in cui una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\"error removing rule\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "caa39041-0f72-4888-90c8-65c61336a1a3",
      "parentUUID": "423e1330-63d3-4117-b3f4-628dd1233ea5",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "removeRule Nel caso in cui una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\"success\"});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "bd963fc4-421e-4c38-b7de-05eae863be08",
      "parentUUID": "423e1330-63d3-4117-b3f4-628dd1233ea5",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\"error updating rule\"});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "bd274684-4120-49d6-b2de-cb7323b9fb09",
      "parentUUID": "d89bcd03-42ad-4e60-91be-b78a848e33ea",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "95b845b3-a047-4201-a321-ba4f89ed81d9",
      "parentUUID": "d89bcd03-42ad-4e60-91be-b78a848e33ea",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
      "fullTitle": "addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \"\"};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 400);",
      "err": {},
      "isRoot": false,
      "uuid": "c42876a2-86d4-482b-8da3-ede34ad9213f",
      "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "0e1fc861-dca2-4a2d-8e2f-860f4a40942f",
      "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
      "fullTitle": "addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "c763b098-1ad3-41f3-82f1-edbd4ba347bd",
      "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
      "skipped": false
    },
    {
      "title": "Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
      "fullTitle": "addRule Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.addRule.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Conflict' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 409);",
      "err": {},
      "isRoot": false,
      "uuid": "a015e9da-bf4e-458e-81c7-b7a34c72cdd0",
      "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "29852138-9793-4a61-82dd-f284c94406cd",
      "parentUUID": "5313bfde-f4d8-4ba7-9f07-ba7680c064e4",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
      "fullTitle": "deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "66e7deee-a097-4f35-a8fa-842d0d1fdbcb",
      "parentUUID": "5313bfde-f4d8-4ba7-9f07-ba7680c064e4",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
      "fullTitle": "deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 404);\n};",
      "err": {},
      "isRoot": false,
      "uuid": "c6a70335-3dfc-41c1-b57f-51a24c3b3d72",
      "parentUUID": "5313bfde-f4d8-4ba7-9f07-ba7680c064e4",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.",
      "fullTitle": "getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "b862d873-13ab-4147-93a1-973bde319874",
      "parentUUID": "fc64a12a-bf9c-4ce2-8c4f-0f62b1fe073f",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "326099c3-e462-4b7d-a2cf-e9b185586fee",
      "parentUUID": "fc64a12a-bf9c-4ce2-8c4f-0f62b1fe073f",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
      "fullTitle": "getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.getRule.returns(Rx.Observable.throw({ code: 'Not found' }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 404);",
      "err": {},
      "isRoot": false,
      "uuid": "44d6c908-c026-4f9c-ace3-bb1a06996727",
      "parentUUID": "fc64a12a-bf9c-4ce2-8c4f-0f62b1fe073f",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.",
      "fullTitle": "getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "aa1d48d6-198a-4af4-afac-c7db759a1f38",
      "parentUUID": "d73704ca-5230-41e5-8743-f3f3736b1622",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "c72d60cd-1b2c-40c6-935b-d6652128f8df",
      "parentUUID": "d73704ca-5230-41e5-8743-f3f3736b1622",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.",
      "fullTitle": "getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "116af487-0d65-4a4d-a337-8b1877a1d9cd",
      "parentUUID": "02c31782-3d8b-4a20-9866-3e283c5dfc71",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "a28ec737-df8e-4c62-818f-82c5ab39be61",
      "parentUUID": "02c31782-3d8b-4a20-9866-3e283c5dfc71",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
      "fullTitle": "updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "6b1cc0eb-5a3b-4c05-8b3a-4bdf0221c572",
      "parentUUID": "0cd041b3-ae95-4251-b4f8-b914d0cb3135",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
      "fullTitle": "updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \"\" , body: \"\"};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 400);",
      "err": {},
      "isRoot": false,
      "uuid": "9e880780-5b00-4cae-98e7-d55e9547d9fe",
      "parentUUID": "0cd041b3-ae95-4251-b4f8-b914d0cb3135",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "b9ef09a1-5610-46f7-b448-23e2c1fa9d78",
      "parentUUID": "0cd041b3-ae95-4251-b4f8-b914d0cb3135",
      "skipped": false
    },
    {
      "title": "Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.",
      "fullTitle": "speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.",
      "timedOut": false,
      "duration": 0,
      "state": "failed",
      "pass": false,
      "fail": true,
      "pending": false,
      "code": "let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});",
      "err": {
        "estack": "TypeError: this.streamifier.createReadStream is not a function\n  at STTWatsonAdapter.speechToText (src\\Back-end\\STT\\STTWatsonAdapter.js:24:31)\n  at Context.<anonymous> (src\\test\\test_STTWatsonAdapter.js:20:27)\n"
      },
      "isRoot": false,
      "uuid": "22b323e5-4414-433b-8d21-a5a8c44dac14",
      "parentUUID": "36203f4f-132f-485a-ac03-b4b81bfda3c6",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\"Requested resource not found\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "a276b1eb-82b7-4cf5-b8a0-36d29f31be3c",
      "parentUUID": "b9a9fc5d-6685-416d-8b86-7f1b637b3e49",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "df25eabe-4714-423f-b556-4ad97e51757e",
      "parentUUID": "b9a9fc5d-6685-416d-8b86-7f1b637b3e49",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getTask Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.getTask('mock_type').subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\"error getting data\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "c7ac7543-162a-4438-b32e-73661278a15e",
      "parentUUID": "30151355-dc16-413c-a70a-47ff8e09efa5",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getTask Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let observable = tasks.getTask('mock_type');\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "7fdfd483-1ca7-442b-a53a-ed9394370f36",
      "parentUUID": "30151355-dc16-413c-a70a-47ff8e09efa5",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \"mock_type2\"});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \"mock_type3\"});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "55fbad25-7a07-4799-84b5-4272348136aa",
      "parentUUID": "2fef8d26-d97d-4580-9522-a3ac93cb3059",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getTaskList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 8,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\"mock_type2\"});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "3b4895e9-e4ae-4490-a218-dd0021254961",
      "parentUUID": "2fef8d26-d97d-4580-9522-a3ac93cb3059",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.removeTask('mock_type').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\"error removing rule\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "e4ed2919-9ce3-4633-89e4-e1cd5f574a4d",
      "parentUUID": "bdb9059f-2f29-4b41-980f-4173950eac2e",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.removeTask('mock_type').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\"success\"});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "44f04a09-2ed0-44ea-a85d-612b1b2735ad",
      "parentUUID": "bdb9059f-2f29-4b41-980f-4173950eac2e",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.updateTask('mock_type').subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\"error updating rule\"});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "ef2806e7-70c2-4af8-97f5-ff003d6baf7e",
      "parentUUID": "23924557-8f5b-44fb-982a-9d6448e20d57",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.updateTask('mock_type').subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "885c756f-cfdc-48d1-b42c-442a960578ed",
      "parentUUID": "23924557-8f5b-44fb-982a-9d6448e20d57",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'utente non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "addUser Nel caso in cui l'utente non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.addUser('mou').subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\"Requested resource not found\"});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "83390f62-e457-4833-a4f7-363b187fc70f",
      "parentUUID": "86e1fc1f-283c-43bb-8db0-c8a7180e4a11",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'utente sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "addUser Nel caso in cui l'utente sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.addUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "1b3cc114-22b1-4b8e-b3a5-9d09c8f6ae55",
      "parentUUID": "86e1fc1f-283c-43bb-8db0-c8a7180e4a11",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getUser Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.getUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\"error getting data\"});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "5e3bf7fa-7013-490f-8e25-c75a17d65dd4",
      "parentUUID": "5a59f620-7101-415c-bb68-753a76c4a91a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getUser Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let observable = users.getUser('mou');\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \"mauro\", username: \"mou\"}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal('mauro');\n\t\t\t\t\texpect(callNext.args[0].username).to.equal('mou');\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "2f0b6bb3-924d-4ab8-af71-3a6c83f48e70",
      "parentUUID": "5a59f620-7101-415c-bb68-753a76c4a91a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getUserList Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'piero'});\ndynamo_client.scan.yield(null, {Items: [{name: \"piero\", username: \"sun\"}], LastEvaluatedKey: 'marco'});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('piero');\nexpect(callNext.args[0].username).to.equal('sun');\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "1bafd5a7-696d-4e0a-af34-cec10d210af2",
      "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getUserList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'piero'});\ndynamo_client.scan.yield(null, {Items: [{name: \"piero\", username: \"sun\"}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('piero');\nexpect(callNext.args[0].username).to.equal('sun');\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "06b74b70-c937-420b-a443-0405f46da7b6",
      "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let query =\n{\n\tname: 'mauro'\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'sun'});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"sun\"}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property('FilterExpression', 'full_name = :full_name');\nexpect(callScan.args[0]).to.have.deep.property('ExpressionAttributeValues.:full_name', 'mauro' );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('sun');",
      "err": {},
      "isRoot": false,
      "uuid": "899a4b20-6042-45fa-8e66-898436549096",
      "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let query =\n{\n\tname: 'mauro',\n\tslack_channel: 'channel'\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'sun'});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"sun\"}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property('FilterExpression', 'full_name = :full_name and slack_channel = :slack_channel');\nexpect(callScan.args[0]).to.have.deep.property('ExpressionAttributeValues.:full_name', 'mauro' );\nexpect(callScan.args[0]).to.have.deep.property('ExpressionAttributeValues.:slack_channel', 'channel' );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('sun');",
      "err": {},
      "isRoot": false,
      "uuid": "3795bb44-9d26-4560-9346-92c7e731a900",
      "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'utente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "removeUser Nel caso in cui l'utente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.removeUser('mou').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \"error removing user\"});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "53ac7672-612e-4787-9785-54a42920be9d",
      "parentUUID": "51ad4ccd-ddb6-4050-bfa8-85b53ef84e53",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'utente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta",
      "fullTitle": "removeUser Nel caso in cui l'utente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.removeUser('mou').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "37d4128b-b13b-4066-81cb-67abf9163c26",
      "parentUUID": "51ad4ccd-ddb6-4050-bfa8-85b53ef84e53",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'utente non venga modificato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "updateUser Nel caso in cui l'utente non venga modificato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.updateUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \"error updating user\"});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "c9d72e9b-400e-4a63-8a5a-0bb42072df45",
      "parentUUID": "39f8b44e-228f-4e9d-b5d2-85e7338d6e56",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'utente sia modificato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "updateUser Nel caso in cui l'utente sia modificato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.updateUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "6ec9eb13-06e0-4d4a-90c3-0c061c3a7032",
      "parentUUID": "39f8b44e-228f-4e9d-b5d2-85e7338d6e56",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "fullTitle": "addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \"Mauro\",\n  username: \"mou\"\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "c6a2295e-ba40-4f1a-8628-cd97ae2bf1e6",
      "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
      "fullTitle": "addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \"Mauro\",\n  username: \"mou\"\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "5e5830df-00ce-408a-a900-ab0e9c6c0797",
      "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
      "skipped": false
    },
    {
      "title": "Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
      "fullTitle": "addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \"\" };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 400);",
      "err": {},
      "isRoot": false,
      "uuid": "4f3d3c4a-eb50-4fa1-9c1c-3d6cc2090d59",
      "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
      "skipped": false
    },
    {
      "title": "Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
      "fullTitle": "addUser Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.addUser.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\nlet user=\n{\n  name: \"Mauro\",\n  username: \"mou\"\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Conflict' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 409);",
      "err": {},
      "isRoot": false,
      "uuid": "687ee9d9-9f48-4e81-9f18-904b1bb8dca7",
      "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "fullTitle": "deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: 'mou' }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "99ddf7d8-5cd8-4bb2-84bd-0931669279b1",
      "parentUUID": "ad7d0256-dcc0-44d8-bb37-a96ec436d965",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
      "fullTitle": "deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: 'mou' }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "40f01a52-b13e-46df-958c-0f237f509ac6",
      "parentUUID": "ad7d0256-dcc0-44d8-bb37-a96ec436d965",
      "skipped": false
    },
    {
      "title": "Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
      "fullTitle": "deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.removeUser.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\nlet ev = { pathParameters: { username: 'pippo' }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 404);",
      "err": {},
      "isRoot": false,
      "uuid": "2a1dfcc2-b9d7-4023-ac73-f6b3783bf264",
      "parentUUID": "ad7d0256-dcc0-44d8-bb37-a96ec436d965",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "fullTitle": "getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: 'mou'} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "48db7279-31e0-4233-80ed-422f789105fb",
      "parentUUID": "d08d3ef1-a1f7-4218-bd16-3f1f61bc779c",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l'utente richiesto",
      "fullTitle": "getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l'utente richiesto",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.getUser.returns(Rx.Observable.of({ name : 'Mauro', username : 'mou' }));\nlet ev = { pathParameters: { username: 'mou'} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ name : 'Mauro', username : 'mou' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "3cdcaca0-379d-4a4d-9477-26e429c38528",
      "parentUUID": "d08d3ef1-a1f7-4218-bd16-3f1f61bc779c",
      "skipped": false
    },
    {
      "title": "Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
      "fullTitle": "getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.getUser.returns(Rx.Observable.throw({ code: 'Not found' }));\n          let ev = { pathParameters: { username: 'pippo'} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 404);",
      "err": {},
      "isRoot": false,
      "uuid": "21292dce-2ca3-4f92-a8e4-b25640dd6198",
      "parentUUID": "d08d3ef1-a1f7-4218-bd16-3f1f61bc779c",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "fullTitle": "getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "5aa15209-a566-4a0d-8c59-c211b9784440",
      "parentUUID": "8b17897e-5dda-49ca-a254-e36f1ff1a75f",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti",
      "fullTitle": "getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.getUserList.returns(Rx.Observable.of({ name : 'Mauro', username : 'mou' }, { name : 'Nicola', username : 'tinto' }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ users: [{ name : 'Mauro', username : 'mou' }, { name : 'Nicola', username : 'tinto' }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "5a430af6-5708-466b-ad31-cbeb0d6be891",
      "parentUUID": "8b17897e-5dda-49ca-a254-e36f1ff1a75f",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "fullTitle": "updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \"gianluca\"\n};\nlet ev = { pathParameters: \"mou\", body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "9047a0f8-88ea-4a42-b99b-b5fb166e8088",
      "parentUUID": "a21d3f36-9b8f-4d52-9b6f-e3692901b11a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
      "fullTitle": "updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \"gianluca\"\n};\nlet ev = { pathParameters: \"mou\", body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "29eab6dc-e65b-4a60-988c-2ae9c38fd5ce",
      "parentUUID": "a21d3f36-9b8f-4d52-9b6f-e3692901b11a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
      "fullTitle": "updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = { pathParameters: \"\", body: \"\" };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 400);",
      "err": {},
      "isRoot": false,
      "uuid": "c5ff3096-f1c4-4306-9ff5-bc1de292eb41",
      "parentUUID": "a21d3f36-9b8f-4d52-9b6f-e3692901b11a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "fullTitle": "onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let context = { body: '' };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
      "err": {},
      "isRoot": false,
      "uuid": "75a00fd3-8b57-462e-9008-aa7ddd3176e6",
      "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "fullTitle": "onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let context = { body: '' };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
      "err": {},
      "isRoot": false,
      "uuid": "83aa1bd0-491d-421f-9292-68c4e8e53054",
      "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "fullTitle": "onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let context = { body: '' };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { 'msg': 'error getting guest' });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
      "err": {},
      "isRoot": false,
      "uuid": "e2282794-72b6-49f6-8890-7e1b7e3887f5",
      "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "fullTitle": "onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let context = { body: '' };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ 'msg': 'error adding conversation' });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
      "err": {},
      "isRoot": false,
      "uuid": "179cb7ef-cded-4f68-bb66-7b6ba42b3757",
      "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.",
      "fullTitle": "onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let context = { body: '' };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { 'type': 'example' });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;",
      "err": {},
      "isRoot": false,
      "uuid": "0175c2d2-9c56-4bf6-98f8-0fe7d399752b",
      "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
      "skipped": false
    },
    {
      "title": "Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.",
      "fullTitle": "query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.getAgent.returns(Rx.Observable.empty());\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\n          \nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith('test'));\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n});",
      "err": {},
      "isRoot": false,
      "uuid": "26943c6b-36c1-4591-899b-99b958b8c87b",
      "parentUUID": "16233e0a-62d6-4264-920a-636c20622f59",
      "skipped": false
    },
    {
      "title": "Se la chiamata al modulo VAModule genera un'errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.",
      "fullTitle": "query Se la chiamata al modulo VAModule genera un'errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.",
      "timedOut": false,
      "duration": 4,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.getAgent.returns(Rx.Observable.throw(new Error()));\n          va.query.returns(Promise.resolve(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\n          \nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n});",
      "err": {},
      "isRoot": false,
      "uuid": "d9b71483-53e7-4d59-ae4d-5003ac406d76",
      "parentUUID": "16233e0a-62d6-4264-920a-636c20622f59",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 4,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "ff6f0521-106c-4d65-bda0-c5d06f974239",
      "parentUUID": "81cb31d0-ac2f-452c-9542-317b14c7a96e",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "e8fa641b-4a95-40f9-b87c-e030c2b411e7",
      "parentUUID": "416dab94-3533-4280-9a42-f1128bc5226b",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 0,
      "pass": false,
      "fail": false,
      "pending": true,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "42c8f399-1f6e-413b-888b-3d77d715c74c",
      "parentUUID": "aa13c3d7-9425-4cda-863f-00de49e521f3",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 1,
      "state": "failed",
      "pass": false,
      "fail": true,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {
        "estack": "ReferenceError: S_SERVICE_URL is not defined\n  at Observable._subscribe (src\\Back-end\\APIGateway\\VocalAPI.js:134:13)\n  at Observable._trySubscribe (node_modules\\rxjs\\Observable.js:57:25)\n  at Observable.subscribe (node_modules\\rxjs\\Observable.js:45:27)\n  at Context.<anonymous> (src\\test\\test_VocalAPI.js:86:22)\n"
      },
      "isRoot": false,
      "uuid": "bc261c7c-9476-4010-894b-2b668a7e529b",
      "parentUUID": "73e77d55-28dd-48e5-9c30-d906ccab88dc",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "cf3616ad-feba-4d3d-a924-05d5b2fe7956",
      "parentUUID": "4108b2b3-b97a-49fe-81b0-8e39c54a421e",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._getUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "595d8437-7df9-43b7-b580-c051c833926b",
      "parentUUID": "e59073d2-5134-4fc2-9749-afa301669c38",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 3,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "6949a687-3043-46b4-9332-b074e13746b4",
      "parentUUID": "e771685a-9cdb-456c-890c-c6b9273d9487",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.",
      "fullTitle": "_loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.",
      "timedOut": false,
      "duration": 0,
      "pass": false,
      "fail": false,
      "pending": true,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "9ed801cb-e267-425a-8e43-46633582053b",
      "parentUUID": "1540a04f-0422-4415-b1c6-682f1ad01a7c",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.",
      "fullTitle": "queryLambda Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "583e7901-d1c5-4fe4-86b9-13d4a3ce203e",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se lo status della risposta ricevuta dall'assistente virtuale  diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio 'Errore nel contattare l'assistente virtuale'.",
      "fullTitle": "queryLambda Se lo status della risposta ricevuta dall'assistente virtuale  diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio 'Errore nel contattare l'assistente virtuale'.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "949b81aa-ddc8-4a4b-9190-bf18e33e54b8",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'rule.add' allora il metodo deve chiamare il metodo privato _addRule.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'rule.add' allora il metodo deve chiamare il metodo privato _addRule.",
      "timedOut": false,
      "duration": 7,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve('Test'));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);",
      "err": {},
      "isRoot": false,
      "uuid": "5e9f7648-3fe4-4443-935a-310e61ed678d",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.add' allora il metodo deve chiamare il metodo privato _addUser.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.add' allora il metodo deve chiamare il metodo privato _addUser.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "fbfd4f11-e04a-4dec-842b-95869763f778",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.addEnrollment' allora il metodo deve chiamare il metodo privato _addUserEnrollment.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.addEnrollment' allora il metodo deve chiamare il metodo privato _addUserEnrollment.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "658c3032-e0e4-4dc1-8542-7cc206941890",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'rule.get' allora il metodo deve chiamare il metodo privato _getRule.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'rule.get' allora il metodo deve chiamare il metodo privato _getRule.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "988b12cf-c46e-4b5a-a5da-a9fbe4835a1c",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'rule.getList' allora il metodo deve chiamare il metodo privato _getRuleList.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'rule.getList' allora il metodo deve chiamare il metodo privato _getRuleList.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "99a7d5ec-e2ec-400c-a26a-daff2c3dff09",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.get' allora il metodo deve chiamare il metodo privato _getUser.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.get' allora il metodo deve chiamare il metodo privato _getUser.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "9848483b-ab68-4ab3-8c39-1d3c32a3e85c",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.getList' allora il metodo deve chiamare il metodo privato _getUserList.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.getList' allora il metodo deve chiamare il metodo privato _getUserList.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "e3612547-bc6e-4334-96da-90a503de5759",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.login' allora il metodo deve chiamare il metodo privato _loginUser.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.login' allora il metodo deve chiamare il metodo privato _loginUser.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "5b91c259-8079-4a76-99fb-9529861bb57d",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'rule.remove' allora il metodo deve chiamare il metodo privato _removeRule.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'rule.remove' allora il metodo deve chiamare il metodo privato _removeRule.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "ae28f2fb-1c74-4d56-82bd-09249f9b2944",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.remove' allora il metodo deve chiamare il metodo privato _removeUser.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.remove' allora il metodo deve chiamare il metodo privato _removeUser.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "38e2757e-47bb-455b-9a16-1723dc95bf89",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.resetEnrollment' allora il metodo deve chiamare il metodo privato _resetUserEnrollment.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.resetEnrollment' allora il metodo deve chiamare il metodo privato _resetUserEnrollment.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "5628ba86-dfbb-4ec3-82cc-862f9278dea1",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'rule.update' allora il metodo deve chiamare il metodo privato _updateRule.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'rule.update' allora il metodo deve chiamare il metodo privato _updateRule.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "9a22581d-2dfd-4374-98b3-362d4b0b256d",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.update' allora il metodo deve chiamare il metodo privato _updateUser.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.update' allora il metodo deve chiamare il metodo privato _updateUser.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "c61a2eb0-32b2-4732-8d7e-71d6cc7b7638",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "e0bd704a-494b-4da0-a41f-99de192dd690",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "c234ea6e-6bb8-4f6c-984a-a39dd5e2b1b9",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "d1fc3c08-6c09-41f8-a3b5-d07a45e7b0b1",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "7423b8fd-e8d0-4730-90de-d2721997f836",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "0772f537-14b1-4030-9411-25348fbdff5a",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "14258172-9f19-4a1b-baac-21b069dcc2d4",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "a956bd2d-27e0-43f7-81ec-0ab80c76e493",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "a714bccc-015e-4d59-b048-057d5673c136",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "7b9c9419-6ac0-4782-8632-db65abea1178",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "acbe1440-eb09-41d4-b0d9-4871d25b7da6",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "e59430c7-587a-4d1c-9a5e-fcc8762e82f8",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "36389c3d-9499-4aed-9a58-447f8e5c9716",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "b9edd18e-a431-40d4-854d-7ca53cb20232",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari allo status dell'errore.",
      "fullTitle": "queryLambda Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari allo status dell'errore.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "720adc5e-2640-4ce2-96cf-be140b0c6f25",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se lo status code della risposta di un microservizio  pari a 200 e l'action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.",
      "fullTitle": "queryLambda Se lo status code della risposta di un microservizio  pari a 200 e l'action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "e3948158-affd-4224-9e83-0149050d04c1",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "141f4f30-4ff7-4c7f-b728-6851abbb3d37",
      "parentUUID": "7c914302-e6ad-49e8-9771-b1b677d0f05e",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 3,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._removeUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "daf11510-401b-413e-bd1f-76e05f6de872",
      "parentUUID": "0a9e3709-fc73-4f47-8ae2-1aad8bc3420c",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 0,
      "pass": false,
      "fail": false,
      "pending": true,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "3ea7b78f-845c-480d-91ed-35640b99ea92",
      "parentUUID": "b816b55e-6cc7-4746-84dc-e8665fe5109f",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "e07a3412-7087-4174-871c-352e867b8043",
      "parentUUID": "9db1915e-bb37-4e6e-b8a6-3d12d3a3d7ab",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 4,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "70747eb8-1151-4d2c-9b3c-0786fd2e5fb7",
      "parentUUID": "70b2ad21-56e9-49de-b504-81d363cdefc5",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "fullTitle": "addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "timedOut": false,
      "duration": 3,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});",
      "err": {},
      "isRoot": false,
      "uuid": "7a7e915c-e835-4785-9a96-b0cc37d8970f",
      "parentUUID": "5915b3d6-0198-4526-980a-b013aa879e1a",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.",
      "fullTitle": "createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
      "err": {},
      "isRoot": false,
      "uuid": "eccb4a39-962a-4f3a-a6f8-e86589269f4a",
      "parentUUID": "8289f800-d2cf-473a-9c24-d259725382c5",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "fullTitle": "deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
      "err": {},
      "isRoot": false,
      "uuid": "cf0cf000-146e-4040-86cf-061a2850ddb6",
      "parentUUID": "b296dfee-7cb9-4158-acb4-82698071dff8",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo 'result' pari a 'Reject', l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "fullTitle": "doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo 'result' pari a 'Reject', l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject({ \"result\" : \"Reject\" }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
      "err": {},
      "isRoot": false,
      "uuid": "2476e090-845f-47c9-b8ec-3e8cb74da2fb",
      "parentUUID": "990aebc1-8494-46d3-9123-236660e612ca",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
      "fullTitle": "getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
      "err": {},
      "isRoot": false,
      "uuid": "6d2b6082-9fb3-4105-97de-dc3038e560dd",
      "parentUUID": "0a551883-894e-47c9-8981-ab12e485d5e2",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
      "fullTitle": "getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(\n  {\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
      "err": {},
      "isRoot": false,
      "uuid": "27cc3c17-0123-49d7-9d5d-6ea8e226ae0b",
      "parentUUID": "2035d6cd-adc3-4ff2-9ec0-b2aafe8cd5fb",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "fullTitle": "resetEnrollment Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.resetEnrollment().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
      "err": {},
      "isRoot": false,
      "uuid": "ae6b267d-a925-46f4-a76b-a6ed8e2aa5b0",
      "parentUUID": "5b90d4b3-27c9-48b5-aa79-aaade1225681",
      "skipped": false
    }
  ],
  "allPending": [
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_addUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 0,
      "pass": false,
      "fail": false,
      "pending": true,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "42c8f399-1f6e-413b-888b-3d77d715c74c",
      "parentUUID": "aa13c3d7-9425-4cda-863f-00de49e521f3",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.",
      "fullTitle": "_loginUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora la Promise deve essere rigettata.",
      "timedOut": false,
      "duration": 0,
      "pass": false,
      "fail": false,
      "pending": true,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "9ed801cb-e267-425a-8e43-46633582053b",
      "parentUUID": "1540a04f-0422-4415-b1c6-682f1ad01a7c",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_resetUserEnrollment Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 0,
      "pass": false,
      "fail": false,
      "pending": true,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "3ea7b78f-845c-480d-91ed-35640b99ea92",
      "parentUUID": "b816b55e-6cc7-4746-84dc-e8665fe5109f",
      "skipped": false
    }
  ],
  "allPasses": [
    {
      "title": "Nel caso in cui un agente di api.ai non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "addAgent Nel caso in cui un agente di api.ai non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 3,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode:400, msg:\"Requested resource not found\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(400);",
      "err": {},
      "isRoot": false,
      "uuid": "26893fa7-e651-42e7-92f1-173f4472299f",
      "parentUUID": "4fadae18-f59d-4696-9466-88a623668476",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un agente di api.ai sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "addAgent Nel caso in cui un agente di api.ai sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.addAgent(mock_agent).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "b11d5fe2-9618-48a1-ac3c-d1de960468a8",
      "parentUUID": "4fadae18-f59d-4696-9466-88a623668476",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getAgent Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.getAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode:500, msg:\"error getting data\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
      "err": {},
      "isRoot": false,
      "uuid": "856587bf-b8e7-4410-b05a-83c006314f6b",
      "parentUUID": "daf9c8b0-1de6-402d-b18c-33d6de82bff2",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getAgent Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let observable = agents.getAgent('mock_name');\nobservable.subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield(null, {Item: {mock_agent}});\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "0deff0df-a3f9-4cc6-93c8-f36b7338c239",
      "parentUUID": "daf9c8b0-1de6-402d-b18c-33d6de82bff2",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un blocco di agenti non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getAgentList Nel caso in cui un blocco di agenti non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: '1'});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: '2'});\ndynamo_client.scan.yield({statusCode:500, msg:\"error getting data\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
      "err": {},
      "isRoot": false,
      "uuid": "9d868356-eaf9-48b4-bc4c-88c7dc0c9e6b",
      "parentUUID": "a54c675d-d666-4ec5-a70f-d3516c0421af",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getAgentList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.getAgentList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [mock_agent], LastEvaluatedKey: '1'});\ndynamo_client.scan.yield(null, {Items: [mock_agent]}); // Ultimo elemento da ottenere\nexpect(next.callCount).to.be.above(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "65aa7f88-a829-4ca3-8cc0-dae56dbeba01",
      "parentUUID": "a54c675d-d666-4ec5-a70f-d3516c0421af",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un agente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "removeAgent Nel caso in cui un agente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.removeAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, msg:\"error removing rule\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
      "err": {},
      "isRoot": false,
      "uuid": "1fc29d68-afe7-4b8f-827b-0b323e0c5d21",
      "parentUUID": "6b8bbdc1-e9e9-4838-b66e-beb284a0abcc",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un agente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "removeAgent Nel caso in cui un agente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.removeAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, msg:\"success\"});\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "04b81d03-22dd-487d-8f98-efce46540105",
      "parentUUID": "6b8bbdc1-e9e9-4838-b66e-beb284a0abcc",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un agente non venga aggiornato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "updateAgent Nel caso in cui un agente non venga aggiornato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 5,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.updateAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, msg:\"error updating rule\"});\nexpect(error.callCount).to.equal(1);\nexpect(error.getCall(0).args[0].statusCode).to.equal(500);",
      "err": {},
      "isRoot": false,
      "uuid": "dc87add1-fdf1-4105-904b-47fdea8ed1ad",
      "parentUUID": "a0505902-4fbc-4a5e-9c0c-069857597be8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un agente sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "updateAgent Nel caso in cui un agente sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.updateAgent('mock_name').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, mock_agent);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "1d95d735-3753-4663-873a-33c773cc1f8d",
      "parentUUID": "a0505902-4fbc-4a5e-9c0c-069857597be8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell'assistente virtuale",
      "fullTitle": "query Nel caso in cui la richiesta HTTP vada a buon fine, la Promise restituita deve essere risolta con i dati relativi alla risposta dell'assistente virtuale",
      "timedOut": false,
      "duration": 3,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "RequestPromise.returns(Promise.resolve(response));\nadapter.query(query).then(function(data)\n\t\t\t\t\t{\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})\n\t\t\t\t\t.catch(done);",
      "err": {},
      "isRoot": false,
      "uuid": "6b34d0de-0aab-4944-a581-7b6f18c3debd",
      "parentUUID": "0b68480d-7356-4390-9948-55a582959fa7",
      "skipped": false
    },
    {
      "title": "Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta",
      "fullTitle": "query Nel caso si verifichi un errore durante la richiesta HTTP, la Promise restituita deve essere respinta",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "//sarebbero da aggiungere i singoli casi (status code, data.statusCode, ecc)\nRequestPromise.returns(Promise.resolve(error));\nadapter.query(query).then(done).catch(function(err){done();});",
      "err": {},
      "isRoot": false,
      "uuid": "e5143ea9-b3c4-4887-b44c-8a3bc38714f5",
      "parentUUID": "0b68480d-7356-4390-9948-55a582959fa7",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "addConversation Nel caso in cui una conversazione non venga aggiunta a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({ statusCode : 400, message : \"Requested resource not found\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "f31c3da8-32ae-468c-9332-f60891c0c84a",
      "parentUUID": "e4157c33-a462-4114-b13f-076e7a145fbc",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una conversazione sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell' Observer iscritto un'unica volta.",
      "fullTitle": "addConversation Nel caso in cui una conversazione sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell' Observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.addConversation(mock_conv).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "a94ebceb-2e3d-4a39-a1db-71b22479cea6",
      "parentUUID": "e4157c33-a462-4114-b13f-076e7a145fbc",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "addMessage Nel caso in cui un messaggio non venga aggiunta alla conversazione a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.addMessage({sender:'mock_sender',text: 'mock_text', timestamp: '2000-10-10'},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield({ statusCode : 500, message : \"error adding message\" });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "4fb15a05-eec8-4faa-9581-e6ad1ad68f1b",
      "parentUUID": "47cc6cad-3104-486a-acbb-5dd29ade298c",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "fullTitle": "addMessage Nel caso in cui un messaggio venga aggiunto correttamente alla conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.addMessage({sender:'mock_sender',text: 'mock_text', timestamp: '2000-10-10'},2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.update.yield(null,{});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "45b408c3-af72-43eb-85b2-a04352e35534",
      "parentUUID": "47cc6cad-3104-486a-acbb-5dd29ade298c",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "getConversation Nel caso in cui una conversazione non venga restituita a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield({ statusCode  :500, message : \"error downloading conversation\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "d64e5096-b768-4109-8f0b-55268a1aab9e",
      "parentUUID": "d4754cff-a4d4-4fae-85f9-670b5909d980",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "fullTitle": "getConversation Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.getConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, mock_conv);\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.Item.session_id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "59195ec3-8a3f-41df-a427-f314b34eebf9",
      "parentUUID": "d4754cff-a4d4-4fae-85f9-670b5909d980",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un blocco di conversazioni non venga restituito a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getConversationList Nel caso in cui un blocco di conversazioni non venga restituito a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.getConversationList().subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\ndynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2],LastEvaluatedKey:3});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\tcallNext = next.getCall(1);\nexpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "7c39be02-44b1-4b5a-a683-ef0cd1396cf4",
      "parentUUID": "e430a129-ab3c-476d-9af1-d96840e155e8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "fullTitle": "getConversationList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte le conversazioni ottenute dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.getConversationList().subscribe(\n  \t\t\t\t\t{\n  \t\t\t\t\t\tnext: next,\n  \t\t\t\t\t\terror: error,\n  \t\t\t\t\t\tcomplete: complete\n  \t\t\t\t\t});\n  dynamo_client.scan.yield(null, {Items:[mock_conv],LastEvaluatedKey:2});\n\t\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_conv2]});\n  expect(error.callCount).to.equal(0);\n  expect(next.callCount).to.equal(2);\n\t\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv.session_id);\n\t\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\t\texpect(callNext.args[0].session_id).to.equal(mock_conv2.session_id);\n  expect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "b0714c38-aaf1-49eb-9638-08393df3a4a5",
      "parentUUID": "e430a129-ab3c-476d-9af1-d96840e155e8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "removeConversation Nel caso in cui una conversazione non venga eliminata a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \"error removing conversation\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "7d38a74b-deb5-4ad3-95ab-46e7b1a6ae9e",
      "parentUUID": "b9275f54-5a82-49df-b283-cce9d5a9beb3",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una conversazione sia eliminata correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "fullTitle": "removeConversation Nel caso in cui una conversazione sia eliminata correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "conv.removeConversation(2).subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \"success\" });\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "b4e04b39-2d53-4374-824d-77b9d236e686",
      "parentUUID": "b9275f54-5a82-49df-b283-cce9d5a9beb3",
      "skipped": false
    },
    {
      "title": "La risposta deve avere il campo name del context uguale a 'admin' nel caso in cui l'utente sia stato riconosciuto come possibile amministratore.",
      "fullTitle": "webhook La risposta deve avere il campo name del context uguale a 'admin' nel caso in cui l'utente sia stato riconosciuto come possibile amministratore.",
      "timedOut": false,
      "duration": 3,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "body.result.action = 'user.check';\nlet ev = {body: JSON.stringify(body)};\nusers_DAO.getUserList.returns(Rx.Observable.of({ name : \"Mauro Carlin\", username : \"mou\"}));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\n//expect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property('name', 'admin');",
      "err": {},
      "isRoot": false,
      "uuid": "3c54a623-22f5-4647-be31-47d4c602ea32",
      "parentUUID": "c8d8e18b-9394-4c7a-96c5-12f32dfea16a",
      "skipped": false
    },
    {
      "title": "La risposta deve avere il campo name del context uguale a 'welcome' nel caso in cui l'utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.",
      "fullTitle": "webhook La risposta deve avere il campo name del context uguale a 'welcome' nel caso in cui l'utente sia stato riconosciuto come ospite che ha avuto interazioni passate con il sistema.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "body.result.action = 'guest.check';\nlet ev = {body: JSON.stringify(body)};\nguests_DAO.getGuestList.returns(Rx.Observable.of([{ name : \"Mauro Carlin\", username : \"mou\", company : \"Google\"}]));\nservice.webhook(ev, context);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).not.to.be.null;\nexpect(JSON.parse(call.args[0].body).contextOut[0]).to.have.deep.property('name', 'welcome');",
      "err": {},
      "isRoot": false,
      "uuid": "ad6f86ce-baef-48da-905c-9435a09d3ccc",
      "parentUUID": "c8d8e18b-9394-4c7a-96c5-12f32dfea16a",
      "skipped": false
    },
    {
      "title": "Deve sollevare un'eccezione se viene chiamato.",
      "fullTitle": "next Deve sollevare un'eccezione se viene chiamato.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "expect(obs.next.bind(obs)).to.throw();",
      "err": {},
      "isRoot": false,
      "uuid": "dfd0ca0b-ac0c-436e-a913-cd9b4969efaa",
      "parentUUID": "756a3b68-64c5-4bb5-9c1e-59dbcc996680",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "addGuest Nel caso in cui un ospite non venga aggiunto a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.addGuest().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode:400, message:\"Requested resource not found\"});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "dc95fe5e-76a5-4fba-ad11-eba62b1325d1",
      "parentUUID": "4a8f5f62-5c15-4f2f-8ce3-79210567d0ee",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un ospite sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "fullTitle": "addGuest Nel caso in cui un ospite sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.addGuest('mauro','Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "f066f453-69fa-4926-bf8f-05eef32d8025",
      "parentUUID": "4a8f5f62-5c15-4f2f-8ce3-79210567d0ee",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "getGuest Nel caso in cui un ospite non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.getGuest('Mauro', 'Zero12').subscribe(\n          {\n            next: next,\n            error: error,\n            complete: complete\n          });\n          dynamo_client.get.yield({ statusCode : 500, message : \"error getting data\" });\n          expect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "c61f3362-04cf-4598-a65c-de16c8640d3d",
      "parentUUID": "9a1d8c07-ea5b-4d5d-8439-26640542c387",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "fullTitle": "getGuest Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.getGuest('Mauro', 'Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.get.yield(null, { Item:{name : \"Mauro\", company : \"Zero12\" }});\nexpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal( \"Mauro\");\n\t\t\t\t\texpect(callNext.args[0].company).to.equal(\"Zero12\");\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "bd7fd340-1a6f-474e-a23f-8fac1e080e6d",
      "parentUUID": "9a1d8c07-ea5b-4d5d-8439-26640542c387",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "getGuestList Nel caso in cui un blocco di ospiti non venga restituito a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{ name : \"Mauro\", company : \"Zero12\" }], LastEvaluatedKey: 'Piero'});\ndynamo_client.scan.yield(null, {Items: [{ name : \"Piero\", company : \"Google\" }], LastEvaluatedKey: 'Luca'});\ndynamo_client.scan.yield({ statusCode : 500 });\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('Mauro');\nexpect(callNext.args[0].company).to.equal('Zero12');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('Piero');\nexpect(callNext.args[0].company).to.equal('Google');\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "11e9802c-02e7-4a52-98f3-0f14e498bde6",
      "parentUUID": "dadef009-1355-4a77-87f5-3738bb7e66f8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "fullTitle": "getGuestList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'Observer iscritto, fino ad inviare tutte gli ospiti ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.getGuestList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name : \"Mauro\", company : \"Zero12\" }], LastEvaluatedKey: 'Piero'});\ndynamo_client.scan.yield(null, {Items: [{name : \"Piero\", company : \"Google\" }]});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('Mauro');\nexpect(callNext.args[0].company).to.equal('Zero12');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('Piero');\nexpect(callNext.args[0].company).to.equal('Google');\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "7a666708-c559-4ba8-a691-329a017e3fc1",
      "parentUUID": "dadef009-1355-4a77-87f5-3738bb7e66f8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "removeGuest Nel caso in cui un ospite non venga eliminato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.removeGuest('mou').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield({ statusCode : 500, message : \"error removing guest\" });\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "9e20406b-fa00-4116-a8ca-6e0529a7b354",
      "parentUUID": "ecda102d-8229-49e6-8ecf-4d8918f2a571",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un ospite sia eliminato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "fullTitle": "removeGuest Nel caso in cui un ospite sia eliminato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.removeGuest('mou','Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.delete.yield(null, { statusCode : 200, message : \"success\" });\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "ff719bb8-c323-4299-aa80-e357a2b668ff",
      "parentUUID": "ecda102d-8229-49e6-8ecf-4d8918f2a571",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "updateGuest Nel caso in cui un ospite non venga aggiornato a causa di un errore del DB, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.updateGuest('mou').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\"error updating guest\"});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "1a403bfa-73ba-408c-9db7-6c7b2633ed97",
      "parentUUID": "16b23eac-f406-487a-bf90-05d97938f888",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un ospite sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "fullTitle": "updateGuest Nel caso in cui un ospite sia aggiornato correttamente, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.updateGuest('mou','Zero12').subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "3b8240b9-4326-4022-8296-b59a8896b8fb",
      "parentUUID": "16b23eac-f406-487a-bf90-05d97938f888",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si provi ad aggiungere l'id di una conversazione gi presente, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "fullTitle": "addConversation Nel caso in cui si provi ad aggiungere l'id di una conversazione gi presente, l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.addConversation('Mauro', 'Zero12', 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield({ statusCode: 500 }, null);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);",
      "err": {},
      "isRoot": false,
      "uuid": "750c214e-81a1-4c9b-9752-6c4918b40401",
      "parentUUID": "0e2cba76-65dc-4050-b4eb-103509990c73",
      "skipped": false
    },
    {
      "title": "Nel caso in cui venga aggiunto correttamente l'id di una conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "fullTitle": "addConversation Nel caso in cui venga aggiunto correttamente l'id di una conversazione, l'Observable restituito deve chiamare il metodo complete dell'Observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "guests.addConversation('Mauro', 'Zero12', 2).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.update.yield(null, { Attributes: {conversations: [1,2] }});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "2c22e6b9-297c-467c-b9d1-381785ab4859",
      "parentUUID": "0e2cba76-65dc-4050-b4eb-103509990c73",
      "skipped": false
    },
    {
      "title": "Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
      "fullTitle": "addMember Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "members.addMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "02c90b6d-866c-4d20-9039-4360eda8cccd",
      "parentUUID": "9af67e4a-18cf-4645-90d6-25862c96083d",
      "skipped": false
    },
    {
      "title": "Nel caso in cui il metodo ottenga il membro dell'azienda allora l'Observable invia tale Member all'Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.",
      "fullTitle": "getMember Nel caso in cui il metodo ottenga il membro dell'azienda allora l'Observable invia tale Member all'Observer iscritto tramite il metodo next e lo notifica richiamando una sola volta il metodo complete.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "members.getMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Docs: https://api.slack.com/methods/users.info\nlet res =\n{\n\t'ok': true,\n\t'user':\n\t{\n\t\t'id': 'U023BECGF',\n\t\t'name': 'bobby',\n\t\t'deleted': false,\n\t\t'color': '9f69e7',\n\t\t'profile':\n\t\t{\n\t\t\t'avatar_hash': 'ge3b51ca72de',\n\t\t\t'current_status': ':mountain_railway: riding a train',\n\t\t\t'first_name': 'Bobby',\n\t\t\t'last_name': 'Tables',\n\t\t\t'real_name': 'Bobby Tables',\n\t\t\t'email': 'bobby@slack.com',\n\t\t\t'skype': 'my-skype-name',\n\t\t\t'phone': '+1 (123) 456 7890'\n\t\t},\n\t\t'is_admin': true,\n\t\t'is_owner': true,\n\t\t'updated': 1490054400,\n\t\t'has_2fa': true\n\t}\n};\nweb_client.users.info.yield(null, res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].id).to.equal(res.user.id);\nexpect(callNext.args[0].name).to.equal(res.user.name);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "ff5aefbd-f636-4c74-a713-a44af12b6cd8",
      "parentUUID": "f496455b-3885-46b8-a45d-b91c857490d2",
      "skipped": false
    },
    {
      "title": "Se si verifica un errore nell'ottenere il membro dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
      "fullTitle": "getMember Se si verifica un errore nell'ottenere il membro dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "members.getMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t'ok': false,\n\t'error': 'not_authed'\n}\nweb_client.users.info.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal('not_authed');\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "863e06bc-cf24-4155-8e0c-1adb021ed578",
      "parentUUID": "f496455b-3885-46b8-a45d-b91c857490d2",
      "skipped": false
    },
    {
      "title": "L'Observable deve notificare l'Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.",
      "fullTitle": "getMemberList L'Observable deve notificare l'Observer con il metodo complete solo dopo aver inviato tutti i Member tramite il metodo next.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nlet res =\n{\n\t\"ok\": true,\n\t\"members\":\n\t[\n\t\t{\n\t\t\t\"id\": \"U023BECGF\",\n\t\t\t\"team_id\": \"T021F9ZE2\",\n\t\t\t\"name\": \"mauro\",\n\t\t\t\"deleted\": false,\n\t\t\t\"status\": null,\n\t\t\t\"color\": \"9f69e7\",\n\t\t\t\"real_name\": \"Mauro Bocciofilo\",\n\t\t\t\"tz\": \"America\\/Los_Angeles\",\n\t\t\t\"tz_label\": \"Pacific Daylight Time\",\n\t\t\t\"tz_offset\": -25200,\n\t\t\t\"profile\":\n\t\t\t{\n\t\t\t\t\"avatar_hash\": \"ge3b51ca72de\",\n\t\t\t\t\"current_status\": \":mountain_railway: riding a train\",\n\t\t\t\t\"first_name\": \"Bobby\",\n\t\t\t\t\"last_name\": \"Tables\",\n\t\t\t\t\"real_name\": \"Bobby Tables\",\n\t\t\t\t\"email\": \"bobby@slack.com\",\n\t\t\t\t\"skype\": \"my-skype-name\",\n\t\t\t\t\"phone\": \"+1 (123) 456 7890\"\n\t\t\t},\n\t\t\t\"is_admin\": true,\n\t\t\t\"is_owner\": true,\n\t\t\t\"updated\": 1490054400,\n\t\t\t\"has_2fa\": false\n\t\t},\n\t\t{\n\t\t\t\"id\": \"U023BECLL\",\n\t\t\t\"team_id\": \"T021F9ZE2\",\n\t\t\t\"name\": \"bobby\",\n\t\t\t\"deleted\": false,\n\t\t\t\"status\": null,\n\t\t\t\"color\": \"9f69e7\",\n\t\t\t\"real_name\": \"Bobby Tables\",\n\t\t\t\"tz\": \"America\\/Los_Angeles\",\n\t\t\t\"tz_label\": \"Pacific Daylight Time\",\n\t\t\t\"tz_offset\": -25200,\n\t\t\t\"profile\":\n\t\t\t{\n\t\t\t\t\"avatar_hash\": \"ge3b51ca72de\",\n\t\t\t\t\"current_status\": \":mountain_railway: riding a train\",\n\t\t\t\t\"first_name\": \"Bobby\",\n\t\t\t\t\"last_name\": \"Tables\",\n\t\t\t\t\"real_name\": \"Bobby Tables\",\n\t\t\t\t\"email\": \"bobby@slack.com\",\n\t\t\t\t\"skype\": \"my-skype-name\",\n\t\t\t\t\"phone\": \"+1 (123) 456 7890\",\n\t\t\t},\n\t\t\t\"is_admin\": true,\n\t\t\t\"is_owner\": true,\n\t\t\t\"updated\": 1490054400,\n\t\t\t\"has_2fa\": false\n\t\t}\n\t]\n}\nweb_client.users.list.yield(null,res);\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(1);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].members[0].id).to.equal(res.members[0].id);\nexpect(callNext.args[0].members[0].name).to.equal(res.members[0].name);\nexpect(callNext.args[0].members[1].id).to.equal(res.members[1].id);\nexpect(callNext.args[0].members[1].name).to.equal(res.members[1].name);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "b734ee6e-a8cf-447b-8980-62e7803d3734",
      "parentUUID": "75f84416-5a90-49df-9969-8fe6b9ce7f77",
      "skipped": false
    },
    {
      "title": "Se si verifica un errore nell'ottenere la lista dei membri dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
      "fullTitle": "getMemberList Se si verifica un errore nell'ottenere la lista dei membri dell'azienda, l'Observable deve notificare l'Observer iscritto richiamando il metodo error.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "members.getMemberList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\n//Esempio di errore (https://api.slack.com/methods/users.info/test)\nlet res =\n{\n\t'ok': false,\n\t'error': 'not_authed'\n}\nweb_client.users.list.yield(res);\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].ok).to.equal(false);\nexpect(callError.args[0].error).to.equal('not_authed');\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "45d2c132-4196-4121-bfc3-2941853864cc",
      "parentUUID": "75f84416-5a90-49df-9969-8fe6b9ce7f77",
      "skipped": false
    },
    {
      "title": "Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
      "fullTitle": "removeMember Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "members.removeMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "a5d59fe5-2a67-4407-8b93-70e32d0a391a",
      "parentUUID": "b55027f0-3c8d-4942-8d33-906e3a6b27de",
      "skipped": false
    },
    {
      "title": "Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
      "fullTitle": "updateMember Anche se viene passato un Member corretto, l'ErrorObservable ritornato deve notificare l'Observer richiamando il suo metodo error.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "members.updateMember('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nexpect(error.callCount).to.equal(1);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "1f57d3f5-677b-44ed-8d66-1a120667b18d",
      "parentUUID": "ee9569e5-5359-4b17-8858-1b444fdecd21",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui canali a Slack, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 3,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = {body: '', queryStringParameters: ''};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields('errore');\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property('statusCode', 500);\n  done();\n}",
      "err": {},
      "isRoot": false,
      "uuid": "a03595bc-4005-47dc-8f88-9f35fb5d3093",
      "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sugli utenti a Slack, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = {body: '', queryStringParameters: ''};\n          service.getChannelList(ev, context);\n          client.groups.list.yields(null, groups);\n          client.users.list.yields('errore');\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property('statusCode', 500);\n            done();\n          }",
      "err": {},
      "isRoot": false,
      "uuid": "614e27bb-15a4-472e-bef7-beba02ee0f64",
      "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "getChannelList Nel caso in cui si verifichi un errore nella richiesta delle informazioni sui gruppi a Slack, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = {body: '', queryStringParameters: ''};\n          service.getChannelList(ev, context);\n          client.groups.list.yields('errore');\n          client.users.list.yields(null, users);\n          client.channels.list.yields(null, channels);\n          context.succeed = function(args)\n          {\n            expect(args).to.have.property('statusCode', 500);\n            done();\n          }",
      "err": {},
      "isRoot": false,
      "uuid": "15ec6b31-d1f3-419c-87fb-ac3350c32f2d",
      "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.",
      "fullTitle": "getChannelList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista dei canali Slack (utenti, canali pubblici e gruppi privati) in formato JSON.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = {body: '', queryStringParameters: null};\nservice.getChannelList(ev, context);\nclient.groups.list.yields(null, groups);\nclient.users.list.yields(null, users);\nclient.channels.list.yields(null, channels);\ncontext.succeed = function(args)\n{\n  expect(args).to.have.property('statusCode', 200);\n  done();\n}",
      "err": {},
      "isRoot": false,
      "uuid": "e7d3f27b-f8e4-42ec-91ba-bbc1ed2da38c",
      "parentUUID": "1cea4c65-d253-45c9-bbbe-1757c1650056",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "sendMsg Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield('errore');\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "ae8cf8d6-4571-48fb-be84-956e4b9d6f30",
      "parentUUID": "66ed54d0-d725-42a7-9d8b-256e464c7d4d",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.",
      "fullTitle": "sendMsg Nel caso in cui non si verifichi alcun errore, il campo statusCode della risposta deve essere impostato a 200.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = {body: JSON.stringify(request_event)};\nservice.sendMsg(ev, context);\nclient.chat.postMessage.yield(null, responseSendMsg);\nexpect(context.succeed.callCount).to.equal(1);\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "b4c761ba-ee0e-4b8a-bff5-1f395660f1bc",
      "parentUUID": "66ed54d0-d725-42a7-9d8b-256e464c7d4d",
      "skipped": false
    },
    {
      "title": "Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
      "fullTitle": "sendMsg Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = {body: JSON.stringify(bad_request)};\nservice.sendMsg(ev, context);\n\nexpect(context.succeed.callCount).to.equal(1);\t\nlet call = context.succeed.getCall(0);\nexpect(call.args[0]).to.have.property('statusCode', 400);",
      "err": {},
      "isRoot": false,
      "uuid": "8a26cac5-7042-4edb-a571-29cf75d4ea72",
      "parentUUID": "66ed54d0-d725-42a7-9d8b-256e464c7d4d",
      "skipped": false
    },
    {
      "title": "Deve chiamare complete_cb",
      "fullTitle": "complete Deve chiamare complete_cb",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "obs.onComplete(success);\nobs.complete();\n        expect(success.callCount, \"il callback di complete non  stato chiamato esattamente una volta.\").to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "ef9c9039-f6f5-40d6-97d1-70b94fcd26db",
      "parentUUID": "59c5c0f1-bb37-4b83-9257-931e791a6665",
      "skipped": false
    },
    {
      "title": "Non deve chiamare complete_cb se l'observer  in pausa",
      "fullTitle": "complete Non deve chiamare complete_cb se l'observer  in pausa",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "obs.onComplete(success);\nobs.pause();\nobs.complete();\nexpect(success.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "6bcd6731-20e5-4535-90e3-8e5709f7ab8a",
      "parentUUID": "59c5c0f1-bb37-4b83-9257-931e791a6665",
      "skipped": false
    },
    {
      "title": "Deve chiamare complete_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
      "fullTitle": "complete Deve chiamare complete_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "obs.onComplete(success);\nobs.complete();\n        expect(success.callCount).to.equal(1);\nobs.pause();\n        obs.complete();\n        expect(success.callCount).to.equal(1);\nobs.resume();\n        expect(success.callCount).to.equal(2);",
      "err": {},
      "isRoot": false,
      "uuid": "ad63bef1-4072-4682-9079-624c2f18b53a",
      "parentUUID": "59c5c0f1-bb37-4b83-9257-931e791a6665",
      "skipped": false
    },
    {
      "title": "Deve chiamare error_cb",
      "fullTitle": "error Deve chiamare error_cb",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let err = new Error('Errore');\nobs.onError(success);\nobs.error(err);\n        let call = success.getCall(0);\n\n        expect(success.callCount).to.equal(1);\n        expect(call.args[0]).to.equal(err);",
      "err": {},
      "isRoot": false,
      "uuid": "ccd804ad-6a28-4339-9e0c-24f5a161d70d",
      "parentUUID": "1ec6d4e7-c568-4ec1-8285-20c05faaf50a",
      "skipped": false
    },
    {
      "title": "Non deve chiamare error_cb se l'observer  in pausa",
      "fullTitle": "error Non deve chiamare error_cb se l'observer  in pausa",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "obs.onError(success);\nobs.pause();\nobs.error('errore');\n        expect(success.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "e3a1cf5e-99cf-4258-9b89-b9b0cef7fd36",
      "parentUUID": "1ec6d4e7-c568-4ec1-8285-20c05faaf50a",
      "skipped": false
    },
    {
      "title": "Deve chiamare error_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
      "fullTitle": "error Deve chiamare error_cb dopo che l'observer  stato ripreso se, mentre era in pausa, il metodo  stato chiamato.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let err = new Error('Errore');\nobs.onError(success);\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.pause();\nobs.error(err);\n        expect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(2);\n        let call = success.getCall(1);\n        expect(call.args[0]).to.equal(err);",
      "err": {},
      "isRoot": false,
      "uuid": "e193717c-9272-4eb9-8ae7-100137f55ea9",
      "parentUUID": "1ec6d4e7-c568-4ec1-8285-20c05faaf50a",
      "skipped": false
    },
    {
      "title": "Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l'observer non  in pausa.",
      "fullTitle": "next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, se l'observer non  in pausa.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "obs.onNext(success);\nobs.next('data');\nexpect(success.callCount).to.equal(1);\nlet call = success.getCall(0);\nexpect(call.args[0]).to.equal('data');",
      "err": {},
      "isRoot": false,
      "uuid": "4ce1ffae-80fb-4cb2-ba87-03004aa1f785",
      "parentUUID": "8394b522-9ca0-4007-acbd-f56b5cdd4bdf",
      "skipped": false
    },
    {
      "title": "Non deve chiamare next_cb se l'observer  in pausa",
      "fullTitle": "next Non deve chiamare next_cb se l'observer  in pausa",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "obs.onNext(success);\nobs.pause();\nobs.next('Function called');\nexpect(success.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "6ffa568f-39f1-4a88-90a9-44c3c3ff1a11",
      "parentUUID": "8394b522-9ca0-4007-acbd-f56b5cdd4bdf",
      "skipped": false
    },
    {
      "title": "Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l'observer ha ripreso.",
      "fullTitle": "next Deve chiamare next_cb, inoltrandogli il parametro ricevuto, dopo che l'observer ha ripreso.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "obs.onNext(success);\nobs.next('data');\nexpect(success.callCount).to.equal(1);\nobs.pause();\nobs.next('data');\nexpect(success.callCount).to.equal(1);\nobs.resume();\nexpect(success.callCount).to.equal(1);\nobs.next('other data');\nexpect(success.callCount).to.equal(2);",
      "err": {},
      "isRoot": false,
      "uuid": "b7df49b6-2cc9-4415-8c28-cb59c4ed6391",
      "parentUUID": "8394b522-9ca0-4007-acbd-f56b5cdd4bdf",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "addRule Nel caso in cui una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.addRule(mock_rule).subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\"Requested resource not found\"});\nexpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "089db301-228f-4a19-a1af-36e3bcba89cb",
      "parentUUID": "7c6f9016-2624-40c3-8b6a-d16a274d03e1",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "addRule Nel caso in cui una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.addRule(mock_rule).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "4ac71995-fe96-4624-aa03-da1927853bce",
      "parentUUID": "7c6f9016-2624-40c3-8b6a-d16a274d03e1",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getRule Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.getRule(1).subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\"error getting data\"});\n        expect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "d62cbc44-0f55-463c-93ae-2d70c0f90b20",
      "parentUUID": "abf42e37-4b7b-484d-8800-a6bdda5f82c2",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getRule Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let observable = rules.getRule(1);\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_rule);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.Item.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "f297c8e6-2069-4f39-87c1-1cc923099ffa",
      "parentUUID": "abf42e37-4b7b-484d-8800-a6bdda5f82c2",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un blocco di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getRuleList Nel caso in cui un blocco di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2],LastEvaluatedKey:3});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "cfb14092-49d1-4c90-8294-1a0e823bbb40",
      "parentUUID": "63b3612e-8067-4d44-ba08-8bd0a4b9892a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getRuleList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.getRuleList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule],LastEvaluatedKey:2});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_rule2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule.id);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].id).to.equal(mock_rule2.id);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "75bf4c6a-663d-4e20-beae-eb17a150cc2e",
      "parentUUID": "63b3612e-8067-4d44-ba08-8bd0a4b9892a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getRuleList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "//da definire",
      "err": {},
      "isRoot": false,
      "uuid": "1a785b97-b413-4d56-88df-895cac1ccaab",
      "parentUUID": "63b3612e-8067-4d44-ba08-8bd0a4b9892a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "removeRule Nel caso in cui una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\"error removing rule\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "caa39041-0f72-4888-90c8-65c61336a1a3",
      "parentUUID": "423e1330-63d3-4117-b3f4-628dd1233ea5",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "removeRule Nel caso in cui una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.removeRule(1).subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\"success\"});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "bd963fc4-421e-4c38-b7de-05eae863be08",
      "parentUUID": "423e1330-63d3-4117-b3f4-628dd1233ea5",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "updateRule Nel caso in cui una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message:\"error updating rule\"});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "bd274684-4120-49d6-b2de-cb7323b9fb09",
      "parentUUID": "d89bcd03-42ad-4e60-91be-b78a848e33ea",
      "skipped": false
    },
    {
      "title": "Nel caso in cui una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "updateRule Nel caso in cui una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rules.updateRule(1).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "95b845b3-a047-4201-a321-ba4f89ed81d9",
      "parentUUID": "d89bcd03-42ad-4e60-91be-b78a848e33ea",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
      "fullTitle": "addRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: \"\"};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 400);",
      "err": {},
      "isRoot": false,
      "uuid": "c42876a2-86d4-482b-8da3-ede34ad9213f",
      "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "addRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.addRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "0e1fc861-dca2-4a2d-8e2f-860f4a40942f",
      "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
      "fullTitle": "addRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.addRule.returns(Rx.Observable.empty());\nlet ev = {body: JSON.stringify(rule)};\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "c763b098-1ad3-41f3-82f1-edbd4ba347bd",
      "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
      "skipped": false
    },
    {
      "title": "Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
      "fullTitle": "addRule Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.addRule.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\nlet ev = { body: JSON.stringify(rule) };\nrules.addRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Conflict' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 409);",
      "err": {},
      "isRoot": false,
      "uuid": "a015e9da-bf4e-458e-81c7-b7a34c72cdd0",
      "parentUUID": "aa669ad2-bbd3-41f2-986b-1c4a8458adc9",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "deleteRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.removeRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "29852138-9793-4a61-82dd-f284c94406cd",
      "parentUUID": "5313bfde-f4d8-4ba7-9f07-ba7680c064e4",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
      "fullTitle": "deleteRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.removeRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }};\nrules.deleteRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "66e7deee-a097-4f35-a8fa-842d0d1fdbcb",
      "parentUUID": "5313bfde-f4d8-4ba7-9f07-ba7680c064e4",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
      "fullTitle": "deleteRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "{\n  rulesDAO.removeRule.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\n  let ev = {pathParameters: { id: 1 }};\n  rules.deleteRule(ev, context);\n  let call = context.succeed.getCall(0);\n  expect(context.succeed.calledOnce).to.be.true;\n  expect(call.args[0]).not.to.be.null;\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\n  \t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 404);\n};",
      "err": {},
      "isRoot": false,
      "uuid": "c6a70335-3dfc-41c1-b57f-51a24c3b3d72",
      "parentUUID": "5313bfde-f4d8-4ba7-9f07-ba7680c064e4",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.",
      "fullTitle": "getRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la Rule cercata.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.getRule.returns(Rx.Observable.of(rule));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify(rule));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "b862d873-13ab-4147-93a1-973bde319874",
      "parentUUID": "fc64a12a-bf9c-4ce2-8c4f-0f62b1fe073f",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "getRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.getRule.returns(Rx.Observable.throw(new Error()));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "326099c3-e462-4b7d-a2cf-e9b185586fee",
      "parentUUID": "fc64a12a-bf9c-4ce2-8c4f-0f62b1fe073f",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
      "fullTitle": "getRule Nel caso in cui la Rule richiesta non sia disponibile, il campo statusCode della risposta deve essere impostato a 404.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.getRule.returns(Rx.Observable.throw({ code: 'Not found' }));\nlet ev = {pathParameters: { id: 1 }};\nrules.getRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 404);",
      "err": {},
      "isRoot": false,
      "uuid": "44d6c908-c026-4f9c-ace3-bb1a06996727",
      "parentUUID": "fc64a12a-bf9c-4ce2-8c4f-0f62b1fe073f",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.",
      "fullTitle": "getRuleList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista delle Rule.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.getRuleList.returns(Rx.Observable.of(rule_1, rule_2));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ rules: [rule_1, rule_2] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "aa1d48d6-198a-4af4-afac-c7db759a1f38",
      "parentUUID": "d73704ca-5230-41e5-8743-f3f3736b1622",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "getRuleList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.getRuleList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getRuleList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "c72d60cd-1b2c-40c6-935b-d6652128f8df",
      "parentUUID": "d73704ca-5230-41e5-8743-f3f3736b1622",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.",
      "fullTitle": "getTaskList Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200 e il campo body deve contenere la lista dei Task.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "taskDAO.getTaskList.returns(Rx.Observable.of(task_1));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ tasks: [task_1] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "116af487-0d65-4a4d-a337-8b1877a1d9cd",
      "parentUUID": "02c31782-3d8b-4a20-9866-3e283c5dfc71",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "getTaskList Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "taskDAO.getTaskList.returns(Rx.Observable.throw(new Error()));\nlet ev = {};\nrules.getTaskList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "a28ec737-df8e-4c62-818f-82c5ab39be61",
      "parentUUID": "02c31782-3d8b-4a20-9866-3e283c5dfc71",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
      "fullTitle": "updateRule Nel caso in cui la chiamata al metodo vada a buon fine, il campo statusCode della risposta deve essere impostato a 200.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.updateRule.returns(Rx.Observable.empty());\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "6b1cc0eb-5a3b-4c05-8b3a-4bdf0221c572",
      "parentUUID": "0cd041b3-ae95-4251-b4f8-b914d0cb3135",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
      "fullTitle": "updateRule Nel caso in cui la chiamata al metodo venga fatta con un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: \"\" , body: \"\"};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 400);",
      "err": {},
      "isRoot": false,
      "uuid": "9e880780-5b00-4cae-98e7-d55e9547d9fe",
      "parentUUID": "0cd041b3-ae95-4251-b4f8-b914d0cb3135",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "fullTitle": "updateRule Nel caso in cui la chiamata al metodo generi un errore del microservizio, il campo statusCode della risposta deve essere impostato a 500.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "rulesDAO.updateRule.returns(Rx.Observable.throw(new Error));\nlet ev = {pathParameters: { id: 1 }, body: JSON.stringify(rule)};\nrules.updateRule(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "b9ef09a1-5610-46f7-b448-23e2c1fa9d78",
      "parentUUID": "0cd041b3-ae95-4251-b4f8-b914d0cb3135",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "addTask Nel caso in cui la funzione di una direttiva non venga aggiunta a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.addTask(mock_task).subscribe(\n\t\t\t\t\t{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\t\t\t\t\tdynamo_client.put.yield({statusCode:400, message:\"Requested resource not found\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "a276b1eb-82b7-4cf5-b8a0-36d29f31be3c",
      "parentUUID": "b9a9fc5d-6685-416d-8b86-7f1b637b3e49",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "addTask Nel caso in cui la funzione di una direttiva sia aggiunta correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.addTask(mock_task).subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "df25eabe-4714-423f-b556-4ad97e51757e",
      "parentUUID": "b9a9fc5d-6685-416d-8b86-7f1b637b3e49",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getTask Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.getTask('mock_type').subscribe(\n        {\n          next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n        });\n        dynamo_client.get.yield({statusCode:500, message:\"error getting data\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "c7ac7543-162a-4438-b32e-73661278a15e",
      "parentUUID": "30151355-dc16-413c-a70a-47ff8e09efa5",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getTask Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let observable = tasks.getTask('mock_type');\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.get.yield(null, mock_task);\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.Item.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "7fdfd483-1ca7-442b-a53a-ed9394370f36",
      "parentUUID": "30151355-dc16-413c-a70a-47ff8e09efa5",
      "skipped": false
    },
    {
      "title": "Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getTaskList Nel caso in cui un blocco di funzioni di direttive non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{mock_task}], LastEvaluatedKey: \"mock_type2\"});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items: [{mock_task2}], LastEvaluatedKey: \"mock_type3\"});\n\t\t\t\t\tdynamo_client.scan.yield({statusCode: 500});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "55fbad25-7a07-4799-84b5-4272348136aa",
      "parentUUID": "2fef8d26-d97d-4580-9522-a3ac93cb3059",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getTaskList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 8,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.getTaskList().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task],LastEvaluatedKey:\"mock_type2\"});\n\t\t\t\t\tdynamo_client.scan.yield(null, {Items:[mock_task2]});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(next.callCount).to.equal(2);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task.type);\n\t\t\t\t\tcallNext = next.getCall(1);\n\t\t\t\t\texpect(callNext.args[0].type).to.equal(mock_task2.type);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "3b4895e9-e4ae-4490-a218-dd0021254961",
      "parentUUID": "2fef8d26-d97d-4580-9522-a3ac93cb3059",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "removeTask Nel caso in cui la funzione di una direttiva non venga rimossa a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.removeTask('mock_type').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield({statusCode: 500, message:\"error removing rule\"});\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "e4ed2919-9ce3-4633-89e4-e1cd5f574a4d",
      "parentUUID": "bdb9059f-2f29-4b41-980f-4173950eac2e",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "removeTask Nel caso in cui la funzione di una direttiva sia rimossa correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.removeTask('mock_type').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {statusCode: 200, message:\"success\"});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "44f04a09-2ed0-44ea-a85d-612b1b2735ad",
      "parentUUID": "bdb9059f-2f29-4b41-980f-4173950eac2e",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "updateTask Nel caso in cui la funzione di una direttiva non venga aggiornata a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.updateTask('mock_type').subscribe(\n{\n            next: next,\n  \t\t\t\t\terror: error,\n  \t\t\t\t\tcomplete: complete\n  \t\t\t\t});\n  \t\t\t\t\tdynamo_client.put.yield({statusCode: 500, message:\"error updating rule\"});\n\texpect(error.callCount).to.equal(1);\n\tlet callError = error.getCall(0);\n\texpect(callError.args[0].statusCode).to.equal(500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "ef2806e7-70c2-4af8-97f5-ff003d6baf7e",
      "parentUUID": "23924557-8f5b-44fb-982a-9d6448e20d57",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "updateTask Nel caso in cui la funzione di una direttiva sia aggiornata correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "tasks.updateTask('mock_type').subscribe(\n{\n            next: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\n          expect(error.callCount).to.equal(0);\n          expect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "885c756f-cfdc-48d1-b42c-442a960578ed",
      "parentUUID": "23924557-8f5b-44fb-982a-9d6448e20d57",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'utente non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "addUser Nel caso in cui l'utente non venga aggiunto a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.addUser('mou').subscribe(\n\t\t\t\t\t{\n\t\t\t\t\t\tnext: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n\t\t\t\t\t});\n\n\t\t\t\t\t//TableName: [nome tabella che non esiste]\n\t\t\t\t\tdynamo_client.put.yield({statusCode: 400, message:\"Requested resource not found\"});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(400);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "83390f62-e457-4833-a4f7-363b187fc70f",
      "parentUUID": "86e1fc1f-283c-43bb-8db0-c8a7180e4a11",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'utente sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "addUser Nel caso in cui l'utente sia aggiunto correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.addUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "1b3cc114-22b1-4b8e-b3a5-9d09c8f6ae55",
      "parentUUID": "86e1fc1f-283c-43bb-8db0-c8a7180e4a11",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getUser Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.getUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.get.yield({statusCode: 500, message:\"error getting data\"});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "5e3bf7fa-7013-490f-8e25-c75a17d65dd4",
      "parentUUID": "5a59f620-7101-415c-bb68-753a76c4a91a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getUser Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let observable = users.getUser('mou');\nobservable.subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.get.yield(null, {Item: {name: \"mauro\", username: \"mou\"}});\n\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\n\t\t\t\t\texpect(next.callCount).to.equal(1);\n\t\t\t\t\tlet callNext = next.getCall(0);\n\t\t\t\t\texpect(callNext.args[0].name).to.equal('mauro');\n\t\t\t\t\texpect(callNext.args[0].username).to.equal('mou');\n\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "2f0b6bb3-924d-4ab8-af71-3a6c83f48e70",
      "parentUUID": "5a59f620-7101-415c-bb68-753a76c4a91a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "getUserList Nel caso in cui si verifichi un errore nell'interrogazione del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'piero'});\ndynamo_client.scan.yield(null, {Items: [{name: \"piero\", username: \"sun\"}], LastEvaluatedKey: 'marco'});\ndynamo_client.scan.yield({statusCode: 500});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\n\n          expect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('piero');\nexpect(callNext.args[0].username).to.equal('sun');\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "1bafd5a7-696d-4e0a-af34-cec10d210af2",
      "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getUserList Nel caso in cui l'interrogazione del DB vada a buon fine, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'piero'});\ndynamo_client.scan.yield(null, {Items: [{name: \"piero\", username: \"sun\"}]}); // Ultimo elemento da ottenere\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('piero');\nexpect(callNext.args[0].username).to.equal('sun');\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "06b74b70-c937-420b-a443-0405f46da7b6",
      "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con un solo attributo, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let query =\n{\n\tname: 'mauro'\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'sun'});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"sun\"}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property('FilterExpression', 'full_name = :full_name');\nexpect(callScan.args[0]).to.have.deep.property('ExpressionAttributeValues.:full_name', 'mauro' );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('sun');",
      "err": {},
      "isRoot": false,
      "uuid": "899a4b20-6042-45fa-8e66-898436549096",
      "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "fullTitle": "getUserList Nel caso in cui il metodo venga chiamato con queryStringParameters con due attributi, l'Observable restituito deve chiamare il metodo next dell'observer iscritto con i dati filtrati ottenuti dall'interrogazione, ed in seguito il metodo complete un'unica volta.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let query =\n{\n\tname: 'mauro',\n\tslack_channel: 'channel'\n};\nusers.getUserList(query).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"mou\"}], LastEvaluatedKey: 'sun'});\ndynamo_client.scan.yield(null, {Items: [{name: \"mauro\", username: \"sun\"}]}); // Ultimo elemento da ottenere\nlet callScan = dynamo_client.scan.getCall(0);\n          expect(callScan.args[0]).to.have.deep.property('FilterExpression', 'full_name = :full_name and slack_channel = :slack_channel');\nexpect(callScan.args[0]).to.have.deep.property('ExpressionAttributeValues.:full_name', 'mauro' );\nexpect(callScan.args[0]).to.have.deep.property('ExpressionAttributeValues.:slack_channel', 'channel' );\nexpect(error.callCount).to.equal(0);\nexpect(next.callCount).to.equal(2);\nlet callNext = next.getCall(0);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('mou');\ncallNext = next.getCall(1);\nexpect(callNext.args[0].name).to.equal('mauro');\nexpect(callNext.args[0].username).to.equal('sun');",
      "err": {},
      "isRoot": false,
      "uuid": "3795bb44-9d26-4560-9346-92c7e731a900",
      "parentUUID": "355ddd49-624c-4820-9fa4-1b59e66f81e8",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'utente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "removeUser Nel caso in cui l'utente non venga rimosso a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.removeUser('mou').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\n\n\t\t\t\t\tdynamo_client.delete.yield({statusCode: 500, message: \"error removing user\"});\n\n\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\tlet callError = error.getCall(0);\n\t\t\t\t\texpect(callError.args[0].statusCode).to.equal(500);\n\n\t\t\t\t\texpect(next.callCount).to.equal(0);\n\n\t\t\t\t\texpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "53ac7672-612e-4787-9785-54a42920be9d",
      "parentUUID": "51ad4ccd-ddb6-4050-bfa8-85b53ef84e53",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'utente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta",
      "fullTitle": "removeUser Nel caso in cui l'utente sia rimosso correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.removeUser('mou').subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\ndynamo_client.delete.yield(null, {});\n\t\t\t\t\texpect(error.callCount).to.equal(0);\n\t\t\t\t\texpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "37d4128b-b13b-4066-81cb-67abf9163c26",
      "parentUUID": "51ad4ccd-ddb6-4050-bfa8-85b53ef84e53",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'utente non venga modificato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "fullTitle": "updateUser Nel caso in cui l'utente non venga modificato a causa di un'errore del DB, l'Observable ritornato deve chiamare il metodo error dell'observer iscritto.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.updateUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield({statusCode: 500, message: \"error updating user\"});\nexpect(error.callCount).to.equal(1);\nlet callError = error.getCall(0);\nexpect(callError.args[0].statusCode).to.equal(500);\nexpect(next.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(0);",
      "err": {},
      "isRoot": false,
      "uuid": "c9d72e9b-400e-4a63-8a5a-0bb42072df45",
      "parentUUID": "39f8b44e-228f-4e9d-b5d2-85e7338d6e56",
      "skipped": false
    },
    {
      "title": "Nel caso in cui l'utente sia modificato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "fullTitle": "updateUser Nel caso in cui l'utente sia modificato correttamente, l'Observable restituito deve chiamare il metodo complete dell'observer iscritto un'unica volta.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users.updateUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\ndynamo_client.put.yield(null, {});\nexpect(error.callCount).to.equal(0);\nexpect(complete.callCount).to.equal(1);",
      "err": {},
      "isRoot": false,
      "uuid": "6ec9eb13-06e0-4d4a-90c3-0c061c3a7032",
      "parentUUID": "39f8b44e-228f-4e9d-b5d2-85e7338d6e56",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "fullTitle": "addUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\nlet user=\n{\n  name: \"Mauro\",\n  username: \"mou\"\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "c6a2295e-ba40-4f1a-8628-cd97ae2bf1e6",
      "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
      "fullTitle": "addUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.addUser.returns(Rx.Observable.empty());\nlet user=\n{\n  name: \"Mauro\",\n  username: \"mou\"\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "5e5830df-00ce-408a-a900-ab0e9c6c0797",
      "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
      "skipped": false
    },
    {
      "title": "Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
      "fullTitle": "addUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.addUser.returns(Rx.Observable.throw(new Error()));\n          let ev = { body: \"\" };\n          service.addUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\n\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 400);",
      "err": {},
      "isRoot": false,
      "uuid": "4f3d3c4a-eb50-4fa1-9c1c-3d6cc2090d59",
      "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
      "skipped": false
    },
    {
      "title": "Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
      "fullTitle": "addUser Nel caso in cui sia passato un oggetto la cui chiave primaria  uguale a quella di un oggetto gi esistente, il campo statusCode della risposta deve essere impostato a 409",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.addUser.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\nlet user=\n{\n  name: \"Mauro\",\n  username: \"mou\"\n};\nlet ev = { body: JSON.stringify(user) };\nservice.addUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Conflict' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 409);",
      "err": {},
      "isRoot": false,
      "uuid": "687ee9d9-9f48-4e81-9f18-904b1bb8dca7",
      "parentUUID": "08867b43-ebe0-478d-9686-c6f6221cb1f6",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "fullTitle": "deleteUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.removeUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: 'mou' }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "99ddf7d8-5cd8-4bb2-84bd-0931669279b1",
      "parentUUID": "ad7d0256-dcc0-44d8-bb37-a96ec436d965",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
      "fullTitle": "deleteUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.removeUser.returns(Rx.Observable.empty());\nlet ev = { pathParameters: { username: 'mou' }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "40f01a52-b13e-46df-958c-0f237f509ac6",
      "parentUUID": "ad7d0256-dcc0-44d8-bb37-a96ec436d965",
      "skipped": false
    },
    {
      "title": "Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
      "fullTitle": "deleteUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.removeUser.returns(Rx.Observable.throw({ code: 'ConditionalCheckFailedException' }));\nlet ev = { pathParameters: { username: 'pippo' }};\nservice.deleteUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 404);",
      "err": {},
      "isRoot": false,
      "uuid": "2a1dfcc2-b9d7-4023-ac73-f6b3783bf264",
      "parentUUID": "ad7d0256-dcc0-44d8-bb37-a96ec436d965",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "fullTitle": "getUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.getUser.returns(Rx.Observable.throw(new Error()));\nlet ev = { pathParameters: { username: 'mou'} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "48db7279-31e0-4233-80ed-422f789105fb",
      "parentUUID": "d08d3ef1-a1f7-4218-bd16-3f1f61bc779c",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l'utente richiesto",
      "fullTitle": "getUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere l'utente richiesto",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.getUser.returns(Rx.Observable.of({ name : 'Mauro', username : 'mou' }));\nlet ev = { pathParameters: { username: 'mou'} };\nservice.getUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ name : 'Mauro', username : 'mou' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "3cdcaca0-379d-4a4d-9477-26e429c38528",
      "parentUUID": "d08d3ef1-a1f7-4218-bd16-3f1f61bc779c",
      "skipped": false
    },
    {
      "title": "Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
      "fullTitle": "getUser Nel caso in cui sia passato uno username non esistente, il campo statusCode della risposta deve essere impostato a 404",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.getUser.returns(Rx.Observable.throw({ code: 'Not found' }));\n          let ev = { pathParameters: { username: 'pippo'} };\n          service.getUser(ev, context);\n          let call = context.succeed.getCall(0);\n          expect(context.succeed.calledOnce).to.be.true;\n          expect(call.args[0]).not.to.be.null;\n          expect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Not found' }));\nexpect(call.args[0]).to.have.deep.property('statusCode', 404);",
      "err": {},
      "isRoot": false,
      "uuid": "21292dce-2ca3-4f92-a8e4-b25640dd6198",
      "parentUUID": "d08d3ef1-a1f7-4218-bd16-3f1f61bc779c",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "fullTitle": "getUserList Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.getUserList.returns(Rx.Observable.throw(new Error()));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "5aa15209-a566-4a0d-8c59-c211b9784440",
      "parentUUID": "8b17897e-5dda-49ca-a254-e36f1ff1a75f",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti",
      "fullTitle": "getUserList Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200 ed il corpo della risposta deve contenere la lista degli utenti",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.getUserList.returns(Rx.Observable.of({ name : 'Mauro', username : 'mou' }, { name : 'Nicola', username : 'tinto' }));\nlet ev = { queryStringParameters: {} };\nservice.getUserList(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ users: [{ name : 'Mauro', username : 'mou' }, { name : 'Nicola', username : 'tinto' }] }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "5a430af6-5708-466b-ad31-cbeb0d6be891",
      "parentUUID": "8b17897e-5dda-49ca-a254-e36f1ff1a75f",
      "skipped": false
    },
    {
      "title": "Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "fullTitle": "updateUser Nel caso in cui si verifichi un errore, il campo statusCode della risposta deve essere impostato a 500",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.updateUser.returns(Rx.Observable.throw(new Error()));\nlet user =\n{\n  name: \"gianluca\"\n};\nlet ev = { pathParameters: \"mou\", body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Internal server error' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 500);",
      "err": {},
      "isRoot": false,
      "uuid": "9047a0f8-88ea-4a42-b99b-b5fb166e8088",
      "parentUUID": "a21d3f36-9b8f-4d52-9b6f-e3692901b11a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
      "fullTitle": "updateUser Nel caso in cui non si verifichino errori, il campo statusCode della risposta deve essere impostato a 200",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "users_DAO.updateUser.returns(Rx.Observable.empty());\nlet user =\n{\n  name: \"gianluca\"\n};\nlet ev = { pathParameters: \"mou\", body: JSON.stringify(user) };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).not.to.be.null;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'success' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 200);",
      "err": {},
      "isRoot": false,
      "uuid": "29eab6dc-e65b-4a60-988c-2ae9c38fd5ce",
      "parentUUID": "a21d3f36-9b8f-4d52-9b6f-e3692901b11a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
      "fullTitle": "updateUser Nel caso in cui sia passato un parametro non atteso, il campo statusCode della risposta deve essere impostato a 400",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let ev = { pathParameters: \"\", body: \"\" };\nservice.updateUser(ev, context);\nlet call = context.succeed.getCall(0);\nexpect(context.succeed.calledOnce).to.be.true;\nexpect(call.args[0]).to.have.deep.property('body', JSON.stringify({ message: 'Bad Request' }));\n\t\t\t\t\texpect(call.args[0]).to.have.deep.property('statusCode', 400);",
      "err": {},
      "isRoot": false,
      "uuid": "c5ff3096-f1c4-4306-9ff5-bc1de292eb41",
      "parentUUID": "a21d3f36-9b8f-4d52-9b6f-e3692901b11a",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "fullTitle": "onMessage Nel caso in cui la chiamata al microservizio Notification non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let context = { body: '' };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.reject(JSON.stringify(notifications_error)));\nconversations.addMessage.returns(Rx.Observable.throw(new Error()));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
      "err": {},
      "isRoot": false,
      "uuid": "75a00fd3-8b57-462e-9008-aa7ddd3176e6",
      "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "fullTitle": "onMessage Nel caso in cui la chiamata al microservizio Rules non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let context = { body: '' };\npromise.onCall(0).returns(Promise.reject(JSON.stringify(rules_error)));\nlistener.onMessage(event, context, callback);\nexpect(callback.callCount).to.above(1); // le chiamate a questo microservizio sono almeno una!\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
      "err": {},
      "isRoot": false,
      "uuid": "83aa1bd0-491d-421f-9292-68c4e8e53054",
      "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "fullTitle": "onMessage Nel caso in cui la chiamata ai metodi di GuestsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let context = { body: '' };\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { 'msg': 'error getting guest' });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
      "err": {},
      "isRoot": false,
      "uuid": "e2282794-72b6-49f6-8890-7e1b7e3887f5",
      "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
      "skipped": false
    },
    {
      "title": "Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "fullTitle": "onMessage Nel caso in cui la chiamata ai metodi di ConversationsDAO non vada a buon fine, la funzione di callback deve essere chiamata con un solo parametro diverso da null.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let context = { body: '' };\nlistener.onMessage(event, context, callback);\ndone();\nconversations.addConversation.yield({ 'msg': 'error adding conversation' });\nexpect(callback.callCount).to.above(1);\nexpect(callback.getCall(0).args[0]).to.not.be.null;\nexpect(callback.getCall(0).args[1]).to.be.undefined;",
      "err": {},
      "isRoot": false,
      "uuid": "179cb7ef-cded-4f68-bb66-7b6ba42b3757",
      "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
      "skipped": false
    },
    {
      "title": "Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.",
      "fullTitle": "onMessage Nel caso in cui non ci siano errori, la funzione di callback deve essere chiamata con due parametri, il primo dei quali uguale a null.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "let context = { body: '' };\npromise.onCall(0).returns(Promise.resolve(JSON.stringify(rules_response)));\npromise.onCall(1).returns(Promise.resolve(JSON.stringify(notifications_response)));\nlistener.onMessage(event, context, callback);\ndone();\nguests.getGuest.yield(null, { 'type': 'example' });\nconversations.addConversation.yield(null, {});\nexpect(callback.callCount).to.equal(1);\nexpect(callback.getCall(0).args[0]).to.be.null;\nexpect(callback.getCall(0).args[1]).to.not.be.null;",
      "err": {},
      "isRoot": false,
      "uuid": "0175c2d2-9c56-4bf6-98f8-0fe7d399752b",
      "parentUUID": "78903e0a-42dc-4f53-a6e7-7b9916a41f00",
      "skipped": false
    },
    {
      "title": "Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.",
      "fullTitle": "query Se la richiesta HTTP ad api.ai va a buon fine allora lo status code della risposta deve essere uguale a 200.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.getAgent.returns(Rx.Observable.empty());\n          va.query.returns(Promise.resolve(res_body));\n          service.query({ body: JSON.stringify(req_body) }, context);\n          \nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\texpect(agents.getAgent.callCount).to.equal(1);\n\texpect(agents.getAgent.calledWith('test'));\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(200);\n});",
      "err": {},
      "isRoot": false,
      "uuid": "26943c6b-36c1-4591-899b-99b958b8c87b",
      "parentUUID": "16233e0a-62d6-4264-920a-636c20622f59",
      "skipped": false
    },
    {
      "title": "Se la chiamata al modulo VAModule genera un'errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.",
      "fullTitle": "query Se la chiamata al modulo VAModule genera un'errore, lo status code della risposta deve essere uguale al codice di errore ricevuto.",
      "timedOut": false,
      "duration": 4,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "agents.getAgent.returns(Rx.Observable.throw(new Error()));\n          va.query.returns(Promise.resolve(error));\n          service.query({ body: JSON.stringify(req_body) }, context);\n          \nsetTimeout(function()\n{\n\texpect(context.succeed.callCount).to.equal(1);\n\tlet result = context.succeed.getCall(0).args[0];\n\texpect(result).to.not.be.null;\n\texpect(result.statusCode).to.equal(412);\n});",
      "err": {},
      "isRoot": false,
      "uuid": "d9b71483-53e7-4d59-ae4d-5003ac406d76",
      "parentUUID": "16233e0a-62d6-4264-920a-636c20622f59",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_addRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 4,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._addRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "ff6f0521-106c-4d65-bda0-c5d06f974239",
      "parentUUID": "81cb31d0-ac2f-452c-9542-317b14c7a96e",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_addUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._addUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "e8fa641b-4a95-40f9-b87c-e030c2b411e7",
      "parentUUID": "416dab94-3533-4280-9a42-f1128bc5226b",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_getRuleList Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._getRuleList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "cf3616ad-feba-4d3d-a924-05d5b2fe7956",
      "parentUUID": "4108b2b3-b97a-49fe-81b0-8e39c54a421e",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_getUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._getUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "595d8437-7df9-43b7-b580-c051c833926b",
      "parentUUID": "e59073d2-5134-4fc2-9749-afa301669c38",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_getUserList Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 3,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._getUserList().subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "6949a687-3043-46b4-9332-b074e13746b4",
      "parentUUID": "e771685a-9cdb-456c-890c-c6b9273d9487",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.",
      "fullTitle": "queryLambda Se la chiamata al servizio di STT non va a buon fine allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente statusCode pari a 500.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "583e7901-d1c5-4fe4-86b9-13d4a3ce203e",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se lo status della risposta ricevuta dall'assistente virtuale  diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio 'Errore nel contattare l'assistente virtuale'.",
      "fullTitle": "queryLambda Se lo status della risposta ricevuta dall'assistente virtuale  diverso da 200 allora il metodo deve chiamare il metodo succeed di context con un oggetto di tipo LambdaResponse come parametro avente il campo statusCode uguale a quello ricevuto e corpo del messaggio 'Errore nel contattare l'assistente virtuale'.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "949b81aa-ddc8-4a4b-9190-bf18e33e54b8",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'rule.add' allora il metodo deve chiamare il metodo privato _addRule.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'rule.add' allora il metodo deve chiamare il metodo privato _addRule.",
      "timedOut": false,
      "duration": 7,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "api._addRule = sinon.stub();\nstt.speechToText.returns(Promise.resolve('Test'));\n          promise.onCall(0).returns(Promise.resolve(va_response_addRule));\n          promise.onCall(1).returns(Promise.resolve(empty_action_response));\n          api._addRule.returns(Rx.Observable.empty());\ncontext.succeed = function(response)\n          {\n            //controllo che i campi non siano nulli, quindi chiamo done\n\texpect(api._addRule.callCount).to.equal(1);\n            done();\n          }\n          api.queryLambda(event, context);",
      "err": {},
      "isRoot": false,
      "uuid": "5e9f7648-3fe4-4443-935a-310e61ed678d",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.add' allora il metodo deve chiamare il metodo privato _addUser.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.add' allora il metodo deve chiamare il metodo privato _addUser.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "fbfd4f11-e04a-4dec-842b-95869763f778",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.addEnrollment' allora il metodo deve chiamare il metodo privato _addUserEnrollment.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.addEnrollment' allora il metodo deve chiamare il metodo privato _addUserEnrollment.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "658c3032-e0e4-4dc1-8542-7cc206941890",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'rule.get' allora il metodo deve chiamare il metodo privato _getRule.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'rule.get' allora il metodo deve chiamare il metodo privato _getRule.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "988b12cf-c46e-4b5a-a5da-a9fbe4835a1c",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'rule.getList' allora il metodo deve chiamare il metodo privato _getRuleList.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'rule.getList' allora il metodo deve chiamare il metodo privato _getRuleList.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "99a7d5ec-e2ec-400c-a26a-daff2c3dff09",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.get' allora il metodo deve chiamare il metodo privato _getUser.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.get' allora il metodo deve chiamare il metodo privato _getUser.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "9848483b-ab68-4ab3-8c39-1d3c32a3e85c",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.getList' allora il metodo deve chiamare il metodo privato _getUserList.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.getList' allora il metodo deve chiamare il metodo privato _getUserList.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "e3612547-bc6e-4334-96da-90a503de5759",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.login' allora il metodo deve chiamare il metodo privato _loginUser.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.login' allora il metodo deve chiamare il metodo privato _loginUser.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "5b91c259-8079-4a76-99fb-9529861bb57d",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'rule.remove' allora il metodo deve chiamare il metodo privato _removeRule.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'rule.remove' allora il metodo deve chiamare il metodo privato _removeRule.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "ae28f2fb-1c74-4d56-82bd-09249f9b2944",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.remove' allora il metodo deve chiamare il metodo privato _removeUser.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.remove' allora il metodo deve chiamare il metodo privato _removeUser.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "38e2757e-47bb-455b-9a16-1723dc95bf89",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.resetEnrollment' allora il metodo deve chiamare il metodo privato _resetUserEnrollment.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.resetEnrollment' allora il metodo deve chiamare il metodo privato _resetUserEnrollment.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "5628ba86-dfbb-4ec3-82cc-862f9278dea1",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'rule.update' allora il metodo deve chiamare il metodo privato _updateRule.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'rule.update' allora il metodo deve chiamare il metodo privato _updateRule.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "9a22581d-2dfd-4374-98b3-362d4b0b256d",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se l'action del body della risposta  uguale a 'user.update' allora il metodo deve chiamare il metodo privato _updateUser.",
      "fullTitle": "queryLambda Se l'action del body della risposta  uguale a 'user.update' allora il metodo deve chiamare il metodo privato _updateUser.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "c61a2eb0-32b2-4732-8d7e-71d6cc7b7638",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _addRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "e0bd704a-494b-4da0-a41f-99de192dd690",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _addUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "c234ea6e-6bb8-4f6c-984a-a39dd5e2b1b9",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _addUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "d1fc3c08-6c09-41f8-a3b5-d07a45e7b0b1",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _getRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "7423b8fd-e8d0-4730-90de-d2721997f836",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _getRuleList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "0772f537-14b1-4030-9411-25348fbdff5a",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _getUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "14258172-9f19-4a1b-baac-21b069dcc2d4",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _getUserList si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "a956bd2d-27e0-43f7-81ec-0ab80c76e493",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _loginUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "a714bccc-015e-4d59-b048-057d5673c136",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _removeRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "7b9c9419-6ac0-4782-8632-db65abea1178",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _removeUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "acbe1440-eb09-41d4-b0d9-4871d25b7da6",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _resetUserEnrollment si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "e59430c7-587a-4d1c-9a5e-fcc8762e82f8",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _updateRule si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio Rule.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "36389c3d-9499-4aed-9a58-447f8e5c9716",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "fullTitle": "queryLambda Se durante la chiamata al metodo privato _updateUser si verifica un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse il quale campo statusCode  impostato ad un valore uguale a quello restituito dal microservizio User.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "b9edd18e-a431-40d4-854d-7ca53cb20232",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari allo status dell'errore.",
      "fullTitle": "queryLambda Se la chiamata al metodo sns.publish genera un errore allora il metodo deve chiamare il metodo succeed del context con un parametro LambdaResponse avente campo statusCode pari allo status dell'errore.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "720adc5e-2640-4ce2-96cf-be140b0c6f25",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se lo status code della risposta di un microservizio  pari a 200 e l'action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.",
      "fullTitle": "queryLambda Se lo status code della risposta di un microservizio  pari a 200 e l'action contenuta nel suo body non corrisponde a nessuna action supportata dal back-end allora il metodo deve rielabolare la risposta e inoltrarla.",
      "timedOut": false,
      "duration": 0,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "",
      "err": {},
      "isRoot": false,
      "uuid": "e3948158-affd-4224-9e83-0149050d04c1",
      "parentUUID": "ebbc15d4-867c-475c-9353-0fefb7514069",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_removeRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._removeRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "141f4f30-4ff7-4c7f-b728-6851abbb3d37",
      "parentUUID": "7c914302-e6ad-49e8-9771-b1b677d0f05e",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_removeUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 3,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._removeUser('mou').subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "daf11510-401b-413e-bd1f-76e05f6de872",
      "parentUUID": "0a9e3709-fc73-4f47-8ae2-1aad8bc3420c",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_updateRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._updateRule(rule).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "e07a3412-7087-4174-871c-352e867b8043",
      "parentUUID": "9db1915e-bb37-4e6e-b8a6-3d12d3a3d7ab",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_updateUser Se la risposta ricevuta dal microservizio Users ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 4,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._updateUser(user).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {},
      "isRoot": false,
      "uuid": "70747eb8-1151-4d2c-9b3c-0786fd2e5fb7",
      "parentUUID": "70b2ad21-56e9-49de-b504-81d363cdefc5",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "fullTitle": "addEnrollment Se la chiamata al servizio di Speaker Recognition per aggiungere un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "timedOut": false,
      "duration": 3,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.addEnrollment().subscribe(\n{\n  next: next,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tcomplete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});",
      "err": {},
      "isRoot": false,
      "uuid": "7a7e915c-e835-4785-9a96-b0cc37d8970f",
      "parentUUID": "5915b3d6-0198-4526-980a-b013aa879e1a",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.",
      "fullTitle": "createUser Se la chiamata al servizio di Speaker Recognition per creare un utente ritorna uno statusCode diverso da 200, StringObservable deve notificare lo StringObserver chiamando il suo metodo error.",
      "timedOut": false,
      "duration": 1,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.createUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
      "err": {},
      "isRoot": false,
      "uuid": "eccb4a39-962a-4f3a-a6f8-e86589269f4a",
      "parentUUID": "8289f800-d2cf-473a-9c24-d259725382c5",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "fullTitle": "deleteUser Se la chiamata al servizio di Speaker Recognition per eliminare un utente ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.deleteUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
      "err": {},
      "isRoot": false,
      "uuid": "cf0cf000-146e-4040-86cf-061a2850ddb6",
      "parentUUID": "b296dfee-7cb9-4158-acb4-82698071dff8",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo 'result' pari a 'Reject', l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "fullTitle": "doLogin Se la chiamata al servizio di Speaker Recognition per effettuare il login ritorna un oggetto con campo 'result' pari a 'Reject', l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject({ \"result\" : \"Reject\" }));\nmicrosoft_login.doLogin().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
      "err": {},
      "isRoot": false,
      "uuid": "2476e090-845f-47c9-b8ec-3e8cb74da2fb",
      "parentUUID": "990aebc1-8494-46d3-9123-236660e612ca",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
      "fullTitle": "getList Se la chiamata al servizio di Speaker Recognition per ottenere la lista degli utenti ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.getList().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
      "err": {},
      "isRoot": false,
      "uuid": "6d2b6082-9fb3-4105-97de-dc3038e560dd",
      "parentUUID": "0a551883-894e-47c9-8981-ab12e485d5e2",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
      "fullTitle": "getUser Se la chiamata al servizio di Speaker Recognition per ottenere un utente ritorna uno statusCode diverso da 200, SRUserObservable deve notificare l'SRUserObserver chiamando il suo metodo error.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(\n  {\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.getUser().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
      "err": {},
      "isRoot": false,
      "uuid": "27cc3c17-0123-49d7-9d5d-6ea8e226ae0b",
      "parentUUID": "2035d6cd-adc3-4ff2-9ec0-b2aafe8cd5fb",
      "skipped": false
    },
    {
      "title": "Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "fullTitle": "resetEnrollment Se la chiamata al servizio di Speaker Recognition per resettare un Enrollment ritorna uno statusCode diverso da 200, l'ErrorObservable deve notificare l'ErrorObserver chiamando il suo metodo error.",
      "timedOut": false,
      "duration": 2,
      "state": "passed",
      "speed": "fast",
      "pass": true,
      "fail": false,
      "pending": false,
      "code": "promise.returns(Promise.reject(\n{\n  \"error\" :\n  {\n    \"code\" : \"InternalServerError\",\n    \"message\" : \"SpeakerInvalid\"\n  }\n}));\nmicrosoft_login.resetEnrollment().subscribe(\n{\n  next: next,\n  error: error,\n  complete: complete\n});\nsetTimeout(function()\n\t\t\t\t\t{\t\n\t\t\t\t\t\texpect(next.callCount).to.equal(0);\n\t\t\t\t\t\texpect(complete.callCount).to.equal(0);\n\t\t\t\t\t\texpect(error.callCount).to.equal(1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t})",
      "err": {},
      "isRoot": false,
      "uuid": "ae6b267d-a925-46f4-a76b-a6ed8e2aa5b0",
      "parentUUID": "5b90d4b3-27c9-48b5-aa79-aaade1225681",
      "skipped": false
    }
  ],
  "allFailures": [
    {
      "title": "La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.",
      "fullTitle": "webhook La risposte dovrebbe avere il campo statusCode impostato a 200 nel caso in cui venga passato un JWT corretto.",
      "timedOut": false,
      "duration": 1,
      "state": "failed",
      "pass": false,
      "fail": true,
      "pending": false,
      "code": "jwt.verify.returns(1);\nservice.webhook(ev, { succeed: function(res) { expect(res.statusCode).to.equal(200); done(); }});",
      "err": {
        "estack": "TypeError: service.webhook is not a function\n  at Context.<anonymous> (src\\test\\test_AdministrationWebhookService.js:72:17)\n"
      },
      "isRoot": false,
      "uuid": "f58b050b-acad-45a7-810c-408e8eb9b8f7",
      "parentUUID": "49cbbc3d-5775-435f-943e-eb1fc7b9224c",
      "skipped": false
    },
    {
      "title": "La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.",
      "fullTitle": "webhook La risposta dovrebbe avere il campo statusCode impostato a 403 nel caso in cui la richiesta contenga un JWT non valido.",
      "timedOut": false,
      "duration": 1,
      "state": "failed",
      "pass": false,
      "fail": true,
      "pending": false,
      "code": "jwt.verify.throws();\nservice.webhook(ev, { succeed: function(res)\n{\n  let body = JSON.parse(res.body);\n  expect(body.data._status).to.equal(403);\n  done();\n}});",
      "err": {
        "estack": "TypeError: service.webhook is not a function\n  at Context.<anonymous> (src\\test\\test_AdministrationWebhookService.js:78:17)\n"
      },
      "isRoot": false,
      "uuid": "aeb5ec22-81aa-4ffd-9170-3799ac0938cb",
      "parentUUID": "49cbbc3d-5775-435f-943e-eb1fc7b9224c",
      "skipped": false
    },
    {
      "title": "Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.",
      "fullTitle": "speechToText Se la chiamata al metodo stt.recognize fallisce allora il metodo deve chiamare il metodo rejected della Promise con un parametro onRejected avente campo code 500.",
      "timedOut": false,
      "duration": 0,
      "state": "failed",
      "pass": false,
      "fail": true,
      "pending": false,
      "code": "let reject = sinon.stub();\nlet promise = watson.speechToText();\npromise.catch(reject);\ndone();\nexpect(reject.callCount).to.equal(1);\nlet call = reject.getCall(0);\nexpect(call.args[0]).to.deep.equal({code: 500});",
      "err": {
        "estack": "TypeError: this.streamifier.createReadStream is not a function\n  at STTWatsonAdapter.speechToText (src\\Back-end\\STT\\STTWatsonAdapter.js:24:31)\n  at Context.<anonymous> (src\\test\\test_STTWatsonAdapter.js:20:27)\n"
      },
      "isRoot": false,
      "uuid": "22b323e5-4414-433b-8d21-a5a8c44dac14",
      "parentUUID": "36203f4f-132f-485a-ac03-b4b81bfda3c6",
      "skipped": false
    },
    {
      "title": "Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "fullTitle": "_getRule Se la risposta ricevuta dal microservizio Rules ha uno status code diverso da 200 allora l'Observable ritornato deve chiamare il metodo error dell'Observer iscritto passandogli come parametro un oggetto di tipo Exception con campo code pari allo status code della risposta.",
      "timedOut": false,
      "duration": 1,
      "state": "failed",
      "pass": false,
      "fail": true,
      "pending": false,
      "code": "promise.returns(Promise.reject(errore));\napi._getRule(5).subscribe(\n{\n\tnext: next,\n\terror: error,\n\tcomplete: complete\n});\nsetTimeout(function()\n{\n\texpect(error.callCount).to.equal(1);\n\texpect(error.getCall(0).args[0]).to.have.property('code', 500);\n\texpect(next.callCount).to.equal(0);\n\texpect(complete.callCount).to.equal(0);\n\tdone();\n});",
      "err": {
        "estack": "ReferenceError: S_SERVICE_URL is not defined\n  at Observable._subscribe (src\\Back-end\\APIGateway\\VocalAPI.js:134:13)\n  at Observable._trySubscribe (node_modules\\rxjs\\Observable.js:57:25)\n  at Observable.subscribe (node_modules\\rxjs\\Observable.js:45:27)\n  at Context.<anonymous> (src\\test\\test_VocalAPI.js:86:22)\n"
      },
      "isRoot": false,
      "uuid": "bc261c7c-9476-4010-894b-2b668a7e529b",
      "parentUUID": "73e77d55-28dd-48e5-9c30-d906ccab88dc",
      "skipped": false
    }
  ],
  "copyrightYear": 2017
}